/* BKRepoServiceStub.h
   Generated by gSOAP 2.8.6 from BKRepoService.h

Copyright(C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef BKRepoServiceStub_H
#define BKRepoServiceStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://com.bk.repo"
#include "stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns1__cowSex
#define SOAP_TYPE_ns1__cowSex (47)
/* ns1:cowSex */
enum ns1__cowSex {ns1__cowSex__XX = 0, ns1__cowSex__XY = 1, ns1__cowSex__NONE = 2};
#endif

#ifndef SOAP_TYPE_ns1__hentType
#define SOAP_TYPE_ns1__hentType (48)
/* ns1:hentType */
enum ns1__hentType {ns1__hentType__INDIVIDUAL = 0, ns1__hentType__COMPANY = 1};
#endif

#ifndef SOAP_TYPE_ns1__payWay
#define SOAP_TYPE_ns1__payWay (49)
/* ns1:payWay */
enum ns1__payWay {ns1__payWay__CASH = 0, ns1__payWay__TRANSFER = 1};
#endif

#ifndef SOAP_TYPE_ns1__invoiceType
#define SOAP_TYPE_ns1__invoiceType (50)
/* ns1:invoiceType */
enum ns1__invoiceType {ns1__invoiceType__LUMP = 0, ns1__invoiceType__REGULAR = 1};
#endif

#ifndef SOAP_TYPE_ns1__status
#define SOAP_TYPE_ns1__status (51)
/* ns1:status */
enum ns1__status {ns1__status__SUCCESS = 0, ns1__status__FAILURE = 1};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_ns1__hent
#define SOAP_TYPE_ns1__hent (8)
/* ns1:hent */
class SOAP_CMAC ns1__hent
{
public:
	std::string *bankaccountno;	/* required element of type xsd:string */
	std::string alias;	/* required element of type xsd:string */
	std::string farmno;	/* required element of type xsd:string */
	std::string *bankname;	/* required element of type xsd:string */
	std::string *cellphoneno;	/* required element of type xsd:string */
	std::string city;	/* required element of type xsd:string */
	std::string *emailaddress;	/* required element of type xsd:string */
	std::string *extras;	/* required element of type xsd:string */
	enum ns1__hentType henttype;	/* required element of type ns1:hentType */
	std::string *idno;	/* required element of type xsd:string */
	time_t *issuedate;	/* required element of type xsd:dateTime */
	std::string *issuepost;	/* required element of type xsd:string */
	double *latitude;	/* required element of type xsd:double */
	double *longitude;	/* required element of type xsd:double */
	std::string name;	/* required element of type xsd:string */
	std::string *nip;	/* required element of type xsd:string */
	std::string *pesel;	/* required element of type xsd:string */
	std::string *phone;	/* required element of type xsd:string */
	std::string *plate;	/* required element of type xsd:string */
	std::string pobox;	/* required element of type xsd:string */
	std::string *regon;	/* required element of type xsd:string */
	std::string street;	/* required element of type xsd:string */
	std::string *wetlicenceno;	/* required element of type xsd:string */
	std::string *wetno;	/* required element of type xsd:string */
	std::string zip;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 8; } /* = unique id SOAP_TYPE_ns1__hent */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__hent() { ns1__hent::soap_default(NULL); }
	virtual ~ns1__hent() { }
};
#endif

#ifndef SOAP_TYPE_ns1__stock
#define SOAP_TYPE_ns1__stock (9)
/* ns1:stock */
class SOAP_CMAC ns1__stock
{
public:
	std::string stockCode;	/* required element of type xsd:string */
	std::string *stockName;	/* required element of type xsd:string */
	double *pricePerKg;	/* required element of type xsd:double */
	enum ns1__cowSex preDefSex;	/* required element of type ns1:cowSex */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 9; } /* = unique id SOAP_TYPE_ns1__stock */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__stock() { ns1__stock::soap_default(NULL); }
	virtual ~ns1__stock() { }
};
#endif

#ifndef SOAP_TYPE_ns1__company
#define SOAP_TYPE_ns1__company (10)
/* ns1:company */
class SOAP_CMAC ns1__company
{
public:
	std::string name;	/* required element of type xsd:string */
	std::string street;	/* required element of type xsd:string */
	std::string POBox;	/* required element of type xsd:string */
	std::string city;	/* required element of type xsd:string */
	std::string zip;	/* required element of type xsd:string */
	std::string farmNo;	/* required element of type xsd:string */
	std::string cellPhoneNo;	/* required element of type xsd:string */
	std::string phoneNo;	/* required element of type xsd:string */
	std::string emailAddress;	/* required element of type xsd:string */
	std::string nip;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 10; } /* = unique id SOAP_TYPE_ns1__company */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__company() { ns1__company::soap_default(NULL); }
	virtual ~ns1__company() { }
};
#endif

#ifndef SOAP_TYPE_ns1__cow
#define SOAP_TYPE_ns1__cow (11)
/* ns1:cow */
class SOAP_CMAC ns1__cow
{
public:
	std::string cowNo;	/* required element of type xsd:string */
	enum ns1__cowSex sex;	/* required element of type ns1:cowSex */
	std::string stockCode;	/* required element of type xsd:string */
	double weight;	/* required element of type xsd:double */
	double price;	/* required element of type xsd:double */
	double *latitude;	/* required element of type xsd:double */
	double *longitude;	/* required element of type xsd:double */
	std::string *passportNo;	/* required element of type xsd:string */
	std::string *firstOwnerNo;	/* required element of type xsd:string */
	time_t *passportIssueDt;	/* required element of type xsd:dateTime */
	std::string *healthCertNo;	/* required element of type xsd:string */
	std::string *motherNo;	/* required element of type xsd:string */
	std::string *birthPlace;	/* required element of type xsd:string */
	time_t *birthDt;	/* required element of type xsd:dateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 11; } /* = unique id SOAP_TYPE_ns1__cow */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__cow() { ns1__cow::soap_default(NULL); }
	virtual ~ns1__cow() { }
};
#endif

#ifndef SOAP_TYPE_ns1__invoice
#define SOAP_TYPE_ns1__invoice (12)
/* ns1:invoice */
class SOAP_CMAC ns1__invoice
{
public:
	time_t invoiceDate;	/* required element of type xsd:dateTime */
	time_t *transactionDate;	/* required element of type xsd:dateTime */
	std::string *transactionPlace;	/* required element of type xsd:string */
	double vatrate;	/* required element of type xsd:double */
	enum ns1__payWay payWay;	/* required element of type ns1:payWay */
	std::string *customNumber;	/* required element of type xsd:string */
	int payDueDays;	/* required element of type xsd:int */
	std::string invoiceHentNo;	/* required element of type xsd:string */
	enum ns1__invoiceType invoiceType;	/* required element of type ns1:invoiceType */
	std::vector<ns1__cow * >cows;	/* required element of type ns1:cow */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_ns1__invoice */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__invoice() { ns1__invoice::soap_default(NULL); }
	virtual ~ns1__invoice() { }
};
#endif

#ifndef SOAP_TYPE_ns1__purchase
#define SOAP_TYPE_ns1__purchase (13)
/* ns1:purchase */
class SOAP_CMAC ns1__purchase
{
public:
	std::string plateNo;	/* required element of type xsd:string */
	time_t startDate;	/* required element of type xsd:dateTime */
	time_t endDate;	/* required element of type xsd:dateTime */
	std::vector<ns1__invoice * >invoices;	/* required element of type ns1:invoice */
	std::vector<ns1__hent * >hents;	/* required element of type ns1:hent */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE_ns1__purchase */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__purchase() { ns1__purchase::soap_default(NULL); }
	virtual ~ns1__purchase() { }
};
#endif

#ifndef SOAP_TYPE_ns1__result
#define SOAP_TYPE_ns1__result (15)
/* ns1:result */
class SOAP_CMAC ns1__result
{
public:
	std::string msg;	/* required element of type xsd:string */
	enum ns1__status status;	/* required element of type ns1:status */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_ns1__result */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__result() { ns1__result::soap_default(NULL); }
	virtual ~ns1__result() { }
};
#endif

#ifndef SOAP_TYPE_ns1__openMobileSessionRequest
#define SOAP_TYPE_ns1__openMobileSessionRequest (16)
/* ns1:openMobileSessionRequest */
class SOAP_CMAC ns1__openMobileSessionRequest
{
public:
	std::string login;	/* required element of type xsd:string */
	std::string password;	/* required element of type xsd:string */
	std::string agent;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_ns1__openMobileSessionRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__openMobileSessionRequest() { ns1__openMobileSessionRequest::soap_default(NULL); }
	virtual ~ns1__openMobileSessionRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns1__openOfficeSessionRequest
#define SOAP_TYPE_ns1__openOfficeSessionRequest (17)
/* ns1:openOfficeSessionRequest */
class SOAP_CMAC ns1__openOfficeSessionRequest
{
public:
	std::string login;	/* required element of type xsd:string */
	std::string password;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_ns1__openOfficeSessionRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__openOfficeSessionRequest() { ns1__openOfficeSessionRequest::soap_default(NULL); }
	virtual ~ns1__openOfficeSessionRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns1__openSessionResponse
#define SOAP_TYPE_ns1__openSessionResponse (18)
/* ns1:openSessionResponse */
class SOAP_CMAC ns1__openSessionResponse
{
public:
	std::string sessionId;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	ns1__result *result;	/* required element of type ns1:result */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_ns1__openSessionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__openSessionResponse() { ns1__openSessionResponse::soap_default(NULL); }
	virtual ~ns1__openSessionResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__sessionRequest
#define SOAP_TYPE_ns1__sessionRequest (19)
/* ns1:sessionRequest */
class SOAP_CMAC ns1__sessionRequest
{
public:
	std::string sessionId;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_ns1__sessionRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__sessionRequest() { ns1__sessionRequest::soap_default(NULL); }
	virtual ~ns1__sessionRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns1__closeSyncTransactionRequest
#define SOAP_TYPE_ns1__closeSyncTransactionRequest (21)
/* ns1:closeSyncTransactionRequest */
class SOAP_CMAC ns1__closeSyncTransactionRequest
{
public:
	ns1__sessionRequest *session;	/* required element of type ns1:sessionRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_ns1__closeSyncTransactionRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__closeSyncTransactionRequest() { ns1__closeSyncTransactionRequest::soap_default(NULL); }
	virtual ~ns1__closeSyncTransactionRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns1__closeSyncTransactionResponse
#define SOAP_TYPE_ns1__closeSyncTransactionResponse (22)
/* ns1:closeSyncTransactionResponse */
class SOAP_CMAC ns1__closeSyncTransactionResponse
{
public:
	ns1__result *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:result */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE_ns1__closeSyncTransactionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__closeSyncTransactionResponse() { ns1__closeSyncTransactionResponse::soap_default(NULL); }
	virtual ~ns1__closeSyncTransactionResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__commitSyncTransactionRequest
#define SOAP_TYPE_ns1__commitSyncTransactionRequest (23)
/* ns1:commitSyncTransactionRequest */
class SOAP_CMAC ns1__commitSyncTransactionRequest
{
public:
	ns1__sessionRequest *session;	/* required element of type ns1:sessionRequest */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_ns1__commitSyncTransactionRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__commitSyncTransactionRequest() { ns1__commitSyncTransactionRequest::soap_default(NULL); }
	virtual ~ns1__commitSyncTransactionRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns1__commitSyncTransactionResponse
#define SOAP_TYPE_ns1__commitSyncTransactionResponse (24)
/* ns1:commitSyncTransactionResponse */
class SOAP_CMAC ns1__commitSyncTransactionResponse
{
public:
	ns1__result *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:result */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_ns1__commitSyncTransactionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__commitSyncTransactionResponse() { ns1__commitSyncTransactionResponse::soap_default(NULL); }
	virtual ~ns1__commitSyncTransactionResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__updateHentRequest
#define SOAP_TYPE_ns1__updateHentRequest (25)
/* ns1:updateHentRequest */
class SOAP_CMAC ns1__updateHentRequest
{
public:
	ns1__sessionRequest *session;	/* required element of type ns1:sessionRequest */
	ns1__hent *hent;	/* required element of type ns1:hent */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_ns1__updateHentRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__updateHentRequest() { ns1__updateHentRequest::soap_default(NULL); }
	virtual ~ns1__updateHentRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns1__updateHentResponse
#define SOAP_TYPE_ns1__updateHentResponse (26)
/* ns1:updateHentResponse */
class SOAP_CMAC ns1__updateHentResponse
{
public:
	ns1__result *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:result */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_ns1__updateHentResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__updateHentResponse() { ns1__updateHentResponse::soap_default(NULL); }
	virtual ~ns1__updateHentResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__updateStockRequest
#define SOAP_TYPE_ns1__updateStockRequest (27)
/* ns1:updateStockRequest */
class SOAP_CMAC ns1__updateStockRequest
{
public:
	ns1__sessionRequest *session;	/* required element of type ns1:sessionRequest */
	ns1__stock *stock;	/* required element of type ns1:stock */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_ns1__updateStockRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__updateStockRequest() { ns1__updateStockRequest::soap_default(NULL); }
	virtual ~ns1__updateStockRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns1__updateStockResponse
#define SOAP_TYPE_ns1__updateStockResponse (28)
/* ns1:updateStockResponse */
class SOAP_CMAC ns1__updateStockResponse
{
public:
	ns1__result *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:result */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_ns1__updateStockResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__updateStockResponse() { ns1__updateStockResponse::soap_default(NULL); }
	virtual ~ns1__updateStockResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__fetchHentsResponse
#define SOAP_TYPE_ns1__fetchHentsResponse (29)
/* ns1:fetchHentsResponse */
class SOAP_CMAC ns1__fetchHentsResponse
{
public:
	ns1__result *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:result */
	std::vector<ns1__hent * >hents;	/* optional element of type ns1:hent */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_ns1__fetchHentsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__fetchHentsResponse() { ns1__fetchHentsResponse::soap_default(NULL); }
	virtual ~ns1__fetchHentsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__closeSessionResponse
#define SOAP_TYPE_ns1__closeSessionResponse (30)
/* ns1:closeSessionResponse */
class SOAP_CMAC ns1__closeSessionResponse
{
public:
	ns1__result *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:result */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_ns1__closeSessionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__closeSessionResponse() { ns1__closeSessionResponse::soap_default(NULL); }
	virtual ~ns1__closeSessionResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__openSyncTransactionResponse
#define SOAP_TYPE_ns1__openSyncTransactionResponse (31)
/* ns1:openSyncTransactionResponse */
class SOAP_CMAC ns1__openSyncTransactionResponse
{
public:
	ns1__result *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:result */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_ns1__openSyncTransactionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__openSyncTransactionResponse() { ns1__openSyncTransactionResponse::soap_default(NULL); }
	virtual ~ns1__openSyncTransactionResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__closeHentCursorResponse
#define SOAP_TYPE_ns1__closeHentCursorResponse (32)
/* ns1:closeHentCursorResponse */
class SOAP_CMAC ns1__closeHentCursorResponse
{
public:
	ns1__result *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:result */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_ns1__closeHentCursorResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__closeHentCursorResponse() { ns1__closeHentCursorResponse::soap_default(NULL); }
	virtual ~ns1__closeHentCursorResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__openHentCursorResponse
#define SOAP_TYPE_ns1__openHentCursorResponse (33)
/* ns1:openHentCursorResponse */
class SOAP_CMAC ns1__openHentCursorResponse
{
public:
	ns1__result *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:result */
	int minFetch;	/* required element of type xsd:int */
	int maxFetch;	/* required element of type xsd:int */
	int count;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_ns1__openHentCursorResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__openHentCursorResponse() { ns1__openHentCursorResponse::soap_default(NULL); }
	virtual ~ns1__openHentCursorResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__openStockCursorResponse
#define SOAP_TYPE_ns1__openStockCursorResponse (34)
/* ns1:openStockCursorResponse */
class SOAP_CMAC ns1__openStockCursorResponse
{
public:
	ns1__result *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:result */
	int minFetch;	/* required element of type xsd:int */
	int maxFetch;	/* required element of type xsd:int */
	int count;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_ns1__openStockCursorResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__openStockCursorResponse() { ns1__openStockCursorResponse::soap_default(NULL); }
	virtual ~ns1__openStockCursorResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__closeStockCursorResponse
#define SOAP_TYPE_ns1__closeStockCursorResponse (35)
/* ns1:closeStockCursorResponse */
class SOAP_CMAC ns1__closeStockCursorResponse
{
public:
	ns1__result *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:result */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_ns1__closeStockCursorResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__closeStockCursorResponse() { ns1__closeStockCursorResponse::soap_default(NULL); }
	virtual ~ns1__closeStockCursorResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__fetchStocksResponse
#define SOAP_TYPE_ns1__fetchStocksResponse (36)
/* ns1:fetchStocksResponse */
class SOAP_CMAC ns1__fetchStocksResponse
{
public:
	std::vector<ns1__stock * >stocks;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:stock */
	ns1__result *result;	/* required element of type ns1:result */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_ns1__fetchStocksResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__fetchStocksResponse() { ns1__fetchStocksResponse::soap_default(NULL); }
	virtual ~ns1__fetchStocksResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__updateCompanyResponse
#define SOAP_TYPE_ns1__updateCompanyResponse (37)
/* ns1:updateCompanyResponse */
class SOAP_CMAC ns1__updateCompanyResponse
{
public:
	ns1__result *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:result */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_ns1__updateCompanyResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__updateCompanyResponse() { ns1__updateCompanyResponse::soap_default(NULL); }
	virtual ~ns1__updateCompanyResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__updateCompanyRequest
#define SOAP_TYPE_ns1__updateCompanyRequest (38)
/* ns1:updateCompanyRequest */
class SOAP_CMAC ns1__updateCompanyRequest
{
public:
	ns1__sessionRequest *session;	/* required element of type ns1:sessionRequest */
	ns1__company *company;	/* required element of type ns1:company */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE_ns1__updateCompanyRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__updateCompanyRequest() { ns1__updateCompanyRequest::soap_default(NULL); }
	virtual ~ns1__updateCompanyRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns1__fetchCompanyResponse
#define SOAP_TYPE_ns1__fetchCompanyResponse (39)
/* ns1:fetchCompanyResponse */
class SOAP_CMAC ns1__fetchCompanyResponse
{
public:
	ns1__company *company;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:company */
	ns1__result *result;	/* required element of type ns1:result */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE_ns1__fetchCompanyResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__fetchCompanyResponse() { ns1__fetchCompanyResponse::soap_default(NULL); }
	virtual ~ns1__fetchCompanyResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__uploadPurchaseRequest
#define SOAP_TYPE_ns1__uploadPurchaseRequest (40)
/* ns1:uploadPurchaseRequest */
class SOAP_CMAC ns1__uploadPurchaseRequest
{
public:
	ns1__sessionRequest *session;	/* required element of type ns1:sessionRequest */
	ns1__purchase *purchase;	/* required element of type ns1:purchase */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE_ns1__uploadPurchaseRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__uploadPurchaseRequest() { ns1__uploadPurchaseRequest::soap_default(NULL); }
	virtual ~ns1__uploadPurchaseRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns1__uploadPurchaseResponse
#define SOAP_TYPE_ns1__uploadPurchaseResponse (41)
/* ns1:uploadPurchaseResponse */
class SOAP_CMAC ns1__uploadPurchaseResponse
{
public:
	ns1__result *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:result */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_ns1__uploadPurchaseResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__uploadPurchaseResponse() { ns1__uploadPurchaseResponse::soap_default(NULL); }
	virtual ~ns1__uploadPurchaseResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__openPurchaseCursorResponse
#define SOAP_TYPE_ns1__openPurchaseCursorResponse (42)
/* ns1:openPurchaseCursorResponse */
class SOAP_CMAC ns1__openPurchaseCursorResponse
{
public:
	ns1__result *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:result */
	int minFetch;	/* required element of type xsd:int */
	int maxFetch;	/* required element of type xsd:int */
	int count;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE_ns1__openPurchaseCursorResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__openPurchaseCursorResponse() { ns1__openPurchaseCursorResponse::soap_default(NULL); }
	virtual ~ns1__openPurchaseCursorResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__closePurchaseCursorResponse
#define SOAP_TYPE_ns1__closePurchaseCursorResponse (43)
/* ns1:closePurchaseCursorResponse */
class SOAP_CMAC ns1__closePurchaseCursorResponse
{
public:
	ns1__result *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:result */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE_ns1__closePurchaseCursorResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__closePurchaseCursorResponse() { ns1__closePurchaseCursorResponse::soap_default(NULL); }
	virtual ~ns1__closePurchaseCursorResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__fetchPurchasesResponse
#define SOAP_TYPE_ns1__fetchPurchasesResponse (44)
/* ns1:fetchPurchasesResponse */
class SOAP_CMAC ns1__fetchPurchasesResponse
{
public:
	std::vector<class ns1__qualifiedPurchase * >purchase;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:qualifiedPurchase */
	ns1__result *result;	/* required element of type ns1:result */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE_ns1__fetchPurchasesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__fetchPurchasesResponse() { ns1__fetchPurchasesResponse::soap_default(NULL); }
	virtual ~ns1__fetchPurchasesResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__downloadPurchaseResponse
#define SOAP_TYPE_ns1__downloadPurchaseResponse (45)
/* ns1:downloadPurchaseResponse */
class SOAP_CMAC ns1__downloadPurchaseResponse
{
public:
	ns1__result *result;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:result */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE_ns1__downloadPurchaseResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__downloadPurchaseResponse() { ns1__downloadPurchaseResponse::soap_default(NULL); }
	virtual ~ns1__downloadPurchaseResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__downloadPurchaseRequest
#define SOAP_TYPE_ns1__downloadPurchaseRequest (46)
/* ns1:downloadPurchaseRequest */
class SOAP_CMAC ns1__downloadPurchaseRequest
{
public:
	ns1__sessionRequest *session;	/* required element of type ns1:sessionRequest */
	int purchaseId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE_ns1__downloadPurchaseRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__downloadPurchaseRequest() { ns1__downloadPurchaseRequest::soap_default(NULL); }
	virtual ~ns1__downloadPurchaseRequest() { }
};
#endif

#ifndef SOAP_TYPE_ns1__qualifiedPurchase
#define SOAP_TYPE_ns1__qualifiedPurchase (14)
/* ns1:qualifiedPurchase */
class SOAP_CMAC ns1__qualifiedPurchase : public ns1__purchase
{
public:
	int purchaseId;	/* required element of type xsd:int */
	std::string agent;	/* required element of type xsd:string */
	bool wasDownloaded;	/* required element of type xsd:boolean */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_ns1__qualifiedPurchase */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__qualifiedPurchase() { ns1__qualifiedPurchase::soap_default(NULL); }
	virtual ~ns1__qualifiedPurchase() { }
};
#endif

#ifndef SOAP_TYPE_ns1__cursorRequest
#define SOAP_TYPE_ns1__cursorRequest (20)
/* ns1:cursorRequest */
class SOAP_CMAC ns1__cursorRequest : public ns1__sessionRequest
{
public:
	int size;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE_ns1__cursorRequest */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__cursorRequest() { ns1__cursorRequest::soap_default(NULL); }
	virtual ~ns1__cursorRequest() { }
};
#endif

#ifndef SOAP_TYPE___ns1__openMobileSession
#define SOAP_TYPE___ns1__openMobileSession (77)
/* Operation wrapper: */
struct __ns1__openMobileSession
{
public:
	ns1__openMobileSessionRequest *ns1__openMobileSessionRequest_;	/* optional element of type ns1:openMobileSessionRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__openOfficeSession
#define SOAP_TYPE___ns1__openOfficeSession (80)
/* Operation wrapper: */
struct __ns1__openOfficeSession
{
public:
	ns1__openOfficeSessionRequest *ns1__openOfficeSessionRequest_;	/* optional element of type ns1:openOfficeSessionRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__closeSession
#define SOAP_TYPE___ns1__closeSession (83)
/* Operation wrapper: */
struct __ns1__closeSession
{
public:
	ns1__sessionRequest *ns1__closeSessionRequest;	/* optional element of type ns1:sessionRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__openHentCursor
#define SOAP_TYPE___ns1__openHentCursor (86)
/* Operation wrapper: */
struct __ns1__openHentCursor
{
public:
	ns1__sessionRequest *ns1__openHentCursorRequest;	/* optional element of type ns1:sessionRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__fetchHents
#define SOAP_TYPE___ns1__fetchHents (90)
/* Operation wrapper: */
struct __ns1__fetchHents
{
public:
	ns1__cursorRequest *ns1__fetchHentsRequest;	/* optional element of type ns1:cursorRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__closeHentCursor
#define SOAP_TYPE___ns1__closeHentCursor (93)
/* Operation wrapper: */
struct __ns1__closeHentCursor
{
public:
	ns1__sessionRequest *ns1__closeHentCursorRequest;	/* optional element of type ns1:sessionRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__openSyncTransaction
#define SOAP_TYPE___ns1__openSyncTransaction (96)
/* Operation wrapper: */
struct __ns1__openSyncTransaction
{
public:
	ns1__sessionRequest *ns1__openSyncTransactionRequest;	/* optional element of type ns1:sessionRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__updateHent
#define SOAP_TYPE___ns1__updateHent (100)
/* Operation wrapper: */
struct __ns1__updateHent
{
public:
	ns1__updateHentRequest *ns1__updateHentRequest_;	/* optional element of type ns1:updateHentRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__updateStock
#define SOAP_TYPE___ns1__updateStock (104)
/* Operation wrapper: */
struct __ns1__updateStock
{
public:
	ns1__updateStockRequest *ns1__updateStockRequest_;	/* optional element of type ns1:updateStockRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__closeSyncTransaction
#define SOAP_TYPE___ns1__closeSyncTransaction (107)
/* Operation wrapper: */
struct __ns1__closeSyncTransaction
{
public:
	ns1__sessionRequest *ns1__closeSyncTransactionRequest_;	/* optional element of type ns1:sessionRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__commitSyncTransaction
#define SOAP_TYPE___ns1__commitSyncTransaction (110)
/* Operation wrapper: */
struct __ns1__commitSyncTransaction
{
public:
	ns1__sessionRequest *ns1__commitSyncTransactionRequest_;	/* optional element of type ns1:sessionRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__openStockCursor
#define SOAP_TYPE___ns1__openStockCursor (113)
/* Operation wrapper: */
struct __ns1__openStockCursor
{
public:
	ns1__sessionRequest *ns1__openStockCursorRequest;	/* optional element of type ns1:sessionRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__fetchStocks
#define SOAP_TYPE___ns1__fetchStocks (116)
/* Operation wrapper: */
struct __ns1__fetchStocks
{
public:
	ns1__cursorRequest *ns1__fetchStocksRequest;	/* optional element of type ns1:cursorRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__closeStockCursor
#define SOAP_TYPE___ns1__closeStockCursor (119)
/* Operation wrapper: */
struct __ns1__closeStockCursor
{
public:
	ns1__sessionRequest *ns1__closeStockCursorRequest;	/* optional element of type ns1:sessionRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__updateCompany
#define SOAP_TYPE___ns1__updateCompany (123)
/* Operation wrapper: */
struct __ns1__updateCompany
{
public:
	ns1__updateCompanyRequest *ns1__updateCompanyRequest_;	/* optional element of type ns1:updateCompanyRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__fetchCompany
#define SOAP_TYPE___ns1__fetchCompany (126)
/* Operation wrapper: */
struct __ns1__fetchCompany
{
public:
	ns1__sessionRequest *ns1__fetchCompanyRequest;	/* optional element of type ns1:sessionRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__uploadPurchase
#define SOAP_TYPE___ns1__uploadPurchase (130)
/* Operation wrapper: */
struct __ns1__uploadPurchase
{
public:
	ns1__uploadPurchaseRequest *ns1__uploadPurchaseRequest_;	/* optional element of type ns1:uploadPurchaseRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__openPurchaseCursor
#define SOAP_TYPE___ns1__openPurchaseCursor (133)
/* Operation wrapper: */
struct __ns1__openPurchaseCursor
{
public:
	ns1__sessionRequest *ns1__openPurchaseCursorRequest;	/* optional element of type ns1:sessionRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__closePurchaseCursor
#define SOAP_TYPE___ns1__closePurchaseCursor (136)
/* Operation wrapper: */
struct __ns1__closePurchaseCursor
{
public:
	ns1__sessionRequest *ns1__closePurchaseCursorRequest;	/* optional element of type ns1:sessionRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__fetchPurchases
#define SOAP_TYPE___ns1__fetchPurchases (139)
/* Operation wrapper: */
struct __ns1__fetchPurchases
{
public:
	ns1__cursorRequest *ns1__fetchPurchasesRequest;	/* optional element of type ns1:cursorRequest */
};
#endif

#ifndef SOAP_TYPE___ns1__downloadPurchase
#define SOAP_TYPE___ns1__downloadPurchase (143)
/* Operation wrapper: */
struct __ns1__downloadPurchase
{
public:
	ns1__downloadPurchaseRequest *ns1__downloadPurchaseRequest_;	/* optional element of type ns1:downloadPurchaseRequest */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (144)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (145)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (147)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (150)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (151)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Client-Side Call Stubs                                                     *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__openMobileSession(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__openMobileSessionRequest *ns1__openMobileSessionRequest_, ns1__openSessionResponse *ns1__openSessionResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__openOfficeSession(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__openOfficeSessionRequest *ns1__openOfficeSessionRequest_, ns1__openSessionResponse *ns1__openSessionResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__closeSession(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__sessionRequest *ns1__closeSessionRequest, ns1__closeSessionResponse *ns1__closeSessionResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__openHentCursor(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__sessionRequest *ns1__openHentCursorRequest, ns1__openHentCursorResponse *ns1__openHentCursorResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__fetchHents(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__cursorRequest *ns1__fetchHentsRequest, ns1__fetchHentsResponse *ns1__fetchHentsResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__closeHentCursor(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__sessionRequest *ns1__closeHentCursorRequest, ns1__closeHentCursorResponse *ns1__closeHentCursorResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__openSyncTransaction(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__sessionRequest *ns1__openSyncTransactionRequest, ns1__openSyncTransactionResponse *ns1__openSyncTransactionResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__updateHent(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__updateHentRequest *ns1__updateHentRequest_, ns1__updateHentResponse *ns1__updateHentResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__updateStock(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__updateStockRequest *ns1__updateStockRequest_, ns1__updateStockResponse *ns1__updateStockResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__closeSyncTransaction(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__sessionRequest *ns1__closeSyncTransactionRequest_, ns1__closeSyncTransactionResponse *ns1__closeSyncTransactionResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__commitSyncTransaction(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__sessionRequest *ns1__commitSyncTransactionRequest_, ns1__commitSyncTransactionResponse *ns1__commitSyncTransactionResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__openStockCursor(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__sessionRequest *ns1__openStockCursorRequest, ns1__openStockCursorResponse *ns1__openStockCursorResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__fetchStocks(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__cursorRequest *ns1__fetchStocksRequest, ns1__fetchStocksResponse *ns1__fetchStocksResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__closeStockCursor(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__sessionRequest *ns1__closeStockCursorRequest, ns1__closeStockCursorResponse *ns1__closeStockCursorResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__updateCompany(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__updateCompanyRequest *ns1__updateCompanyRequest_, ns1__updateCompanyResponse *ns1__updateCompanyResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__fetchCompany(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__sessionRequest *ns1__fetchCompanyRequest, ns1__fetchCompanyResponse *ns1__fetchCompanyResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__uploadPurchase(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__uploadPurchaseRequest *ns1__uploadPurchaseRequest_, ns1__uploadPurchaseResponse *ns1__uploadPurchaseResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__openPurchaseCursor(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__sessionRequest *ns1__openPurchaseCursorRequest, ns1__openPurchaseCursorResponse *ns1__openPurchaseCursorResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__closePurchaseCursor(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__sessionRequest *ns1__closePurchaseCursorRequest, ns1__closePurchaseCursorResponse *ns1__closePurchaseCursorResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__fetchPurchases(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__cursorRequest *ns1__fetchPurchasesRequest, ns1__fetchPurchasesResponse *ns1__fetchPurchasesResponse_);

SOAP_FMAC5 int SOAP_FMAC6 soap_call___ns1__downloadPurchase(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__downloadPurchaseRequest *ns1__downloadPurchaseRequest_, ns1__downloadPurchaseResponse *ns1__downloadPurchaseResponse_);

#endif

/* End of BKRepoServiceStub.h */
