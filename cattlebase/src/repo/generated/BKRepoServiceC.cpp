/* BKRepoServiceC.cpp
   Generated by gSOAP 2.8.6 from BKRepoService.h

Copyright(C) 2000-2011, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
1) GPL or 2) Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "BKRepoServiceH.h"

SOAP_SOURCE_STAMP("@(#) BKRepoServiceC.cpp ver 2.8.6 2012-11-26 17:19:48 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	if ((soap->header = soap_new_SOAP_ENV__Header(soap, -1)))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		if (!soap->fault)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_check_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if (soap->error || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_double:
		return soap_in_double(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_time:
		return soap_in_time(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_in_bool(soap, NULL, NULL, "xsd:boolean");
	case SOAP_TYPE_ns1__status:
		return soap_in_ns1__status(soap, NULL, NULL, "ns1:status");
	case SOAP_TYPE_ns1__invoiceType:
		return soap_in_ns1__invoiceType(soap, NULL, NULL, "ns1:invoiceType");
	case SOAP_TYPE_ns1__payWay:
		return soap_in_ns1__payWay(soap, NULL, NULL, "ns1:payWay");
	case SOAP_TYPE_ns1__hentType:
		return soap_in_ns1__hentType(soap, NULL, NULL, "ns1:hentType");
	case SOAP_TYPE_ns1__cowSex:
		return soap_in_ns1__cowSex(soap, NULL, NULL, "ns1:cowSex");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_ns1__downloadPurchaseRequest:
		return soap_in_ns1__downloadPurchaseRequest(soap, NULL, NULL, "ns1:downloadPurchaseRequest");
	case SOAP_TYPE_ns1__downloadPurchaseResponse:
		return soap_in_ns1__downloadPurchaseResponse(soap, NULL, NULL, "ns1:downloadPurchaseResponse");
	case SOAP_TYPE_ns1__fetchPurchasesResponse:
		return soap_in_ns1__fetchPurchasesResponse(soap, NULL, NULL, "ns1:fetchPurchasesResponse");
	case SOAP_TYPE_ns1__closePurchaseCursorResponse:
		return soap_in_ns1__closePurchaseCursorResponse(soap, NULL, NULL, "ns1:closePurchaseCursorResponse");
	case SOAP_TYPE_ns1__openPurchaseCursorResponse:
		return soap_in_ns1__openPurchaseCursorResponse(soap, NULL, NULL, "ns1:openPurchaseCursorResponse");
	case SOAP_TYPE_ns1__uploadPurchaseResponse:
		return soap_in_ns1__uploadPurchaseResponse(soap, NULL, NULL, "ns1:uploadPurchaseResponse");
	case SOAP_TYPE_ns1__uploadPurchaseRequest:
		return soap_in_ns1__uploadPurchaseRequest(soap, NULL, NULL, "ns1:uploadPurchaseRequest");
	case SOAP_TYPE_ns1__fetchCompanyResponse:
		return soap_in_ns1__fetchCompanyResponse(soap, NULL, NULL, "ns1:fetchCompanyResponse");
	case SOAP_TYPE_ns1__updateCompanyRequest:
		return soap_in_ns1__updateCompanyRequest(soap, NULL, NULL, "ns1:updateCompanyRequest");
	case SOAP_TYPE_ns1__updateCompanyResponse:
		return soap_in_ns1__updateCompanyResponse(soap, NULL, NULL, "ns1:updateCompanyResponse");
	case SOAP_TYPE_ns1__fetchStocksResponse:
		return soap_in_ns1__fetchStocksResponse(soap, NULL, NULL, "ns1:fetchStocksResponse");
	case SOAP_TYPE_ns1__closeStockCursorResponse:
		return soap_in_ns1__closeStockCursorResponse(soap, NULL, NULL, "ns1:closeStockCursorResponse");
	case SOAP_TYPE_ns1__openStockCursorResponse:
		return soap_in_ns1__openStockCursorResponse(soap, NULL, NULL, "ns1:openStockCursorResponse");
	case SOAP_TYPE_ns1__openHentCursorResponse:
		return soap_in_ns1__openHentCursorResponse(soap, NULL, NULL, "ns1:openHentCursorResponse");
	case SOAP_TYPE_ns1__closeHentCursorResponse:
		return soap_in_ns1__closeHentCursorResponse(soap, NULL, NULL, "ns1:closeHentCursorResponse");
	case SOAP_TYPE_ns1__openSyncTransactionResponse:
		return soap_in_ns1__openSyncTransactionResponse(soap, NULL, NULL, "ns1:openSyncTransactionResponse");
	case SOAP_TYPE_ns1__closeSessionResponse:
		return soap_in_ns1__closeSessionResponse(soap, NULL, NULL, "ns1:closeSessionResponse");
	case SOAP_TYPE_ns1__fetchHentsResponse:
		return soap_in_ns1__fetchHentsResponse(soap, NULL, NULL, "ns1:fetchHentsResponse");
	case SOAP_TYPE_ns1__updateStockResponse:
		return soap_in_ns1__updateStockResponse(soap, NULL, NULL, "ns1:updateStockResponse");
	case SOAP_TYPE_ns1__updateStockRequest:
		return soap_in_ns1__updateStockRequest(soap, NULL, NULL, "ns1:updateStockRequest");
	case SOAP_TYPE_ns1__updateHentResponse:
		return soap_in_ns1__updateHentResponse(soap, NULL, NULL, "ns1:updateHentResponse");
	case SOAP_TYPE_ns1__updateHentRequest:
		return soap_in_ns1__updateHentRequest(soap, NULL, NULL, "ns1:updateHentRequest");
	case SOAP_TYPE_ns1__commitSyncTransactionResponse:
		return soap_in_ns1__commitSyncTransactionResponse(soap, NULL, NULL, "ns1:commitSyncTransactionResponse");
	case SOAP_TYPE_ns1__commitSyncTransactionRequest:
		return soap_in_ns1__commitSyncTransactionRequest(soap, NULL, NULL, "ns1:commitSyncTransactionRequest");
	case SOAP_TYPE_ns1__closeSyncTransactionResponse:
		return soap_in_ns1__closeSyncTransactionResponse(soap, NULL, NULL, "ns1:closeSyncTransactionResponse");
	case SOAP_TYPE_ns1__closeSyncTransactionRequest:
		return soap_in_ns1__closeSyncTransactionRequest(soap, NULL, NULL, "ns1:closeSyncTransactionRequest");
	case SOAP_TYPE_ns1__cursorRequest:
		return soap_in_ns1__cursorRequest(soap, NULL, NULL, "ns1:cursorRequest");
	case SOAP_TYPE_ns1__sessionRequest:
		return soap_in_ns1__sessionRequest(soap, NULL, NULL, "ns1:sessionRequest");
	case SOAP_TYPE_ns1__openSessionResponse:
		return soap_in_ns1__openSessionResponse(soap, NULL, NULL, "ns1:openSessionResponse");
	case SOAP_TYPE_ns1__openOfficeSessionRequest:
		return soap_in_ns1__openOfficeSessionRequest(soap, NULL, NULL, "ns1:openOfficeSessionRequest");
	case SOAP_TYPE_ns1__openMobileSessionRequest:
		return soap_in_ns1__openMobileSessionRequest(soap, NULL, NULL, "ns1:openMobileSessionRequest");
	case SOAP_TYPE_ns1__result:
		return soap_in_ns1__result(soap, NULL, NULL, "ns1:result");
	case SOAP_TYPE_ns1__qualifiedPurchase:
		return soap_in_ns1__qualifiedPurchase(soap, NULL, NULL, "ns1:qualifiedPurchase");
	case SOAP_TYPE_ns1__purchase:
		return soap_in_ns1__purchase(soap, NULL, NULL, "ns1:purchase");
	case SOAP_TYPE_ns1__invoice:
		return soap_in_ns1__invoice(soap, NULL, NULL, "ns1:invoice");
	case SOAP_TYPE_ns1__cow:
		return soap_in_ns1__cow(soap, NULL, NULL, "ns1:cow");
	case SOAP_TYPE_ns1__company:
		return soap_in_ns1__company(soap, NULL, NULL, "ns1:company");
	case SOAP_TYPE_ns1__stock:
		return soap_in_ns1__stock(soap, NULL, NULL, "ns1:stock");
	case SOAP_TYPE_ns1__hent:
		return soap_in_ns1__hent(soap, NULL, NULL, "ns1:hent");
	case SOAP_TYPE_PointerTons1__downloadPurchaseResponse:
		return soap_in_PointerTons1__downloadPurchaseResponse(soap, NULL, NULL, "ns1:downloadPurchaseResponse");
	case SOAP_TYPE_PointerTons1__downloadPurchaseRequest:
		return soap_in_PointerTons1__downloadPurchaseRequest(soap, NULL, NULL, "ns1:downloadPurchaseRequest");
	case SOAP_TYPE_PointerTons1__fetchPurchasesResponse:
		return soap_in_PointerTons1__fetchPurchasesResponse(soap, NULL, NULL, "ns1:fetchPurchasesResponse");
	case SOAP_TYPE_PointerTons1__closePurchaseCursorResponse:
		return soap_in_PointerTons1__closePurchaseCursorResponse(soap, NULL, NULL, "ns1:closePurchaseCursorResponse");
	case SOAP_TYPE_PointerTons1__openPurchaseCursorResponse:
		return soap_in_PointerTons1__openPurchaseCursorResponse(soap, NULL, NULL, "ns1:openPurchaseCursorResponse");
	case SOAP_TYPE_PointerTons1__uploadPurchaseResponse:
		return soap_in_PointerTons1__uploadPurchaseResponse(soap, NULL, NULL, "ns1:uploadPurchaseResponse");
	case SOAP_TYPE_PointerTons1__uploadPurchaseRequest:
		return soap_in_PointerTons1__uploadPurchaseRequest(soap, NULL, NULL, "ns1:uploadPurchaseRequest");
	case SOAP_TYPE_PointerTons1__fetchCompanyResponse:
		return soap_in_PointerTons1__fetchCompanyResponse(soap, NULL, NULL, "ns1:fetchCompanyResponse");
	case SOAP_TYPE_PointerTons1__updateCompanyResponse:
		return soap_in_PointerTons1__updateCompanyResponse(soap, NULL, NULL, "ns1:updateCompanyResponse");
	case SOAP_TYPE_PointerTons1__updateCompanyRequest:
		return soap_in_PointerTons1__updateCompanyRequest(soap, NULL, NULL, "ns1:updateCompanyRequest");
	case SOAP_TYPE_PointerTons1__closeStockCursorResponse:
		return soap_in_PointerTons1__closeStockCursorResponse(soap, NULL, NULL, "ns1:closeStockCursorResponse");
	case SOAP_TYPE_PointerTons1__fetchStocksResponse:
		return soap_in_PointerTons1__fetchStocksResponse(soap, NULL, NULL, "ns1:fetchStocksResponse");
	case SOAP_TYPE_PointerTons1__openStockCursorResponse:
		return soap_in_PointerTons1__openStockCursorResponse(soap, NULL, NULL, "ns1:openStockCursorResponse");
	case SOAP_TYPE_PointerTons1__commitSyncTransactionResponse:
		return soap_in_PointerTons1__commitSyncTransactionResponse(soap, NULL, NULL, "ns1:commitSyncTransactionResponse");
	case SOAP_TYPE_PointerTons1__closeSyncTransactionResponse:
		return soap_in_PointerTons1__closeSyncTransactionResponse(soap, NULL, NULL, "ns1:closeSyncTransactionResponse");
	case SOAP_TYPE_PointerTons1__updateStockResponse:
		return soap_in_PointerTons1__updateStockResponse(soap, NULL, NULL, "ns1:updateStockResponse");
	case SOAP_TYPE_PointerTons1__updateStockRequest:
		return soap_in_PointerTons1__updateStockRequest(soap, NULL, NULL, "ns1:updateStockRequest");
	case SOAP_TYPE_PointerTons1__updateHentResponse:
		return soap_in_PointerTons1__updateHentResponse(soap, NULL, NULL, "ns1:updateHentResponse");
	case SOAP_TYPE_PointerTons1__updateHentRequest:
		return soap_in_PointerTons1__updateHentRequest(soap, NULL, NULL, "ns1:updateHentRequest");
	case SOAP_TYPE_PointerTons1__openSyncTransactionResponse:
		return soap_in_PointerTons1__openSyncTransactionResponse(soap, NULL, NULL, "ns1:openSyncTransactionResponse");
	case SOAP_TYPE_PointerTons1__closeHentCursorResponse:
		return soap_in_PointerTons1__closeHentCursorResponse(soap, NULL, NULL, "ns1:closeHentCursorResponse");
	case SOAP_TYPE_PointerTons1__fetchHentsResponse:
		return soap_in_PointerTons1__fetchHentsResponse(soap, NULL, NULL, "ns1:fetchHentsResponse");
	case SOAP_TYPE_PointerTons1__cursorRequest:
		return soap_in_PointerTons1__cursorRequest(soap, NULL, NULL, "ns1:cursorRequest");
	case SOAP_TYPE_PointerTons1__openHentCursorResponse:
		return soap_in_PointerTons1__openHentCursorResponse(soap, NULL, NULL, "ns1:openHentCursorResponse");
	case SOAP_TYPE_PointerTons1__closeSessionResponse:
		return soap_in_PointerTons1__closeSessionResponse(soap, NULL, NULL, "ns1:closeSessionResponse");
	case SOAP_TYPE_PointerTons1__openOfficeSessionRequest:
		return soap_in_PointerTons1__openOfficeSessionRequest(soap, NULL, NULL, "ns1:openOfficeSessionRequest");
	case SOAP_TYPE_PointerTons1__openSessionResponse:
		return soap_in_PointerTons1__openSessionResponse(soap, NULL, NULL, "ns1:openSessionResponse");
	case SOAP_TYPE_PointerTons1__openMobileSessionRequest:
		return soap_in_PointerTons1__openMobileSessionRequest(soap, NULL, NULL, "ns1:openMobileSessionRequest");
	case SOAP_TYPE_PointerTons1__qualifiedPurchase:
		return soap_in_PointerTons1__qualifiedPurchase(soap, NULL, NULL, "ns1:qualifiedPurchase");
	case SOAP_TYPE_PointerTons1__purchase:
		return soap_in_PointerTons1__purchase(soap, NULL, NULL, "ns1:purchase");
	case SOAP_TYPE_PointerTons1__company:
		return soap_in_PointerTons1__company(soap, NULL, NULL, "ns1:company");
	case SOAP_TYPE_PointerTons1__stock:
		return soap_in_PointerTons1__stock(soap, NULL, NULL, "ns1:stock");
	case SOAP_TYPE_PointerTons1__sessionRequest:
		return soap_in_PointerTons1__sessionRequest(soap, NULL, NULL, "ns1:sessionRequest");
	case SOAP_TYPE_PointerTons1__result:
		return soap_in_PointerTons1__result(soap, NULL, NULL, "ns1:result");
	case SOAP_TYPE_PointerTons1__hent:
		return soap_in_PointerTons1__hent(soap, NULL, NULL, "ns1:hent");
	case SOAP_TYPE_PointerTons1__invoice:
		return soap_in_PointerTons1__invoice(soap, NULL, NULL, "ns1:invoice");
	case SOAP_TYPE_PointerTons1__cow:
		return soap_in_PointerTons1__cow(soap, NULL, NULL, "ns1:cow");
	case SOAP_TYPE_PointerTodouble:
		return soap_in_PointerTodouble(soap, NULL, NULL, "xsd:double");
	case SOAP_TYPE_PointerTotime:
		return soap_in_PointerTotime(soap, NULL, NULL, "xsd:dateTime");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:downloadPurchaseRequest"))
		{	*type = SOAP_TYPE_ns1__downloadPurchaseRequest;
			return soap_in_ns1__downloadPurchaseRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:downloadPurchaseResponse"))
		{	*type = SOAP_TYPE_ns1__downloadPurchaseResponse;
			return soap_in_ns1__downloadPurchaseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:fetchPurchasesResponse"))
		{	*type = SOAP_TYPE_ns1__fetchPurchasesResponse;
			return soap_in_ns1__fetchPurchasesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:closePurchaseCursorResponse"))
		{	*type = SOAP_TYPE_ns1__closePurchaseCursorResponse;
			return soap_in_ns1__closePurchaseCursorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:openPurchaseCursorResponse"))
		{	*type = SOAP_TYPE_ns1__openPurchaseCursorResponse;
			return soap_in_ns1__openPurchaseCursorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:uploadPurchaseResponse"))
		{	*type = SOAP_TYPE_ns1__uploadPurchaseResponse;
			return soap_in_ns1__uploadPurchaseResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:uploadPurchaseRequest"))
		{	*type = SOAP_TYPE_ns1__uploadPurchaseRequest;
			return soap_in_ns1__uploadPurchaseRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:fetchCompanyResponse"))
		{	*type = SOAP_TYPE_ns1__fetchCompanyResponse;
			return soap_in_ns1__fetchCompanyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateCompanyRequest"))
		{	*type = SOAP_TYPE_ns1__updateCompanyRequest;
			return soap_in_ns1__updateCompanyRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateCompanyResponse"))
		{	*type = SOAP_TYPE_ns1__updateCompanyResponse;
			return soap_in_ns1__updateCompanyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:fetchStocksResponse"))
		{	*type = SOAP_TYPE_ns1__fetchStocksResponse;
			return soap_in_ns1__fetchStocksResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:closeStockCursorResponse"))
		{	*type = SOAP_TYPE_ns1__closeStockCursorResponse;
			return soap_in_ns1__closeStockCursorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:openStockCursorResponse"))
		{	*type = SOAP_TYPE_ns1__openStockCursorResponse;
			return soap_in_ns1__openStockCursorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:openHentCursorResponse"))
		{	*type = SOAP_TYPE_ns1__openHentCursorResponse;
			return soap_in_ns1__openHentCursorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:closeHentCursorResponse"))
		{	*type = SOAP_TYPE_ns1__closeHentCursorResponse;
			return soap_in_ns1__closeHentCursorResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:openSyncTransactionResponse"))
		{	*type = SOAP_TYPE_ns1__openSyncTransactionResponse;
			return soap_in_ns1__openSyncTransactionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:closeSessionResponse"))
		{	*type = SOAP_TYPE_ns1__closeSessionResponse;
			return soap_in_ns1__closeSessionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:fetchHentsResponse"))
		{	*type = SOAP_TYPE_ns1__fetchHentsResponse;
			return soap_in_ns1__fetchHentsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateStockResponse"))
		{	*type = SOAP_TYPE_ns1__updateStockResponse;
			return soap_in_ns1__updateStockResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateStockRequest"))
		{	*type = SOAP_TYPE_ns1__updateStockRequest;
			return soap_in_ns1__updateStockRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateHentResponse"))
		{	*type = SOAP_TYPE_ns1__updateHentResponse;
			return soap_in_ns1__updateHentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:updateHentRequest"))
		{	*type = SOAP_TYPE_ns1__updateHentRequest;
			return soap_in_ns1__updateHentRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:commitSyncTransactionResponse"))
		{	*type = SOAP_TYPE_ns1__commitSyncTransactionResponse;
			return soap_in_ns1__commitSyncTransactionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:commitSyncTransactionRequest"))
		{	*type = SOAP_TYPE_ns1__commitSyncTransactionRequest;
			return soap_in_ns1__commitSyncTransactionRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:closeSyncTransactionResponse"))
		{	*type = SOAP_TYPE_ns1__closeSyncTransactionResponse;
			return soap_in_ns1__closeSyncTransactionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:closeSyncTransactionRequest"))
		{	*type = SOAP_TYPE_ns1__closeSyncTransactionRequest;
			return soap_in_ns1__closeSyncTransactionRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cursorRequest"))
		{	*type = SOAP_TYPE_ns1__cursorRequest;
			return soap_in_ns1__cursorRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:sessionRequest"))
		{	*type = SOAP_TYPE_ns1__sessionRequest;
			return soap_in_ns1__sessionRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:openSessionResponse"))
		{	*type = SOAP_TYPE_ns1__openSessionResponse;
			return soap_in_ns1__openSessionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:openOfficeSessionRequest"))
		{	*type = SOAP_TYPE_ns1__openOfficeSessionRequest;
			return soap_in_ns1__openOfficeSessionRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:openMobileSessionRequest"))
		{	*type = SOAP_TYPE_ns1__openMobileSessionRequest;
			return soap_in_ns1__openMobileSessionRequest(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:result"))
		{	*type = SOAP_TYPE_ns1__result;
			return soap_in_ns1__result(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:qualifiedPurchase"))
		{	*type = SOAP_TYPE_ns1__qualifiedPurchase;
			return soap_in_ns1__qualifiedPurchase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:purchase"))
		{	*type = SOAP_TYPE_ns1__purchase;
			return soap_in_ns1__purchase(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:invoice"))
		{	*type = SOAP_TYPE_ns1__invoice;
			return soap_in_ns1__invoice(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cow"))
		{	*type = SOAP_TYPE_ns1__cow;
			return soap_in_ns1__cow(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:company"))
		{	*type = SOAP_TYPE_ns1__company;
			return soap_in_ns1__company(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:stock"))
		{	*type = SOAP_TYPE_ns1__stock;
			return soap_in_ns1__stock(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hent"))
		{	*type = SOAP_TYPE_ns1__hent;
			return soap_in_ns1__hent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:double"))
		{	*type = SOAP_TYPE_double;
			return soap_in_double(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:dateTime"))
		{	*type = SOAP_TYPE_time;
			return soap_in_time(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:boolean"))
		{	*type = SOAP_TYPE_bool;
			return soap_in_bool(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:status"))
		{	*type = SOAP_TYPE_ns1__status;
			return soap_in_ns1__status(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:invoiceType"))
		{	*type = SOAP_TYPE_ns1__invoiceType;
			return soap_in_ns1__invoiceType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:payWay"))
		{	*type = SOAP_TYPE_ns1__payWay;
			return soap_in_ns1__payWay(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:hentType"))
		{	*type = SOAP_TYPE_ns1__hentType;
			return soap_in_ns1__hentType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:cowSex"))
		{	*type = SOAP_TYPE_ns1__cowSex;
			return soap_in_ns1__cowSex(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level=%u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_double:
		return soap_out_double(soap, tag, id, (const double *)ptr, "xsd:double");
	case SOAP_TYPE_time:
		return soap_out_time(soap, tag, id, (const time_t *)ptr, "xsd:dateTime");
	case SOAP_TYPE_bool:
		return soap_out_bool(soap, tag, id, (const bool *)ptr, "xsd:boolean");
	case SOAP_TYPE_ns1__status:
		return soap_out_ns1__status(soap, tag, id, (const enum ns1__status *)ptr, "ns1:status");
	case SOAP_TYPE_ns1__invoiceType:
		return soap_out_ns1__invoiceType(soap, tag, id, (const enum ns1__invoiceType *)ptr, "ns1:invoiceType");
	case SOAP_TYPE_ns1__payWay:
		return soap_out_ns1__payWay(soap, tag, id, (const enum ns1__payWay *)ptr, "ns1:payWay");
	case SOAP_TYPE_ns1__hentType:
		return soap_out_ns1__hentType(soap, tag, id, (const enum ns1__hentType *)ptr, "ns1:hentType");
	case SOAP_TYPE_ns1__cowSex:
		return soap_out_ns1__cowSex(soap, tag, id, (const enum ns1__cowSex *)ptr, "ns1:cowSex");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_ns1__downloadPurchaseRequest:
		return ((ns1__downloadPurchaseRequest *)ptr)->soap_out(soap, tag, id, "ns1:downloadPurchaseRequest");
	case SOAP_TYPE_ns1__downloadPurchaseResponse:
		return ((ns1__downloadPurchaseResponse *)ptr)->soap_out(soap, tag, id, "ns1:downloadPurchaseResponse");
	case SOAP_TYPE_ns1__fetchPurchasesResponse:
		return ((ns1__fetchPurchasesResponse *)ptr)->soap_out(soap, tag, id, "ns1:fetchPurchasesResponse");
	case SOAP_TYPE_ns1__closePurchaseCursorResponse:
		return ((ns1__closePurchaseCursorResponse *)ptr)->soap_out(soap, tag, id, "ns1:closePurchaseCursorResponse");
	case SOAP_TYPE_ns1__openPurchaseCursorResponse:
		return ((ns1__openPurchaseCursorResponse *)ptr)->soap_out(soap, tag, id, "ns1:openPurchaseCursorResponse");
	case SOAP_TYPE_ns1__uploadPurchaseResponse:
		return ((ns1__uploadPurchaseResponse *)ptr)->soap_out(soap, tag, id, "ns1:uploadPurchaseResponse");
	case SOAP_TYPE_ns1__uploadPurchaseRequest:
		return ((ns1__uploadPurchaseRequest *)ptr)->soap_out(soap, tag, id, "ns1:uploadPurchaseRequest");
	case SOAP_TYPE_ns1__fetchCompanyResponse:
		return ((ns1__fetchCompanyResponse *)ptr)->soap_out(soap, tag, id, "ns1:fetchCompanyResponse");
	case SOAP_TYPE_ns1__updateCompanyRequest:
		return ((ns1__updateCompanyRequest *)ptr)->soap_out(soap, tag, id, "ns1:updateCompanyRequest");
	case SOAP_TYPE_ns1__updateCompanyResponse:
		return ((ns1__updateCompanyResponse *)ptr)->soap_out(soap, tag, id, "ns1:updateCompanyResponse");
	case SOAP_TYPE_ns1__fetchStocksResponse:
		return ((ns1__fetchStocksResponse *)ptr)->soap_out(soap, tag, id, "ns1:fetchStocksResponse");
	case SOAP_TYPE_ns1__closeStockCursorResponse:
		return ((ns1__closeStockCursorResponse *)ptr)->soap_out(soap, tag, id, "ns1:closeStockCursorResponse");
	case SOAP_TYPE_ns1__openStockCursorResponse:
		return ((ns1__openStockCursorResponse *)ptr)->soap_out(soap, tag, id, "ns1:openStockCursorResponse");
	case SOAP_TYPE_ns1__openHentCursorResponse:
		return ((ns1__openHentCursorResponse *)ptr)->soap_out(soap, tag, id, "ns1:openHentCursorResponse");
	case SOAP_TYPE_ns1__closeHentCursorResponse:
		return ((ns1__closeHentCursorResponse *)ptr)->soap_out(soap, tag, id, "ns1:closeHentCursorResponse");
	case SOAP_TYPE_ns1__openSyncTransactionResponse:
		return ((ns1__openSyncTransactionResponse *)ptr)->soap_out(soap, tag, id, "ns1:openSyncTransactionResponse");
	case SOAP_TYPE_ns1__closeSessionResponse:
		return ((ns1__closeSessionResponse *)ptr)->soap_out(soap, tag, id, "ns1:closeSessionResponse");
	case SOAP_TYPE_ns1__fetchHentsResponse:
		return ((ns1__fetchHentsResponse *)ptr)->soap_out(soap, tag, id, "ns1:fetchHentsResponse");
	case SOAP_TYPE_ns1__updateStockResponse:
		return ((ns1__updateStockResponse *)ptr)->soap_out(soap, tag, id, "ns1:updateStockResponse");
	case SOAP_TYPE_ns1__updateStockRequest:
		return ((ns1__updateStockRequest *)ptr)->soap_out(soap, tag, id, "ns1:updateStockRequest");
	case SOAP_TYPE_ns1__updateHentResponse:
		return ((ns1__updateHentResponse *)ptr)->soap_out(soap, tag, id, "ns1:updateHentResponse");
	case SOAP_TYPE_ns1__updateHentRequest:
		return ((ns1__updateHentRequest *)ptr)->soap_out(soap, tag, id, "ns1:updateHentRequest");
	case SOAP_TYPE_ns1__commitSyncTransactionResponse:
		return ((ns1__commitSyncTransactionResponse *)ptr)->soap_out(soap, tag, id, "ns1:commitSyncTransactionResponse");
	case SOAP_TYPE_ns1__commitSyncTransactionRequest:
		return ((ns1__commitSyncTransactionRequest *)ptr)->soap_out(soap, tag, id, "ns1:commitSyncTransactionRequest");
	case SOAP_TYPE_ns1__closeSyncTransactionResponse:
		return ((ns1__closeSyncTransactionResponse *)ptr)->soap_out(soap, tag, id, "ns1:closeSyncTransactionResponse");
	case SOAP_TYPE_ns1__closeSyncTransactionRequest:
		return ((ns1__closeSyncTransactionRequest *)ptr)->soap_out(soap, tag, id, "ns1:closeSyncTransactionRequest");
	case SOAP_TYPE_ns1__cursorRequest:
		return ((ns1__cursorRequest *)ptr)->soap_out(soap, tag, id, "ns1:cursorRequest");
	case SOAP_TYPE_ns1__sessionRequest:
		return ((ns1__sessionRequest *)ptr)->soap_out(soap, tag, id, "ns1:sessionRequest");
	case SOAP_TYPE_ns1__openSessionResponse:
		return ((ns1__openSessionResponse *)ptr)->soap_out(soap, tag, id, "ns1:openSessionResponse");
	case SOAP_TYPE_ns1__openOfficeSessionRequest:
		return ((ns1__openOfficeSessionRequest *)ptr)->soap_out(soap, tag, id, "ns1:openOfficeSessionRequest");
	case SOAP_TYPE_ns1__openMobileSessionRequest:
		return ((ns1__openMobileSessionRequest *)ptr)->soap_out(soap, tag, id, "ns1:openMobileSessionRequest");
	case SOAP_TYPE_ns1__result:
		return ((ns1__result *)ptr)->soap_out(soap, tag, id, "ns1:result");
	case SOAP_TYPE_ns1__qualifiedPurchase:
		return ((ns1__qualifiedPurchase *)ptr)->soap_out(soap, tag, id, "ns1:qualifiedPurchase");
	case SOAP_TYPE_ns1__purchase:
		return ((ns1__purchase *)ptr)->soap_out(soap, tag, id, "ns1:purchase");
	case SOAP_TYPE_ns1__invoice:
		return ((ns1__invoice *)ptr)->soap_out(soap, tag, id, "ns1:invoice");
	case SOAP_TYPE_ns1__cow:
		return ((ns1__cow *)ptr)->soap_out(soap, tag, id, "ns1:cow");
	case SOAP_TYPE_ns1__company:
		return ((ns1__company *)ptr)->soap_out(soap, tag, id, "ns1:company");
	case SOAP_TYPE_ns1__stock:
		return ((ns1__stock *)ptr)->soap_out(soap, tag, id, "ns1:stock");
	case SOAP_TYPE_ns1__hent:
		return ((ns1__hent *)ptr)->soap_out(soap, tag, id, "ns1:hent");
	case SOAP_TYPE_PointerTons1__downloadPurchaseResponse:
		return soap_out_PointerTons1__downloadPurchaseResponse(soap, tag, id, (ns1__downloadPurchaseResponse *const*)ptr, "ns1:downloadPurchaseResponse");
	case SOAP_TYPE_PointerTons1__downloadPurchaseRequest:
		return soap_out_PointerTons1__downloadPurchaseRequest(soap, tag, id, (ns1__downloadPurchaseRequest *const*)ptr, "ns1:downloadPurchaseRequest");
	case SOAP_TYPE_PointerTons1__fetchPurchasesResponse:
		return soap_out_PointerTons1__fetchPurchasesResponse(soap, tag, id, (ns1__fetchPurchasesResponse *const*)ptr, "ns1:fetchPurchasesResponse");
	case SOAP_TYPE_PointerTons1__closePurchaseCursorResponse:
		return soap_out_PointerTons1__closePurchaseCursorResponse(soap, tag, id, (ns1__closePurchaseCursorResponse *const*)ptr, "ns1:closePurchaseCursorResponse");
	case SOAP_TYPE_PointerTons1__openPurchaseCursorResponse:
		return soap_out_PointerTons1__openPurchaseCursorResponse(soap, tag, id, (ns1__openPurchaseCursorResponse *const*)ptr, "ns1:openPurchaseCursorResponse");
	case SOAP_TYPE_PointerTons1__uploadPurchaseResponse:
		return soap_out_PointerTons1__uploadPurchaseResponse(soap, tag, id, (ns1__uploadPurchaseResponse *const*)ptr, "ns1:uploadPurchaseResponse");
	case SOAP_TYPE_PointerTons1__uploadPurchaseRequest:
		return soap_out_PointerTons1__uploadPurchaseRequest(soap, tag, id, (ns1__uploadPurchaseRequest *const*)ptr, "ns1:uploadPurchaseRequest");
	case SOAP_TYPE_PointerTons1__fetchCompanyResponse:
		return soap_out_PointerTons1__fetchCompanyResponse(soap, tag, id, (ns1__fetchCompanyResponse *const*)ptr, "ns1:fetchCompanyResponse");
	case SOAP_TYPE_PointerTons1__updateCompanyResponse:
		return soap_out_PointerTons1__updateCompanyResponse(soap, tag, id, (ns1__updateCompanyResponse *const*)ptr, "ns1:updateCompanyResponse");
	case SOAP_TYPE_PointerTons1__updateCompanyRequest:
		return soap_out_PointerTons1__updateCompanyRequest(soap, tag, id, (ns1__updateCompanyRequest *const*)ptr, "ns1:updateCompanyRequest");
	case SOAP_TYPE_PointerTons1__closeStockCursorResponse:
		return soap_out_PointerTons1__closeStockCursorResponse(soap, tag, id, (ns1__closeStockCursorResponse *const*)ptr, "ns1:closeStockCursorResponse");
	case SOAP_TYPE_PointerTons1__fetchStocksResponse:
		return soap_out_PointerTons1__fetchStocksResponse(soap, tag, id, (ns1__fetchStocksResponse *const*)ptr, "ns1:fetchStocksResponse");
	case SOAP_TYPE_PointerTons1__openStockCursorResponse:
		return soap_out_PointerTons1__openStockCursorResponse(soap, tag, id, (ns1__openStockCursorResponse *const*)ptr, "ns1:openStockCursorResponse");
	case SOAP_TYPE_PointerTons1__commitSyncTransactionResponse:
		return soap_out_PointerTons1__commitSyncTransactionResponse(soap, tag, id, (ns1__commitSyncTransactionResponse *const*)ptr, "ns1:commitSyncTransactionResponse");
	case SOAP_TYPE_PointerTons1__closeSyncTransactionResponse:
		return soap_out_PointerTons1__closeSyncTransactionResponse(soap, tag, id, (ns1__closeSyncTransactionResponse *const*)ptr, "ns1:closeSyncTransactionResponse");
	case SOAP_TYPE_PointerTons1__updateStockResponse:
		return soap_out_PointerTons1__updateStockResponse(soap, tag, id, (ns1__updateStockResponse *const*)ptr, "ns1:updateStockResponse");
	case SOAP_TYPE_PointerTons1__updateStockRequest:
		return soap_out_PointerTons1__updateStockRequest(soap, tag, id, (ns1__updateStockRequest *const*)ptr, "ns1:updateStockRequest");
	case SOAP_TYPE_PointerTons1__updateHentResponse:
		return soap_out_PointerTons1__updateHentResponse(soap, tag, id, (ns1__updateHentResponse *const*)ptr, "ns1:updateHentResponse");
	case SOAP_TYPE_PointerTons1__updateHentRequest:
		return soap_out_PointerTons1__updateHentRequest(soap, tag, id, (ns1__updateHentRequest *const*)ptr, "ns1:updateHentRequest");
	case SOAP_TYPE_PointerTons1__openSyncTransactionResponse:
		return soap_out_PointerTons1__openSyncTransactionResponse(soap, tag, id, (ns1__openSyncTransactionResponse *const*)ptr, "ns1:openSyncTransactionResponse");
	case SOAP_TYPE_PointerTons1__closeHentCursorResponse:
		return soap_out_PointerTons1__closeHentCursorResponse(soap, tag, id, (ns1__closeHentCursorResponse *const*)ptr, "ns1:closeHentCursorResponse");
	case SOAP_TYPE_PointerTons1__fetchHentsResponse:
		return soap_out_PointerTons1__fetchHentsResponse(soap, tag, id, (ns1__fetchHentsResponse *const*)ptr, "ns1:fetchHentsResponse");
	case SOAP_TYPE_PointerTons1__cursorRequest:
		return soap_out_PointerTons1__cursorRequest(soap, tag, id, (ns1__cursorRequest *const*)ptr, "ns1:cursorRequest");
	case SOAP_TYPE_PointerTons1__openHentCursorResponse:
		return soap_out_PointerTons1__openHentCursorResponse(soap, tag, id, (ns1__openHentCursorResponse *const*)ptr, "ns1:openHentCursorResponse");
	case SOAP_TYPE_PointerTons1__closeSessionResponse:
		return soap_out_PointerTons1__closeSessionResponse(soap, tag, id, (ns1__closeSessionResponse *const*)ptr, "ns1:closeSessionResponse");
	case SOAP_TYPE_PointerTons1__openOfficeSessionRequest:
		return soap_out_PointerTons1__openOfficeSessionRequest(soap, tag, id, (ns1__openOfficeSessionRequest *const*)ptr, "ns1:openOfficeSessionRequest");
	case SOAP_TYPE_PointerTons1__openSessionResponse:
		return soap_out_PointerTons1__openSessionResponse(soap, tag, id, (ns1__openSessionResponse *const*)ptr, "ns1:openSessionResponse");
	case SOAP_TYPE_PointerTons1__openMobileSessionRequest:
		return soap_out_PointerTons1__openMobileSessionRequest(soap, tag, id, (ns1__openMobileSessionRequest *const*)ptr, "ns1:openMobileSessionRequest");
	case SOAP_TYPE_PointerTons1__qualifiedPurchase:
		return soap_out_PointerTons1__qualifiedPurchase(soap, tag, id, (ns1__qualifiedPurchase *const*)ptr, "ns1:qualifiedPurchase");
	case SOAP_TYPE_PointerTons1__purchase:
		return soap_out_PointerTons1__purchase(soap, tag, id, (ns1__purchase *const*)ptr, "ns1:purchase");
	case SOAP_TYPE_PointerTons1__company:
		return soap_out_PointerTons1__company(soap, tag, id, (ns1__company *const*)ptr, "ns1:company");
	case SOAP_TYPE_PointerTons1__stock:
		return soap_out_PointerTons1__stock(soap, tag, id, (ns1__stock *const*)ptr, "ns1:stock");
	case SOAP_TYPE_PointerTons1__sessionRequest:
		return soap_out_PointerTons1__sessionRequest(soap, tag, id, (ns1__sessionRequest *const*)ptr, "ns1:sessionRequest");
	case SOAP_TYPE_PointerTons1__result:
		return soap_out_PointerTons1__result(soap, tag, id, (ns1__result *const*)ptr, "ns1:result");
	case SOAP_TYPE_PointerTons1__hent:
		return soap_out_PointerTons1__hent(soap, tag, id, (ns1__hent *const*)ptr, "ns1:hent");
	case SOAP_TYPE_PointerTons1__invoice:
		return soap_out_PointerTons1__invoice(soap, tag, id, (ns1__invoice *const*)ptr, "ns1:invoice");
	case SOAP_TYPE_PointerTons1__cow:
		return soap_out_PointerTons1__cow(soap, tag, id, (ns1__cow *const*)ptr, "ns1:cow");
	case SOAP_TYPE_PointerTodouble:
		return soap_out_PointerTodouble(soap, tag, id, (double *const*)ptr, "xsd:double");
	case SOAP_TYPE_PointerTotime:
		return soap_out_PointerTotime(soap, tag, id, (time_t *const*)ptr, "xsd:dateTime");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_ns1__downloadPurchaseRequest:
		((ns1__downloadPurchaseRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__downloadPurchaseResponse:
		((ns1__downloadPurchaseResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__fetchPurchasesResponse:
		((ns1__fetchPurchasesResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__closePurchaseCursorResponse:
		((ns1__closePurchaseCursorResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__openPurchaseCursorResponse:
		((ns1__openPurchaseCursorResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__uploadPurchaseResponse:
		((ns1__uploadPurchaseResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__uploadPurchaseRequest:
		((ns1__uploadPurchaseRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__fetchCompanyResponse:
		((ns1__fetchCompanyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__updateCompanyRequest:
		((ns1__updateCompanyRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__updateCompanyResponse:
		((ns1__updateCompanyResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__fetchStocksResponse:
		((ns1__fetchStocksResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__closeStockCursorResponse:
		((ns1__closeStockCursorResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__openStockCursorResponse:
		((ns1__openStockCursorResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__openHentCursorResponse:
		((ns1__openHentCursorResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__closeHentCursorResponse:
		((ns1__closeHentCursorResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__openSyncTransactionResponse:
		((ns1__openSyncTransactionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__closeSessionResponse:
		((ns1__closeSessionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__fetchHentsResponse:
		((ns1__fetchHentsResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__updateStockResponse:
		((ns1__updateStockResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__updateStockRequest:
		((ns1__updateStockRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__updateHentResponse:
		((ns1__updateHentResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__updateHentRequest:
		((ns1__updateHentRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__commitSyncTransactionResponse:
		((ns1__commitSyncTransactionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__commitSyncTransactionRequest:
		((ns1__commitSyncTransactionRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__closeSyncTransactionResponse:
		((ns1__closeSyncTransactionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__closeSyncTransactionRequest:
		((ns1__closeSyncTransactionRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__cursorRequest:
		((ns1__cursorRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__sessionRequest:
		((ns1__sessionRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__openSessionResponse:
		((ns1__openSessionResponse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__openOfficeSessionRequest:
		((ns1__openOfficeSessionRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__openMobileSessionRequest:
		((ns1__openMobileSessionRequest *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__result:
		((ns1__result *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__qualifiedPurchase:
		((ns1__qualifiedPurchase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__purchase:
		((ns1__purchase *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__invoice:
		((ns1__invoice *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__cow:
		((ns1__cow *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__company:
		((ns1__company *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__stock:
		((ns1__stock *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__hent:
		((ns1__hent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___ns1__downloadPurchase:
		soap_serialize___ns1__downloadPurchase(soap, (const struct __ns1__downloadPurchase *)ptr);
		break;
	case SOAP_TYPE___ns1__fetchPurchases:
		soap_serialize___ns1__fetchPurchases(soap, (const struct __ns1__fetchPurchases *)ptr);
		break;
	case SOAP_TYPE___ns1__closePurchaseCursor:
		soap_serialize___ns1__closePurchaseCursor(soap, (const struct __ns1__closePurchaseCursor *)ptr);
		break;
	case SOAP_TYPE___ns1__openPurchaseCursor:
		soap_serialize___ns1__openPurchaseCursor(soap, (const struct __ns1__openPurchaseCursor *)ptr);
		break;
	case SOAP_TYPE___ns1__uploadPurchase:
		soap_serialize___ns1__uploadPurchase(soap, (const struct __ns1__uploadPurchase *)ptr);
		break;
	case SOAP_TYPE___ns1__fetchCompany:
		soap_serialize___ns1__fetchCompany(soap, (const struct __ns1__fetchCompany *)ptr);
		break;
	case SOAP_TYPE___ns1__updateCompany:
		soap_serialize___ns1__updateCompany(soap, (const struct __ns1__updateCompany *)ptr);
		break;
	case SOAP_TYPE___ns1__closeStockCursor:
		soap_serialize___ns1__closeStockCursor(soap, (const struct __ns1__closeStockCursor *)ptr);
		break;
	case SOAP_TYPE___ns1__fetchStocks:
		soap_serialize___ns1__fetchStocks(soap, (const struct __ns1__fetchStocks *)ptr);
		break;
	case SOAP_TYPE___ns1__openStockCursor:
		soap_serialize___ns1__openStockCursor(soap, (const struct __ns1__openStockCursor *)ptr);
		break;
	case SOAP_TYPE___ns1__commitSyncTransaction:
		soap_serialize___ns1__commitSyncTransaction(soap, (const struct __ns1__commitSyncTransaction *)ptr);
		break;
	case SOAP_TYPE___ns1__closeSyncTransaction:
		soap_serialize___ns1__closeSyncTransaction(soap, (const struct __ns1__closeSyncTransaction *)ptr);
		break;
	case SOAP_TYPE___ns1__updateStock:
		soap_serialize___ns1__updateStock(soap, (const struct __ns1__updateStock *)ptr);
		break;
	case SOAP_TYPE___ns1__updateHent:
		soap_serialize___ns1__updateHent(soap, (const struct __ns1__updateHent *)ptr);
		break;
	case SOAP_TYPE___ns1__openSyncTransaction:
		soap_serialize___ns1__openSyncTransaction(soap, (const struct __ns1__openSyncTransaction *)ptr);
		break;
	case SOAP_TYPE___ns1__closeHentCursor:
		soap_serialize___ns1__closeHentCursor(soap, (const struct __ns1__closeHentCursor *)ptr);
		break;
	case SOAP_TYPE___ns1__fetchHents:
		soap_serialize___ns1__fetchHents(soap, (const struct __ns1__fetchHents *)ptr);
		break;
	case SOAP_TYPE___ns1__openHentCursor:
		soap_serialize___ns1__openHentCursor(soap, (const struct __ns1__openHentCursor *)ptr);
		break;
	case SOAP_TYPE___ns1__closeSession:
		soap_serialize___ns1__closeSession(soap, (const struct __ns1__closeSession *)ptr);
		break;
	case SOAP_TYPE___ns1__openOfficeSession:
		soap_serialize___ns1__openOfficeSession(soap, (const struct __ns1__openOfficeSession *)ptr);
		break;
	case SOAP_TYPE___ns1__openMobileSession:
		soap_serialize___ns1__openMobileSession(soap, (const struct __ns1__openMobileSession *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__downloadPurchaseResponse:
		soap_serialize_PointerTons1__downloadPurchaseResponse(soap, (ns1__downloadPurchaseResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__downloadPurchaseRequest:
		soap_serialize_PointerTons1__downloadPurchaseRequest(soap, (ns1__downloadPurchaseRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__fetchPurchasesResponse:
		soap_serialize_PointerTons1__fetchPurchasesResponse(soap, (ns1__fetchPurchasesResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__closePurchaseCursorResponse:
		soap_serialize_PointerTons1__closePurchaseCursorResponse(soap, (ns1__closePurchaseCursorResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__openPurchaseCursorResponse:
		soap_serialize_PointerTons1__openPurchaseCursorResponse(soap, (ns1__openPurchaseCursorResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__uploadPurchaseResponse:
		soap_serialize_PointerTons1__uploadPurchaseResponse(soap, (ns1__uploadPurchaseResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__uploadPurchaseRequest:
		soap_serialize_PointerTons1__uploadPurchaseRequest(soap, (ns1__uploadPurchaseRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__fetchCompanyResponse:
		soap_serialize_PointerTons1__fetchCompanyResponse(soap, (ns1__fetchCompanyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__updateCompanyResponse:
		soap_serialize_PointerTons1__updateCompanyResponse(soap, (ns1__updateCompanyResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__updateCompanyRequest:
		soap_serialize_PointerTons1__updateCompanyRequest(soap, (ns1__updateCompanyRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__closeStockCursorResponse:
		soap_serialize_PointerTons1__closeStockCursorResponse(soap, (ns1__closeStockCursorResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__fetchStocksResponse:
		soap_serialize_PointerTons1__fetchStocksResponse(soap, (ns1__fetchStocksResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__openStockCursorResponse:
		soap_serialize_PointerTons1__openStockCursorResponse(soap, (ns1__openStockCursorResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__commitSyncTransactionResponse:
		soap_serialize_PointerTons1__commitSyncTransactionResponse(soap, (ns1__commitSyncTransactionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__closeSyncTransactionResponse:
		soap_serialize_PointerTons1__closeSyncTransactionResponse(soap, (ns1__closeSyncTransactionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__updateStockResponse:
		soap_serialize_PointerTons1__updateStockResponse(soap, (ns1__updateStockResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__updateStockRequest:
		soap_serialize_PointerTons1__updateStockRequest(soap, (ns1__updateStockRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__updateHentResponse:
		soap_serialize_PointerTons1__updateHentResponse(soap, (ns1__updateHentResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__updateHentRequest:
		soap_serialize_PointerTons1__updateHentRequest(soap, (ns1__updateHentRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__openSyncTransactionResponse:
		soap_serialize_PointerTons1__openSyncTransactionResponse(soap, (ns1__openSyncTransactionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__closeHentCursorResponse:
		soap_serialize_PointerTons1__closeHentCursorResponse(soap, (ns1__closeHentCursorResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__fetchHentsResponse:
		soap_serialize_PointerTons1__fetchHentsResponse(soap, (ns1__fetchHentsResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__cursorRequest:
		soap_serialize_PointerTons1__cursorRequest(soap, (ns1__cursorRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__openHentCursorResponse:
		soap_serialize_PointerTons1__openHentCursorResponse(soap, (ns1__openHentCursorResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__closeSessionResponse:
		soap_serialize_PointerTons1__closeSessionResponse(soap, (ns1__closeSessionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__openOfficeSessionRequest:
		soap_serialize_PointerTons1__openOfficeSessionRequest(soap, (ns1__openOfficeSessionRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__openSessionResponse:
		soap_serialize_PointerTons1__openSessionResponse(soap, (ns1__openSessionResponse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__openMobileSessionRequest:
		soap_serialize_PointerTons1__openMobileSessionRequest(soap, (ns1__openMobileSessionRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__qualifiedPurchase:
		soap_serialize_PointerTons1__qualifiedPurchase(soap, (ns1__qualifiedPurchase *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__purchase:
		soap_serialize_PointerTons1__purchase(soap, (ns1__purchase *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__company:
		soap_serialize_PointerTons1__company(soap, (ns1__company *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__stock:
		soap_serialize_PointerTons1__stock(soap, (ns1__stock *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__sessionRequest:
		soap_serialize_PointerTons1__sessionRequest(soap, (ns1__sessionRequest *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__result:
		soap_serialize_PointerTons1__result(soap, (ns1__result *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__hent:
		soap_serialize_PointerTons1__hent(soap, (ns1__hent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__invoice:
		soap_serialize_PointerTons1__invoice(soap, (ns1__invoice *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__cow:
		soap_serialize_PointerTons1__cow(soap, (ns1__cow *const*)ptr);
		break;
	case SOAP_TYPE_PointerTodouble:
		soap_serialize_PointerTodouble(soap, (double *const*)ptr);
		break;
	case SOAP_TYPE_PointerTotime:
		soap_serialize_PointerTotime(soap, (time_t *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 BKRepoService_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{	(void)type;
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__hent:
		return (void*)soap_instantiate_ns1__hent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__stock:
		return (void*)soap_instantiate_ns1__stock(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__company:
		return (void*)soap_instantiate_ns1__company(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cow:
		return (void*)soap_instantiate_ns1__cow(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__invoice:
		return (void*)soap_instantiate_ns1__invoice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__purchase:
		return (void*)soap_instantiate_ns1__purchase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__result:
		return (void*)soap_instantiate_ns1__result(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__openMobileSessionRequest:
		return (void*)soap_instantiate_ns1__openMobileSessionRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__openOfficeSessionRequest:
		return (void*)soap_instantiate_ns1__openOfficeSessionRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__openSessionResponse:
		return (void*)soap_instantiate_ns1__openSessionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__sessionRequest:
		return (void*)soap_instantiate_ns1__sessionRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__closeSyncTransactionRequest:
		return (void*)soap_instantiate_ns1__closeSyncTransactionRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__closeSyncTransactionResponse:
		return (void*)soap_instantiate_ns1__closeSyncTransactionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__commitSyncTransactionRequest:
		return (void*)soap_instantiate_ns1__commitSyncTransactionRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__commitSyncTransactionResponse:
		return (void*)soap_instantiate_ns1__commitSyncTransactionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__updateHentRequest:
		return (void*)soap_instantiate_ns1__updateHentRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__updateHentResponse:
		return (void*)soap_instantiate_ns1__updateHentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__updateStockRequest:
		return (void*)soap_instantiate_ns1__updateStockRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__updateStockResponse:
		return (void*)soap_instantiate_ns1__updateStockResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__fetchHentsResponse:
		return (void*)soap_instantiate_ns1__fetchHentsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__closeSessionResponse:
		return (void*)soap_instantiate_ns1__closeSessionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__openSyncTransactionResponse:
		return (void*)soap_instantiate_ns1__openSyncTransactionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__closeHentCursorResponse:
		return (void*)soap_instantiate_ns1__closeHentCursorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__openHentCursorResponse:
		return (void*)soap_instantiate_ns1__openHentCursorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__openStockCursorResponse:
		return (void*)soap_instantiate_ns1__openStockCursorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__closeStockCursorResponse:
		return (void*)soap_instantiate_ns1__closeStockCursorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__fetchStocksResponse:
		return (void*)soap_instantiate_ns1__fetchStocksResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__updateCompanyResponse:
		return (void*)soap_instantiate_ns1__updateCompanyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__updateCompanyRequest:
		return (void*)soap_instantiate_ns1__updateCompanyRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__fetchCompanyResponse:
		return (void*)soap_instantiate_ns1__fetchCompanyResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__uploadPurchaseRequest:
		return (void*)soap_instantiate_ns1__uploadPurchaseRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__uploadPurchaseResponse:
		return (void*)soap_instantiate_ns1__uploadPurchaseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__openPurchaseCursorResponse:
		return (void*)soap_instantiate_ns1__openPurchaseCursorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__closePurchaseCursorResponse:
		return (void*)soap_instantiate_ns1__closePurchaseCursorResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__fetchPurchasesResponse:
		return (void*)soap_instantiate_ns1__fetchPurchasesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__downloadPurchaseResponse:
		return (void*)soap_instantiate_ns1__downloadPurchaseResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__downloadPurchaseRequest:
		return (void*)soap_instantiate_ns1__downloadPurchaseRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__qualifiedPurchase:
		return (void*)soap_instantiate_ns1__qualifiedPurchase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__cursorRequest:
		return (void*)soap_instantiate_ns1__cursorRequest(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__openMobileSession:
		return (void*)soap_instantiate___ns1__openMobileSession(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__openOfficeSession:
		return (void*)soap_instantiate___ns1__openOfficeSession(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__closeSession:
		return (void*)soap_instantiate___ns1__closeSession(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__openHentCursor:
		return (void*)soap_instantiate___ns1__openHentCursor(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__fetchHents:
		return (void*)soap_instantiate___ns1__fetchHents(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__closeHentCursor:
		return (void*)soap_instantiate___ns1__closeHentCursor(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__openSyncTransaction:
		return (void*)soap_instantiate___ns1__openSyncTransaction(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__updateHent:
		return (void*)soap_instantiate___ns1__updateHent(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__updateStock:
		return (void*)soap_instantiate___ns1__updateStock(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__closeSyncTransaction:
		return (void*)soap_instantiate___ns1__closeSyncTransaction(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__commitSyncTransaction:
		return (void*)soap_instantiate___ns1__commitSyncTransaction(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__openStockCursor:
		return (void*)soap_instantiate___ns1__openStockCursor(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__fetchStocks:
		return (void*)soap_instantiate___ns1__fetchStocks(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__closeStockCursor:
		return (void*)soap_instantiate___ns1__closeStockCursor(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__updateCompany:
		return (void*)soap_instantiate___ns1__updateCompany(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__fetchCompany:
		return (void*)soap_instantiate___ns1__fetchCompany(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__uploadPurchase:
		return (void*)soap_instantiate___ns1__uploadPurchase(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__openPurchaseCursor:
		return (void*)soap_instantiate___ns1__openPurchaseCursor(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__closePurchaseCursor:
		return (void*)soap_instantiate___ns1__closePurchaseCursor(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__fetchPurchases:
		return (void*)soap_instantiate___ns1__fetchPurchases(soap, -1, type, arrayType, n);
	case SOAP_TYPE___ns1__downloadPurchase:
		return (void*)soap_instantiate___ns1__downloadPurchase(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__qualifiedPurchase:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__qualifiedPurchase(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__stock:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__stock(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__hent:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__hent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__invoice:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__invoice(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__cow:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTons1__cow(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 BKRepoService_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			SOAP_DELETE((std::string*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::string*)p->ptr);
		break;
	case SOAP_TYPE_ns1__hent:
		if (p->size < 0)
			SOAP_DELETE((ns1__hent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__hent*)p->ptr);
		break;
	case SOAP_TYPE_ns1__stock:
		if (p->size < 0)
			SOAP_DELETE((ns1__stock*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__stock*)p->ptr);
		break;
	case SOAP_TYPE_ns1__company:
		if (p->size < 0)
			SOAP_DELETE((ns1__company*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__company*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cow:
		if (p->size < 0)
			SOAP_DELETE((ns1__cow*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__cow*)p->ptr);
		break;
	case SOAP_TYPE_ns1__invoice:
		if (p->size < 0)
			SOAP_DELETE((ns1__invoice*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__invoice*)p->ptr);
		break;
	case SOAP_TYPE_ns1__purchase:
		if (p->size < 0)
			SOAP_DELETE((ns1__purchase*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__purchase*)p->ptr);
		break;
	case SOAP_TYPE_ns1__result:
		if (p->size < 0)
			SOAP_DELETE((ns1__result*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__result*)p->ptr);
		break;
	case SOAP_TYPE_ns1__openMobileSessionRequest:
		if (p->size < 0)
			SOAP_DELETE((ns1__openMobileSessionRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__openMobileSessionRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns1__openOfficeSessionRequest:
		if (p->size < 0)
			SOAP_DELETE((ns1__openOfficeSessionRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__openOfficeSessionRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns1__openSessionResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__openSessionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__openSessionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__sessionRequest:
		if (p->size < 0)
			SOAP_DELETE((ns1__sessionRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__sessionRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns1__closeSyncTransactionRequest:
		if (p->size < 0)
			SOAP_DELETE((ns1__closeSyncTransactionRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__closeSyncTransactionRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns1__closeSyncTransactionResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__closeSyncTransactionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__closeSyncTransactionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__commitSyncTransactionRequest:
		if (p->size < 0)
			SOAP_DELETE((ns1__commitSyncTransactionRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__commitSyncTransactionRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns1__commitSyncTransactionResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__commitSyncTransactionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__commitSyncTransactionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__updateHentRequest:
		if (p->size < 0)
			SOAP_DELETE((ns1__updateHentRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__updateHentRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns1__updateHentResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__updateHentResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__updateHentResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__updateStockRequest:
		if (p->size < 0)
			SOAP_DELETE((ns1__updateStockRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__updateStockRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns1__updateStockResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__updateStockResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__updateStockResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__fetchHentsResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__fetchHentsResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__fetchHentsResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__closeSessionResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__closeSessionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__closeSessionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__openSyncTransactionResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__openSyncTransactionResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__openSyncTransactionResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__closeHentCursorResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__closeHentCursorResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__closeHentCursorResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__openHentCursorResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__openHentCursorResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__openHentCursorResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__openStockCursorResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__openStockCursorResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__openStockCursorResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__closeStockCursorResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__closeStockCursorResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__closeStockCursorResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__fetchStocksResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__fetchStocksResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__fetchStocksResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__updateCompanyResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__updateCompanyResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__updateCompanyResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__updateCompanyRequest:
		if (p->size < 0)
			SOAP_DELETE((ns1__updateCompanyRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__updateCompanyRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns1__fetchCompanyResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__fetchCompanyResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__fetchCompanyResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__uploadPurchaseRequest:
		if (p->size < 0)
			SOAP_DELETE((ns1__uploadPurchaseRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__uploadPurchaseRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns1__uploadPurchaseResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__uploadPurchaseResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__uploadPurchaseResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__openPurchaseCursorResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__openPurchaseCursorResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__openPurchaseCursorResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__closePurchaseCursorResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__closePurchaseCursorResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__closePurchaseCursorResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__fetchPurchasesResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__fetchPurchasesResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__fetchPurchasesResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__downloadPurchaseResponse:
		if (p->size < 0)
			SOAP_DELETE((ns1__downloadPurchaseResponse*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__downloadPurchaseResponse*)p->ptr);
		break;
	case SOAP_TYPE_ns1__downloadPurchaseRequest:
		if (p->size < 0)
			SOAP_DELETE((ns1__downloadPurchaseRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__downloadPurchaseRequest*)p->ptr);
		break;
	case SOAP_TYPE_ns1__qualifiedPurchase:
		if (p->size < 0)
			SOAP_DELETE((ns1__qualifiedPurchase*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__qualifiedPurchase*)p->ptr);
		break;
	case SOAP_TYPE_ns1__cursorRequest:
		if (p->size < 0)
			SOAP_DELETE((ns1__cursorRequest*)p->ptr);
		else
			SOAP_DELETE_ARRAY((ns1__cursorRequest*)p->ptr);
		break;
	case SOAP_TYPE___ns1__openMobileSession:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__openMobileSession*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__openMobileSession*)p->ptr);
		break;
	case SOAP_TYPE___ns1__openOfficeSession:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__openOfficeSession*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__openOfficeSession*)p->ptr);
		break;
	case SOAP_TYPE___ns1__closeSession:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__closeSession*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__closeSession*)p->ptr);
		break;
	case SOAP_TYPE___ns1__openHentCursor:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__openHentCursor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__openHentCursor*)p->ptr);
		break;
	case SOAP_TYPE___ns1__fetchHents:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__fetchHents*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__fetchHents*)p->ptr);
		break;
	case SOAP_TYPE___ns1__closeHentCursor:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__closeHentCursor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__closeHentCursor*)p->ptr);
		break;
	case SOAP_TYPE___ns1__openSyncTransaction:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__openSyncTransaction*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__openSyncTransaction*)p->ptr);
		break;
	case SOAP_TYPE___ns1__updateHent:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__updateHent*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__updateHent*)p->ptr);
		break;
	case SOAP_TYPE___ns1__updateStock:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__updateStock*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__updateStock*)p->ptr);
		break;
	case SOAP_TYPE___ns1__closeSyncTransaction:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__closeSyncTransaction*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__closeSyncTransaction*)p->ptr);
		break;
	case SOAP_TYPE___ns1__commitSyncTransaction:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__commitSyncTransaction*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__commitSyncTransaction*)p->ptr);
		break;
	case SOAP_TYPE___ns1__openStockCursor:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__openStockCursor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__openStockCursor*)p->ptr);
		break;
	case SOAP_TYPE___ns1__fetchStocks:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__fetchStocks*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__fetchStocks*)p->ptr);
		break;
	case SOAP_TYPE___ns1__closeStockCursor:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__closeStockCursor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__closeStockCursor*)p->ptr);
		break;
	case SOAP_TYPE___ns1__updateCompany:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__updateCompany*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__updateCompany*)p->ptr);
		break;
	case SOAP_TYPE___ns1__fetchCompany:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__fetchCompany*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__fetchCompany*)p->ptr);
		break;
	case SOAP_TYPE___ns1__uploadPurchase:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__uploadPurchase*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__uploadPurchase*)p->ptr);
		break;
	case SOAP_TYPE___ns1__openPurchaseCursor:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__openPurchaseCursor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__openPurchaseCursor*)p->ptr);
		break;
	case SOAP_TYPE___ns1__closePurchaseCursor:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__closePurchaseCursor*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__closePurchaseCursor*)p->ptr);
		break;
	case SOAP_TYPE___ns1__fetchPurchases:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__fetchPurchases*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__fetchPurchases*)p->ptr);
		break;
	case SOAP_TYPE___ns1__downloadPurchase:
		if (p->size < 0)
			SOAP_DELETE((struct __ns1__downloadPurchase*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct __ns1__downloadPurchase*)p->ptr);
		break;
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Header*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Header*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Code*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Code*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Detail*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Detail*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Reason*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Reason*)p->ptr);
		break;
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			SOAP_DELETE((struct SOAP_ENV__Fault*)p->ptr);
		else
			SOAP_DELETE_ARRAY((struct SOAP_ENV__Fault*)p->ptr);
		break;
#endif
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__qualifiedPurchase:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__qualifiedPurchase * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__qualifiedPurchase * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__stock:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__stock * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__stock * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__hent:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__hent * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__hent * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__invoice:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__invoice * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__invoice * >*)p->ptr);
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__cow:
		if (p->size < 0)
			SOAP_DELETE((std::vector<ns1__cow * >*)p->ptr);
		else
			SOAP_DELETE_ARRAY((std::vector<ns1__cow * >*)p->ptr);
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, BKRepoService_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, BKRepoService_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 BKRepoService_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
#ifdef WIN32
#pragma warning(push)
#pragma warning(disable:4065)
#endif
{
	(void)soap; (void)st; (void)p; (void)len; (void)q; (void)n; /* appease -Wall -Werror */
	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__qualifiedPurchase:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container BKRepoService_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__qualifiedPurchase * >*)p)[len] = *(ns1__qualifiedPurchase **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__stock:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container BKRepoService_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__stock * >*)p)[len] = *(ns1__stock **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__hent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container BKRepoService_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__hent * >*)p)[len] = *(ns1__hent **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__invoice:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container BKRepoService_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__invoice * >*)p)[len] = *(ns1__invoice **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTons1__cow:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container BKRepoService_container_insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<ns1__cow * >*)p)[len] = *(ns1__cow **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
#ifdef WIN32
#pragma warning(pop)
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{	char *p;
	p = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{	int *p;
	p = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_double(struct soap *soap, double *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdouble(soap, tag, id, a, type, SOAP_TYPE_double);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{	double *p;
	p = soap_indouble(soap, tag, a, type, SOAP_TYPE_double);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_double(struct soap *soap, const double *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_double);
	if (soap_out_double(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double * SOAP_FMAC4 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_time(struct soap *soap, time_t *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_time
	*a = SOAP_DEFAULT_time;
#else
	*a = (time_t)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_time(struct soap *soap, const char *tag, int id, const time_t *a, const char *type)
{	(void)soap; (void)type; (void)tag; (void)id;
	return soap_outdateTime(soap, tag, id, a, type, SOAP_TYPE_time);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_in_time(struct soap *soap, const char *tag, time_t *a, const char *type)
{	time_t *p;
	p = soap_indateTime(soap, tag, a, type, SOAP_TYPE_time);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_time(struct soap *soap, const time_t *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_time);
	if (soap_out_time(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t * SOAP_FMAC4 soap_get_time(struct soap *soap, time_t *p, const char *tag, const char *type)
{
	if ((p = soap_in_time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_bool(struct soap *soap, bool *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

static const struct soap_code_map soap_codes_bool[] =
{	{ (long)false, "false" },
	{ (long)true, "true" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_bool2s(struct soap *soap, bool n)
{
	(void)soap; /* appease -Wall -Werror */
return soap_code_str(soap_codes_bool, n!=0);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type) || soap_send(soap, soap_bool2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_bool, s);
	if (map)
		*a = (bool)(map->code != 0);
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || n < 0 || n > 1)
			return soap->error = SOAP_TYPE;
		*a = (bool)(n != 0);
	}
	return SOAP_OK;
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":boolean"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2bool(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_bool, 0, sizeof(bool), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_bool(struct soap *soap, const bool *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_bool);
	if (soap_out_bool(soap, tag?tag:"boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 bool * SOAP_FMAC4 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__status(struct soap *soap, enum ns1__status *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__status
	*a = SOAP_DEFAULT_ns1__status;
#else
	*a = (enum ns1__status)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__status[] =
{	{ (long)ns1__status__SUCCESS, "SUCCESS" },
	{ (long)ns1__status__FAILURE, "FAILURE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__status2s(struct soap *soap, enum ns1__status n)
{	const char *s = soap_code_str(soap_codes_ns1__status, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__status(struct soap *soap, const char *tag, int id, const enum ns1__status *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__status), type) || soap_send(soap, soap_ns1__status2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__status(struct soap *soap, const char *s, enum ns1__status *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__status, s);
	if (map)
		*a = (enum ns1__status)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__status)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__status * SOAP_FMAC4 soap_in_ns1__status(struct soap *soap, const char *tag, enum ns1__status *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__status *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__status, sizeof(enum ns1__status), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__status(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__status, 0, sizeof(enum ns1__status), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__status(struct soap *soap, const enum ns1__status *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__status);
	if (soap_out_ns1__status(soap, tag?tag:"ns1:status", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__status * SOAP_FMAC4 soap_get_ns1__status(struct soap *soap, enum ns1__status *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__invoiceType(struct soap *soap, enum ns1__invoiceType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__invoiceType
	*a = SOAP_DEFAULT_ns1__invoiceType;
#else
	*a = (enum ns1__invoiceType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__invoiceType[] =
{	{ (long)ns1__invoiceType__LUMP, "LUMP" },
	{ (long)ns1__invoiceType__REGULAR, "REGULAR" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__invoiceType2s(struct soap *soap, enum ns1__invoiceType n)
{	const char *s = soap_code_str(soap_codes_ns1__invoiceType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__invoiceType(struct soap *soap, const char *tag, int id, const enum ns1__invoiceType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__invoiceType), type) || soap_send(soap, soap_ns1__invoiceType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__invoiceType(struct soap *soap, const char *s, enum ns1__invoiceType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__invoiceType, s);
	if (map)
		*a = (enum ns1__invoiceType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__invoiceType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__invoiceType * SOAP_FMAC4 soap_in_ns1__invoiceType(struct soap *soap, const char *tag, enum ns1__invoiceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__invoiceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__invoiceType, sizeof(enum ns1__invoiceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__invoiceType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__invoiceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__invoiceType, 0, sizeof(enum ns1__invoiceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__invoiceType(struct soap *soap, const enum ns1__invoiceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__invoiceType);
	if (soap_out_ns1__invoiceType(soap, tag?tag:"ns1:invoiceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__invoiceType * SOAP_FMAC4 soap_get_ns1__invoiceType(struct soap *soap, enum ns1__invoiceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__invoiceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__payWay(struct soap *soap, enum ns1__payWay *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__payWay
	*a = SOAP_DEFAULT_ns1__payWay;
#else
	*a = (enum ns1__payWay)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__payWay[] =
{	{ (long)ns1__payWay__CASH, "CASH" },
	{ (long)ns1__payWay__TRANSFER, "TRANSFER" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__payWay2s(struct soap *soap, enum ns1__payWay n)
{	const char *s = soap_code_str(soap_codes_ns1__payWay, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__payWay(struct soap *soap, const char *tag, int id, const enum ns1__payWay *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__payWay), type) || soap_send(soap, soap_ns1__payWay2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__payWay(struct soap *soap, const char *s, enum ns1__payWay *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__payWay, s);
	if (map)
		*a = (enum ns1__payWay)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__payWay)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__payWay * SOAP_FMAC4 soap_in_ns1__payWay(struct soap *soap, const char *tag, enum ns1__payWay *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__payWay *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__payWay, sizeof(enum ns1__payWay), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__payWay(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__payWay *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__payWay, 0, sizeof(enum ns1__payWay), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__payWay(struct soap *soap, const enum ns1__payWay *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__payWay);
	if (soap_out_ns1__payWay(soap, tag?tag:"ns1:payWay", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__payWay * SOAP_FMAC4 soap_get_ns1__payWay(struct soap *soap, enum ns1__payWay *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__payWay(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__hentType(struct soap *soap, enum ns1__hentType *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__hentType
	*a = SOAP_DEFAULT_ns1__hentType;
#else
	*a = (enum ns1__hentType)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__hentType[] =
{	{ (long)ns1__hentType__INDIVIDUAL, "INDIVIDUAL" },
	{ (long)ns1__hentType__COMPANY, "COMPANY" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__hentType2s(struct soap *soap, enum ns1__hentType n)
{	const char *s = soap_code_str(soap_codes_ns1__hentType, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__hentType(struct soap *soap, const char *tag, int id, const enum ns1__hentType *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__hentType), type) || soap_send(soap, soap_ns1__hentType2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__hentType(struct soap *soap, const char *s, enum ns1__hentType *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__hentType, s);
	if (map)
		*a = (enum ns1__hentType)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__hentType)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__hentType * SOAP_FMAC4 soap_in_ns1__hentType(struct soap *soap, const char *tag, enum ns1__hentType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__hentType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__hentType, sizeof(enum ns1__hentType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__hentType(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__hentType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__hentType, 0, sizeof(enum ns1__hentType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__hentType(struct soap *soap, const enum ns1__hentType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__hentType);
	if (soap_out_ns1__hentType(soap, tag?tag:"ns1:hentType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__hentType * SOAP_FMAC4 soap_get_ns1__hentType(struct soap *soap, enum ns1__hentType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__hentType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__cowSex(struct soap *soap, enum ns1__cowSex *a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__cowSex
	*a = SOAP_DEFAULT_ns1__cowSex;
#else
	*a = (enum ns1__cowSex)0;
#endif
}

static const struct soap_code_map soap_codes_ns1__cowSex[] =
{	{ (long)ns1__cowSex__XX, "XX" },
	{ (long)ns1__cowSex__XY, "XY" },
	{ (long)ns1__cowSex__NONE, "NONE" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__cowSex2s(struct soap *soap, enum ns1__cowSex n)
{	const char *s = soap_code_str(soap_codes_ns1__cowSex, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cowSex(struct soap *soap, const char *tag, int id, const enum ns1__cowSex *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cowSex), type) || soap_send(soap, soap_ns1__cowSex2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__cowSex(struct soap *soap, const char *s, enum ns1__cowSex *a)
{
	const struct soap_code_map *map;
	if (!s)
		return soap->error;
	map = soap_code(soap_codes_ns1__cowSex, s);
	if (map)
		*a = (enum ns1__cowSex)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__cowSex)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__cowSex * SOAP_FMAC4 soap_in_ns1__cowSex(struct soap *soap, const char *tag, enum ns1__cowSex *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__cowSex *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cowSex, sizeof(enum ns1__cowSex), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__cowSex(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__cowSex *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cowSex, 0, sizeof(enum ns1__cowSex), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__cowSex(struct soap *soap, const enum ns1__cowSex *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__cowSex);
	if (soap_out_ns1__cowSex(soap, tag?tag:"ns1:cowSex", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__cowSex * SOAP_FMAC4 soap_get_ns1__cowSex(struct soap *soap, enum ns1__cowSex *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cowSex(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{
	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *a)
{	(void)soap; (void)a; /* appease -Wall -Werror */
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
		{	if (!(t = soap_string_in(soap, 1, 0, -1)))
				return NULL;
			s->assign(t);
		}
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::string);
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::string[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void ns1__downloadPurchaseRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__downloadPurchaseRequest::session = NULL;
	soap_default_int(soap, &this->ns1__downloadPurchaseRequest::purchaseId);
	/* transient soap skipped */
}

void ns1__downloadPurchaseRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__sessionRequest(soap, &this->ns1__downloadPurchaseRequest::session);
	/* transient soap skipped */
}

int ns1__downloadPurchaseRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__downloadPurchaseRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__downloadPurchaseRequest(struct soap *soap, const char *tag, int id, const ns1__downloadPurchaseRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__downloadPurchaseRequest), type))
		return soap->error;
	if (a->ns1__downloadPurchaseRequest::session)
	{	if (soap_out_PointerTons1__sessionRequest(soap, "session", -1, &a->ns1__downloadPurchaseRequest::session, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "session"))
		return soap->error;
	if (soap_out_int(soap, "purchaseId", -1, &(a->ns1__downloadPurchaseRequest::purchaseId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__downloadPurchaseRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__downloadPurchaseRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__downloadPurchaseRequest * SOAP_FMAC4 soap_in_ns1__downloadPurchaseRequest(struct soap *soap, const char *tag, ns1__downloadPurchaseRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__downloadPurchaseRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__downloadPurchaseRequest, sizeof(ns1__downloadPurchaseRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__downloadPurchaseRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__downloadPurchaseRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_session1 = 1;
	size_t soap_flag_purchaseId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sessionRequest(soap, "session", &(a->ns1__downloadPurchaseRequest::session), "ns1:sessionRequest"))
				{	soap_flag_session1--;
					continue;
				}
			if (soap_flag_purchaseId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "purchaseId", &(a->ns1__downloadPurchaseRequest::purchaseId), "xsd:int"))
				{	soap_flag_purchaseId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__downloadPurchaseRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__downloadPurchaseRequest, 0, sizeof(ns1__downloadPurchaseRequest), 0, soap_copy_ns1__downloadPurchaseRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_session1 > 0 || soap_flag_purchaseId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__downloadPurchaseRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__downloadPurchaseRequest);
	if (this->soap_out(soap, tag?tag:"ns1:downloadPurchaseRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__downloadPurchaseRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__downloadPurchaseRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__downloadPurchaseRequest * SOAP_FMAC4 soap_get_ns1__downloadPurchaseRequest(struct soap *soap, ns1__downloadPurchaseRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__downloadPurchaseRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__downloadPurchaseRequest * SOAP_FMAC2 soap_instantiate_ns1__downloadPurchaseRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__downloadPurchaseRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__downloadPurchaseRequest, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__downloadPurchaseRequest);
		if (size)
			*size = sizeof(ns1__downloadPurchaseRequest);
		((ns1__downloadPurchaseRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__downloadPurchaseRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__downloadPurchaseRequest);
		for (int i = 0; i < n; i++)
			((ns1__downloadPurchaseRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__downloadPurchaseRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__downloadPurchaseRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__downloadPurchaseRequest %p -> %p\n", q, p));
	*(ns1__downloadPurchaseRequest*)p = *(ns1__downloadPurchaseRequest*)q;
}

void ns1__downloadPurchaseResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__downloadPurchaseResponse::result = NULL;
	/* transient soap skipped */
}

void ns1__downloadPurchaseResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__result(soap, &this->ns1__downloadPurchaseResponse::result);
	/* transient soap skipped */
}

int ns1__downloadPurchaseResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__downloadPurchaseResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__downloadPurchaseResponse(struct soap *soap, const char *tag, int id, const ns1__downloadPurchaseResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__downloadPurchaseResponse), type))
		return soap->error;
	if (a->ns1__downloadPurchaseResponse::result)
	{	if (soap_out_PointerTons1__result(soap, "result", -1, &a->ns1__downloadPurchaseResponse::result, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "result"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__downloadPurchaseResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__downloadPurchaseResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__downloadPurchaseResponse * SOAP_FMAC4 soap_in_ns1__downloadPurchaseResponse(struct soap *soap, const char *tag, ns1__downloadPurchaseResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__downloadPurchaseResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__downloadPurchaseResponse, sizeof(ns1__downloadPurchaseResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__downloadPurchaseResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__downloadPurchaseResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__result(soap, "result", &(a->ns1__downloadPurchaseResponse::result), "ns1:result"))
				{	soap_flag_result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__downloadPurchaseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__downloadPurchaseResponse, 0, sizeof(ns1__downloadPurchaseResponse), 0, soap_copy_ns1__downloadPurchaseResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__downloadPurchaseResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__downloadPurchaseResponse);
	if (this->soap_out(soap, tag?tag:"ns1:downloadPurchaseResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__downloadPurchaseResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__downloadPurchaseResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__downloadPurchaseResponse * SOAP_FMAC4 soap_get_ns1__downloadPurchaseResponse(struct soap *soap, ns1__downloadPurchaseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__downloadPurchaseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__downloadPurchaseResponse * SOAP_FMAC2 soap_instantiate_ns1__downloadPurchaseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__downloadPurchaseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__downloadPurchaseResponse, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__downloadPurchaseResponse);
		if (size)
			*size = sizeof(ns1__downloadPurchaseResponse);
		((ns1__downloadPurchaseResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__downloadPurchaseResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__downloadPurchaseResponse);
		for (int i = 0; i < n; i++)
			((ns1__downloadPurchaseResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__downloadPurchaseResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__downloadPurchaseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__downloadPurchaseResponse %p -> %p\n", q, p));
	*(ns1__downloadPurchaseResponse*)p = *(ns1__downloadPurchaseResponse*)q;
}

void ns1__fetchPurchasesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__qualifiedPurchase(soap, &this->ns1__fetchPurchasesResponse::purchase);
	this->ns1__fetchPurchasesResponse::result = NULL;
	/* transient soap skipped */
}

void ns1__fetchPurchasesResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__qualifiedPurchase(soap, &this->ns1__fetchPurchasesResponse::purchase);
	soap_serialize_PointerTons1__result(soap, &this->ns1__fetchPurchasesResponse::result);
	/* transient soap skipped */
}

int ns1__fetchPurchasesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__fetchPurchasesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__fetchPurchasesResponse(struct soap *soap, const char *tag, int id, const ns1__fetchPurchasesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__fetchPurchasesResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__qualifiedPurchase(soap, "purchase", -1, &(a->ns1__fetchPurchasesResponse::purchase), ""))
		return soap->error;
	if (a->ns1__fetchPurchasesResponse::result)
	{	if (soap_out_PointerTons1__result(soap, "result", -1, &a->ns1__fetchPurchasesResponse::result, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "result"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__fetchPurchasesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__fetchPurchasesResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__fetchPurchasesResponse * SOAP_FMAC4 soap_in_ns1__fetchPurchasesResponse(struct soap *soap, const char *tag, ns1__fetchPurchasesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__fetchPurchasesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__fetchPurchasesResponse, sizeof(ns1__fetchPurchasesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__fetchPurchasesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__fetchPurchasesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__qualifiedPurchase(soap, "purchase", &(a->ns1__fetchPurchasesResponse::purchase), "ns1:qualifiedPurchase"))
					continue;
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__result(soap, "result", &(a->ns1__fetchPurchasesResponse::result), "ns1:result"))
				{	soap_flag_result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__fetchPurchasesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__fetchPurchasesResponse, 0, sizeof(ns1__fetchPurchasesResponse), 0, soap_copy_ns1__fetchPurchasesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__fetchPurchasesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__fetchPurchasesResponse);
	if (this->soap_out(soap, tag?tag:"ns1:fetchPurchasesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__fetchPurchasesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__fetchPurchasesResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__fetchPurchasesResponse * SOAP_FMAC4 soap_get_ns1__fetchPurchasesResponse(struct soap *soap, ns1__fetchPurchasesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__fetchPurchasesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__fetchPurchasesResponse * SOAP_FMAC2 soap_instantiate_ns1__fetchPurchasesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__fetchPurchasesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__fetchPurchasesResponse, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__fetchPurchasesResponse);
		if (size)
			*size = sizeof(ns1__fetchPurchasesResponse);
		((ns1__fetchPurchasesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__fetchPurchasesResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__fetchPurchasesResponse);
		for (int i = 0; i < n; i++)
			((ns1__fetchPurchasesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__fetchPurchasesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__fetchPurchasesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__fetchPurchasesResponse %p -> %p\n", q, p));
	*(ns1__fetchPurchasesResponse*)p = *(ns1__fetchPurchasesResponse*)q;
}

void ns1__closePurchaseCursorResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__closePurchaseCursorResponse::result = NULL;
	/* transient soap skipped */
}

void ns1__closePurchaseCursorResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__result(soap, &this->ns1__closePurchaseCursorResponse::result);
	/* transient soap skipped */
}

int ns1__closePurchaseCursorResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__closePurchaseCursorResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__closePurchaseCursorResponse(struct soap *soap, const char *tag, int id, const ns1__closePurchaseCursorResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__closePurchaseCursorResponse), type))
		return soap->error;
	if (a->ns1__closePurchaseCursorResponse::result)
	{	if (soap_out_PointerTons1__result(soap, "result", -1, &a->ns1__closePurchaseCursorResponse::result, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "result"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__closePurchaseCursorResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__closePurchaseCursorResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__closePurchaseCursorResponse * SOAP_FMAC4 soap_in_ns1__closePurchaseCursorResponse(struct soap *soap, const char *tag, ns1__closePurchaseCursorResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__closePurchaseCursorResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__closePurchaseCursorResponse, sizeof(ns1__closePurchaseCursorResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__closePurchaseCursorResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__closePurchaseCursorResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__result(soap, "result", &(a->ns1__closePurchaseCursorResponse::result), "ns1:result"))
				{	soap_flag_result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__closePurchaseCursorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__closePurchaseCursorResponse, 0, sizeof(ns1__closePurchaseCursorResponse), 0, soap_copy_ns1__closePurchaseCursorResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__closePurchaseCursorResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__closePurchaseCursorResponse);
	if (this->soap_out(soap, tag?tag:"ns1:closePurchaseCursorResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__closePurchaseCursorResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__closePurchaseCursorResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__closePurchaseCursorResponse * SOAP_FMAC4 soap_get_ns1__closePurchaseCursorResponse(struct soap *soap, ns1__closePurchaseCursorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__closePurchaseCursorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__closePurchaseCursorResponse * SOAP_FMAC2 soap_instantiate_ns1__closePurchaseCursorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__closePurchaseCursorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__closePurchaseCursorResponse, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__closePurchaseCursorResponse);
		if (size)
			*size = sizeof(ns1__closePurchaseCursorResponse);
		((ns1__closePurchaseCursorResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__closePurchaseCursorResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__closePurchaseCursorResponse);
		for (int i = 0; i < n; i++)
			((ns1__closePurchaseCursorResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__closePurchaseCursorResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__closePurchaseCursorResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__closePurchaseCursorResponse %p -> %p\n", q, p));
	*(ns1__closePurchaseCursorResponse*)p = *(ns1__closePurchaseCursorResponse*)q;
}

void ns1__openPurchaseCursorResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__openPurchaseCursorResponse::result = NULL;
	soap_default_int(soap, &this->ns1__openPurchaseCursorResponse::minFetch);
	soap_default_int(soap, &this->ns1__openPurchaseCursorResponse::maxFetch);
	soap_default_int(soap, &this->ns1__openPurchaseCursorResponse::count);
	/* transient soap skipped */
}

void ns1__openPurchaseCursorResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__result(soap, &this->ns1__openPurchaseCursorResponse::result);
	/* transient soap skipped */
}

int ns1__openPurchaseCursorResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__openPurchaseCursorResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__openPurchaseCursorResponse(struct soap *soap, const char *tag, int id, const ns1__openPurchaseCursorResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__openPurchaseCursorResponse), type))
		return soap->error;
	if (a->ns1__openPurchaseCursorResponse::result)
	{	if (soap_out_PointerTons1__result(soap, "result", -1, &a->ns1__openPurchaseCursorResponse::result, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "result"))
		return soap->error;
	if (soap_out_int(soap, "minFetch", -1, &(a->ns1__openPurchaseCursorResponse::minFetch), ""))
		return soap->error;
	if (soap_out_int(soap, "maxFetch", -1, &(a->ns1__openPurchaseCursorResponse::maxFetch), ""))
		return soap->error;
	if (soap_out_int(soap, "count", -1, &(a->ns1__openPurchaseCursorResponse::count), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__openPurchaseCursorResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__openPurchaseCursorResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__openPurchaseCursorResponse * SOAP_FMAC4 soap_in_ns1__openPurchaseCursorResponse(struct soap *soap, const char *tag, ns1__openPurchaseCursorResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__openPurchaseCursorResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__openPurchaseCursorResponse, sizeof(ns1__openPurchaseCursorResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__openPurchaseCursorResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__openPurchaseCursorResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	size_t soap_flag_minFetch1 = 1;
	size_t soap_flag_maxFetch1 = 1;
	size_t soap_flag_count1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__result(soap, "result", &(a->ns1__openPurchaseCursorResponse::result), "ns1:result"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag_minFetch1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "minFetch", &(a->ns1__openPurchaseCursorResponse::minFetch), "xsd:int"))
				{	soap_flag_minFetch1--;
					continue;
				}
			if (soap_flag_maxFetch1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "maxFetch", &(a->ns1__openPurchaseCursorResponse::maxFetch), "xsd:int"))
				{	soap_flag_maxFetch1--;
					continue;
				}
			if (soap_flag_count1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "count", &(a->ns1__openPurchaseCursorResponse::count), "xsd:int"))
				{	soap_flag_count1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__openPurchaseCursorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__openPurchaseCursorResponse, 0, sizeof(ns1__openPurchaseCursorResponse), 0, soap_copy_ns1__openPurchaseCursorResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0 || soap_flag_minFetch1 > 0 || soap_flag_maxFetch1 > 0 || soap_flag_count1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__openPurchaseCursorResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__openPurchaseCursorResponse);
	if (this->soap_out(soap, tag?tag:"ns1:openPurchaseCursorResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__openPurchaseCursorResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__openPurchaseCursorResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__openPurchaseCursorResponse * SOAP_FMAC4 soap_get_ns1__openPurchaseCursorResponse(struct soap *soap, ns1__openPurchaseCursorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__openPurchaseCursorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__openPurchaseCursorResponse * SOAP_FMAC2 soap_instantiate_ns1__openPurchaseCursorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__openPurchaseCursorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__openPurchaseCursorResponse, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__openPurchaseCursorResponse);
		if (size)
			*size = sizeof(ns1__openPurchaseCursorResponse);
		((ns1__openPurchaseCursorResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__openPurchaseCursorResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__openPurchaseCursorResponse);
		for (int i = 0; i < n; i++)
			((ns1__openPurchaseCursorResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__openPurchaseCursorResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__openPurchaseCursorResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__openPurchaseCursorResponse %p -> %p\n", q, p));
	*(ns1__openPurchaseCursorResponse*)p = *(ns1__openPurchaseCursorResponse*)q;
}

void ns1__uploadPurchaseResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__uploadPurchaseResponse::result = NULL;
	/* transient soap skipped */
}

void ns1__uploadPurchaseResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__result(soap, &this->ns1__uploadPurchaseResponse::result);
	/* transient soap skipped */
}

int ns1__uploadPurchaseResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__uploadPurchaseResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__uploadPurchaseResponse(struct soap *soap, const char *tag, int id, const ns1__uploadPurchaseResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__uploadPurchaseResponse), type))
		return soap->error;
	if (a->ns1__uploadPurchaseResponse::result)
	{	if (soap_out_PointerTons1__result(soap, "result", -1, &a->ns1__uploadPurchaseResponse::result, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "result"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__uploadPurchaseResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__uploadPurchaseResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__uploadPurchaseResponse * SOAP_FMAC4 soap_in_ns1__uploadPurchaseResponse(struct soap *soap, const char *tag, ns1__uploadPurchaseResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__uploadPurchaseResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__uploadPurchaseResponse, sizeof(ns1__uploadPurchaseResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__uploadPurchaseResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__uploadPurchaseResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__result(soap, "result", &(a->ns1__uploadPurchaseResponse::result), "ns1:result"))
				{	soap_flag_result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__uploadPurchaseResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__uploadPurchaseResponse, 0, sizeof(ns1__uploadPurchaseResponse), 0, soap_copy_ns1__uploadPurchaseResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__uploadPurchaseResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__uploadPurchaseResponse);
	if (this->soap_out(soap, tag?tag:"ns1:uploadPurchaseResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__uploadPurchaseResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__uploadPurchaseResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__uploadPurchaseResponse * SOAP_FMAC4 soap_get_ns1__uploadPurchaseResponse(struct soap *soap, ns1__uploadPurchaseResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__uploadPurchaseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__uploadPurchaseResponse * SOAP_FMAC2 soap_instantiate_ns1__uploadPurchaseResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__uploadPurchaseResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__uploadPurchaseResponse, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__uploadPurchaseResponse);
		if (size)
			*size = sizeof(ns1__uploadPurchaseResponse);
		((ns1__uploadPurchaseResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__uploadPurchaseResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__uploadPurchaseResponse);
		for (int i = 0; i < n; i++)
			((ns1__uploadPurchaseResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__uploadPurchaseResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__uploadPurchaseResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__uploadPurchaseResponse %p -> %p\n", q, p));
	*(ns1__uploadPurchaseResponse*)p = *(ns1__uploadPurchaseResponse*)q;
}

void ns1__uploadPurchaseRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__uploadPurchaseRequest::session = NULL;
	this->ns1__uploadPurchaseRequest::purchase = NULL;
	/* transient soap skipped */
}

void ns1__uploadPurchaseRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__sessionRequest(soap, &this->ns1__uploadPurchaseRequest::session);
	soap_serialize_PointerTons1__purchase(soap, &this->ns1__uploadPurchaseRequest::purchase);
	/* transient soap skipped */
}

int ns1__uploadPurchaseRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__uploadPurchaseRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__uploadPurchaseRequest(struct soap *soap, const char *tag, int id, const ns1__uploadPurchaseRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__uploadPurchaseRequest), type))
		return soap->error;
	if (a->ns1__uploadPurchaseRequest::session)
	{	if (soap_out_PointerTons1__sessionRequest(soap, "session", -1, &a->ns1__uploadPurchaseRequest::session, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "session"))
		return soap->error;
	if (a->ns1__uploadPurchaseRequest::purchase)
	{	if (soap_out_PointerTons1__purchase(soap, "purchase", -1, &a->ns1__uploadPurchaseRequest::purchase, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "purchase"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__uploadPurchaseRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__uploadPurchaseRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__uploadPurchaseRequest * SOAP_FMAC4 soap_in_ns1__uploadPurchaseRequest(struct soap *soap, const char *tag, ns1__uploadPurchaseRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__uploadPurchaseRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__uploadPurchaseRequest, sizeof(ns1__uploadPurchaseRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__uploadPurchaseRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__uploadPurchaseRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_session1 = 1;
	size_t soap_flag_purchase1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sessionRequest(soap, "session", &(a->ns1__uploadPurchaseRequest::session), "ns1:sessionRequest"))
				{	soap_flag_session1--;
					continue;
				}
			if (soap_flag_purchase1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__purchase(soap, "purchase", &(a->ns1__uploadPurchaseRequest::purchase), "ns1:purchase"))
				{	soap_flag_purchase1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__uploadPurchaseRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__uploadPurchaseRequest, 0, sizeof(ns1__uploadPurchaseRequest), 0, soap_copy_ns1__uploadPurchaseRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_session1 > 0 || soap_flag_purchase1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__uploadPurchaseRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__uploadPurchaseRequest);
	if (this->soap_out(soap, tag?tag:"ns1:uploadPurchaseRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__uploadPurchaseRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__uploadPurchaseRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__uploadPurchaseRequest * SOAP_FMAC4 soap_get_ns1__uploadPurchaseRequest(struct soap *soap, ns1__uploadPurchaseRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__uploadPurchaseRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__uploadPurchaseRequest * SOAP_FMAC2 soap_instantiate_ns1__uploadPurchaseRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__uploadPurchaseRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__uploadPurchaseRequest, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__uploadPurchaseRequest);
		if (size)
			*size = sizeof(ns1__uploadPurchaseRequest);
		((ns1__uploadPurchaseRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__uploadPurchaseRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__uploadPurchaseRequest);
		for (int i = 0; i < n; i++)
			((ns1__uploadPurchaseRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__uploadPurchaseRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__uploadPurchaseRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__uploadPurchaseRequest %p -> %p\n", q, p));
	*(ns1__uploadPurchaseRequest*)p = *(ns1__uploadPurchaseRequest*)q;
}

void ns1__fetchCompanyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__fetchCompanyResponse::company = NULL;
	this->ns1__fetchCompanyResponse::result = NULL;
	/* transient soap skipped */
}

void ns1__fetchCompanyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__company(soap, &this->ns1__fetchCompanyResponse::company);
	soap_serialize_PointerTons1__result(soap, &this->ns1__fetchCompanyResponse::result);
	/* transient soap skipped */
}

int ns1__fetchCompanyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__fetchCompanyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__fetchCompanyResponse(struct soap *soap, const char *tag, int id, const ns1__fetchCompanyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__fetchCompanyResponse), type))
		return soap->error;
	if (a->ns1__fetchCompanyResponse::company)
	{	if (soap_out_PointerTons1__company(soap, "company", -1, &a->ns1__fetchCompanyResponse::company, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "company"))
		return soap->error;
	if (a->ns1__fetchCompanyResponse::result)
	{	if (soap_out_PointerTons1__result(soap, "result", -1, &a->ns1__fetchCompanyResponse::result, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "result"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__fetchCompanyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__fetchCompanyResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__fetchCompanyResponse * SOAP_FMAC4 soap_in_ns1__fetchCompanyResponse(struct soap *soap, const char *tag, ns1__fetchCompanyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__fetchCompanyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__fetchCompanyResponse, sizeof(ns1__fetchCompanyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__fetchCompanyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__fetchCompanyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_company1 = 1;
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_company1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__company(soap, "company", &(a->ns1__fetchCompanyResponse::company), "ns1:company"))
				{	soap_flag_company1--;
					continue;
				}
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__result(soap, "result", &(a->ns1__fetchCompanyResponse::result), "ns1:result"))
				{	soap_flag_result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__fetchCompanyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__fetchCompanyResponse, 0, sizeof(ns1__fetchCompanyResponse), 0, soap_copy_ns1__fetchCompanyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_company1 > 0 || soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__fetchCompanyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__fetchCompanyResponse);
	if (this->soap_out(soap, tag?tag:"ns1:fetchCompanyResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__fetchCompanyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__fetchCompanyResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__fetchCompanyResponse * SOAP_FMAC4 soap_get_ns1__fetchCompanyResponse(struct soap *soap, ns1__fetchCompanyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__fetchCompanyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__fetchCompanyResponse * SOAP_FMAC2 soap_instantiate_ns1__fetchCompanyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__fetchCompanyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__fetchCompanyResponse, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__fetchCompanyResponse);
		if (size)
			*size = sizeof(ns1__fetchCompanyResponse);
		((ns1__fetchCompanyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__fetchCompanyResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__fetchCompanyResponse);
		for (int i = 0; i < n; i++)
			((ns1__fetchCompanyResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__fetchCompanyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__fetchCompanyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__fetchCompanyResponse %p -> %p\n", q, p));
	*(ns1__fetchCompanyResponse*)p = *(ns1__fetchCompanyResponse*)q;
}

void ns1__updateCompanyRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__updateCompanyRequest::session = NULL;
	this->ns1__updateCompanyRequest::company = NULL;
	/* transient soap skipped */
}

void ns1__updateCompanyRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__sessionRequest(soap, &this->ns1__updateCompanyRequest::session);
	soap_serialize_PointerTons1__company(soap, &this->ns1__updateCompanyRequest::company);
	/* transient soap skipped */
}

int ns1__updateCompanyRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__updateCompanyRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__updateCompanyRequest(struct soap *soap, const char *tag, int id, const ns1__updateCompanyRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__updateCompanyRequest), type))
		return soap->error;
	if (a->ns1__updateCompanyRequest::session)
	{	if (soap_out_PointerTons1__sessionRequest(soap, "session", -1, &a->ns1__updateCompanyRequest::session, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "session"))
		return soap->error;
	if (a->ns1__updateCompanyRequest::company)
	{	if (soap_out_PointerTons1__company(soap, "company", -1, &a->ns1__updateCompanyRequest::company, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "company"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__updateCompanyRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__updateCompanyRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__updateCompanyRequest * SOAP_FMAC4 soap_in_ns1__updateCompanyRequest(struct soap *soap, const char *tag, ns1__updateCompanyRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__updateCompanyRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__updateCompanyRequest, sizeof(ns1__updateCompanyRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__updateCompanyRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__updateCompanyRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_session1 = 1;
	size_t soap_flag_company1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sessionRequest(soap, "session", &(a->ns1__updateCompanyRequest::session), "ns1:sessionRequest"))
				{	soap_flag_session1--;
					continue;
				}
			if (soap_flag_company1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__company(soap, "company", &(a->ns1__updateCompanyRequest::company), "ns1:company"))
				{	soap_flag_company1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__updateCompanyRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__updateCompanyRequest, 0, sizeof(ns1__updateCompanyRequest), 0, soap_copy_ns1__updateCompanyRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_session1 > 0 || soap_flag_company1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__updateCompanyRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__updateCompanyRequest);
	if (this->soap_out(soap, tag?tag:"ns1:updateCompanyRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__updateCompanyRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__updateCompanyRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__updateCompanyRequest * SOAP_FMAC4 soap_get_ns1__updateCompanyRequest(struct soap *soap, ns1__updateCompanyRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__updateCompanyRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__updateCompanyRequest * SOAP_FMAC2 soap_instantiate_ns1__updateCompanyRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__updateCompanyRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__updateCompanyRequest, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__updateCompanyRequest);
		if (size)
			*size = sizeof(ns1__updateCompanyRequest);
		((ns1__updateCompanyRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__updateCompanyRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__updateCompanyRequest);
		for (int i = 0; i < n; i++)
			((ns1__updateCompanyRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__updateCompanyRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__updateCompanyRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__updateCompanyRequest %p -> %p\n", q, p));
	*(ns1__updateCompanyRequest*)p = *(ns1__updateCompanyRequest*)q;
}

void ns1__updateCompanyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__updateCompanyResponse::result = NULL;
	/* transient soap skipped */
}

void ns1__updateCompanyResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__result(soap, &this->ns1__updateCompanyResponse::result);
	/* transient soap skipped */
}

int ns1__updateCompanyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__updateCompanyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__updateCompanyResponse(struct soap *soap, const char *tag, int id, const ns1__updateCompanyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__updateCompanyResponse), type))
		return soap->error;
	if (a->ns1__updateCompanyResponse::result)
	{	if (soap_out_PointerTons1__result(soap, "result", -1, &a->ns1__updateCompanyResponse::result, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "result"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__updateCompanyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__updateCompanyResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__updateCompanyResponse * SOAP_FMAC4 soap_in_ns1__updateCompanyResponse(struct soap *soap, const char *tag, ns1__updateCompanyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__updateCompanyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__updateCompanyResponse, sizeof(ns1__updateCompanyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__updateCompanyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__updateCompanyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__result(soap, "result", &(a->ns1__updateCompanyResponse::result), "ns1:result"))
				{	soap_flag_result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__updateCompanyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__updateCompanyResponse, 0, sizeof(ns1__updateCompanyResponse), 0, soap_copy_ns1__updateCompanyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__updateCompanyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__updateCompanyResponse);
	if (this->soap_out(soap, tag?tag:"ns1:updateCompanyResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__updateCompanyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__updateCompanyResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__updateCompanyResponse * SOAP_FMAC4 soap_get_ns1__updateCompanyResponse(struct soap *soap, ns1__updateCompanyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__updateCompanyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__updateCompanyResponse * SOAP_FMAC2 soap_instantiate_ns1__updateCompanyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__updateCompanyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__updateCompanyResponse, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__updateCompanyResponse);
		if (size)
			*size = sizeof(ns1__updateCompanyResponse);
		((ns1__updateCompanyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__updateCompanyResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__updateCompanyResponse);
		for (int i = 0; i < n; i++)
			((ns1__updateCompanyResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__updateCompanyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__updateCompanyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__updateCompanyResponse %p -> %p\n", q, p));
	*(ns1__updateCompanyResponse*)p = *(ns1__updateCompanyResponse*)q;
}

void ns1__fetchStocksResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTons1__stock(soap, &this->ns1__fetchStocksResponse::stocks);
	this->ns1__fetchStocksResponse::result = NULL;
	/* transient soap skipped */
}

void ns1__fetchStocksResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTons1__stock(soap, &this->ns1__fetchStocksResponse::stocks);
	soap_serialize_PointerTons1__result(soap, &this->ns1__fetchStocksResponse::result);
	/* transient soap skipped */
}

int ns1__fetchStocksResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__fetchStocksResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__fetchStocksResponse(struct soap *soap, const char *tag, int id, const ns1__fetchStocksResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__fetchStocksResponse), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__stock(soap, "stocks", -1, &(a->ns1__fetchStocksResponse::stocks), ""))
		return soap->error;
	if (a->ns1__fetchStocksResponse::result)
	{	if (soap_out_PointerTons1__result(soap, "result", -1, &a->ns1__fetchStocksResponse::result, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "result"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__fetchStocksResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__fetchStocksResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__fetchStocksResponse * SOAP_FMAC4 soap_in_ns1__fetchStocksResponse(struct soap *soap, const char *tag, ns1__fetchStocksResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__fetchStocksResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__fetchStocksResponse, sizeof(ns1__fetchStocksResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__fetchStocksResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__fetchStocksResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__stock(soap, "stocks", &(a->ns1__fetchStocksResponse::stocks), "ns1:stock"))
					continue;
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__result(soap, "result", &(a->ns1__fetchStocksResponse::result), "ns1:result"))
				{	soap_flag_result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__fetchStocksResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__fetchStocksResponse, 0, sizeof(ns1__fetchStocksResponse), 0, soap_copy_ns1__fetchStocksResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__fetchStocksResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__fetchStocksResponse);
	if (this->soap_out(soap, tag?tag:"ns1:fetchStocksResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__fetchStocksResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__fetchStocksResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__fetchStocksResponse * SOAP_FMAC4 soap_get_ns1__fetchStocksResponse(struct soap *soap, ns1__fetchStocksResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__fetchStocksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__fetchStocksResponse * SOAP_FMAC2 soap_instantiate_ns1__fetchStocksResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__fetchStocksResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__fetchStocksResponse, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__fetchStocksResponse);
		if (size)
			*size = sizeof(ns1__fetchStocksResponse);
		((ns1__fetchStocksResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__fetchStocksResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__fetchStocksResponse);
		for (int i = 0; i < n; i++)
			((ns1__fetchStocksResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__fetchStocksResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__fetchStocksResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__fetchStocksResponse %p -> %p\n", q, p));
	*(ns1__fetchStocksResponse*)p = *(ns1__fetchStocksResponse*)q;
}

void ns1__closeStockCursorResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__closeStockCursorResponse::result = NULL;
	/* transient soap skipped */
}

void ns1__closeStockCursorResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__result(soap, &this->ns1__closeStockCursorResponse::result);
	/* transient soap skipped */
}

int ns1__closeStockCursorResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__closeStockCursorResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__closeStockCursorResponse(struct soap *soap, const char *tag, int id, const ns1__closeStockCursorResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__closeStockCursorResponse), type))
		return soap->error;
	if (a->ns1__closeStockCursorResponse::result)
	{	if (soap_out_PointerTons1__result(soap, "result", -1, &a->ns1__closeStockCursorResponse::result, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "result"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__closeStockCursorResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__closeStockCursorResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__closeStockCursorResponse * SOAP_FMAC4 soap_in_ns1__closeStockCursorResponse(struct soap *soap, const char *tag, ns1__closeStockCursorResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__closeStockCursorResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__closeStockCursorResponse, sizeof(ns1__closeStockCursorResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__closeStockCursorResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__closeStockCursorResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__result(soap, "result", &(a->ns1__closeStockCursorResponse::result), "ns1:result"))
				{	soap_flag_result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__closeStockCursorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__closeStockCursorResponse, 0, sizeof(ns1__closeStockCursorResponse), 0, soap_copy_ns1__closeStockCursorResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__closeStockCursorResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__closeStockCursorResponse);
	if (this->soap_out(soap, tag?tag:"ns1:closeStockCursorResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__closeStockCursorResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__closeStockCursorResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__closeStockCursorResponse * SOAP_FMAC4 soap_get_ns1__closeStockCursorResponse(struct soap *soap, ns1__closeStockCursorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__closeStockCursorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__closeStockCursorResponse * SOAP_FMAC2 soap_instantiate_ns1__closeStockCursorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__closeStockCursorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__closeStockCursorResponse, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__closeStockCursorResponse);
		if (size)
			*size = sizeof(ns1__closeStockCursorResponse);
		((ns1__closeStockCursorResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__closeStockCursorResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__closeStockCursorResponse);
		for (int i = 0; i < n; i++)
			((ns1__closeStockCursorResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__closeStockCursorResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__closeStockCursorResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__closeStockCursorResponse %p -> %p\n", q, p));
	*(ns1__closeStockCursorResponse*)p = *(ns1__closeStockCursorResponse*)q;
}

void ns1__openStockCursorResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__openStockCursorResponse::result = NULL;
	soap_default_int(soap, &this->ns1__openStockCursorResponse::minFetch);
	soap_default_int(soap, &this->ns1__openStockCursorResponse::maxFetch);
	soap_default_int(soap, &this->ns1__openStockCursorResponse::count);
	/* transient soap skipped */
}

void ns1__openStockCursorResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__result(soap, &this->ns1__openStockCursorResponse::result);
	/* transient soap skipped */
}

int ns1__openStockCursorResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__openStockCursorResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__openStockCursorResponse(struct soap *soap, const char *tag, int id, const ns1__openStockCursorResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__openStockCursorResponse), type))
		return soap->error;
	if (a->ns1__openStockCursorResponse::result)
	{	if (soap_out_PointerTons1__result(soap, "result", -1, &a->ns1__openStockCursorResponse::result, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "result"))
		return soap->error;
	if (soap_out_int(soap, "minFetch", -1, &(a->ns1__openStockCursorResponse::minFetch), ""))
		return soap->error;
	if (soap_out_int(soap, "maxFetch", -1, &(a->ns1__openStockCursorResponse::maxFetch), ""))
		return soap->error;
	if (soap_out_int(soap, "count", -1, &(a->ns1__openStockCursorResponse::count), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__openStockCursorResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__openStockCursorResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__openStockCursorResponse * SOAP_FMAC4 soap_in_ns1__openStockCursorResponse(struct soap *soap, const char *tag, ns1__openStockCursorResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__openStockCursorResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__openStockCursorResponse, sizeof(ns1__openStockCursorResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__openStockCursorResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__openStockCursorResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	size_t soap_flag_minFetch1 = 1;
	size_t soap_flag_maxFetch1 = 1;
	size_t soap_flag_count1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__result(soap, "result", &(a->ns1__openStockCursorResponse::result), "ns1:result"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag_minFetch1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "minFetch", &(a->ns1__openStockCursorResponse::minFetch), "xsd:int"))
				{	soap_flag_minFetch1--;
					continue;
				}
			if (soap_flag_maxFetch1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "maxFetch", &(a->ns1__openStockCursorResponse::maxFetch), "xsd:int"))
				{	soap_flag_maxFetch1--;
					continue;
				}
			if (soap_flag_count1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "count", &(a->ns1__openStockCursorResponse::count), "xsd:int"))
				{	soap_flag_count1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__openStockCursorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__openStockCursorResponse, 0, sizeof(ns1__openStockCursorResponse), 0, soap_copy_ns1__openStockCursorResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0 || soap_flag_minFetch1 > 0 || soap_flag_maxFetch1 > 0 || soap_flag_count1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__openStockCursorResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__openStockCursorResponse);
	if (this->soap_out(soap, tag?tag:"ns1:openStockCursorResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__openStockCursorResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__openStockCursorResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__openStockCursorResponse * SOAP_FMAC4 soap_get_ns1__openStockCursorResponse(struct soap *soap, ns1__openStockCursorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__openStockCursorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__openStockCursorResponse * SOAP_FMAC2 soap_instantiate_ns1__openStockCursorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__openStockCursorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__openStockCursorResponse, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__openStockCursorResponse);
		if (size)
			*size = sizeof(ns1__openStockCursorResponse);
		((ns1__openStockCursorResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__openStockCursorResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__openStockCursorResponse);
		for (int i = 0; i < n; i++)
			((ns1__openStockCursorResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__openStockCursorResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__openStockCursorResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__openStockCursorResponse %p -> %p\n", q, p));
	*(ns1__openStockCursorResponse*)p = *(ns1__openStockCursorResponse*)q;
}

void ns1__openHentCursorResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__openHentCursorResponse::result = NULL;
	soap_default_int(soap, &this->ns1__openHentCursorResponse::minFetch);
	soap_default_int(soap, &this->ns1__openHentCursorResponse::maxFetch);
	soap_default_int(soap, &this->ns1__openHentCursorResponse::count);
	/* transient soap skipped */
}

void ns1__openHentCursorResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__result(soap, &this->ns1__openHentCursorResponse::result);
	/* transient soap skipped */
}

int ns1__openHentCursorResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__openHentCursorResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__openHentCursorResponse(struct soap *soap, const char *tag, int id, const ns1__openHentCursorResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__openHentCursorResponse), type))
		return soap->error;
	if (a->ns1__openHentCursorResponse::result)
	{	if (soap_out_PointerTons1__result(soap, "result", -1, &a->ns1__openHentCursorResponse::result, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "result"))
		return soap->error;
	if (soap_out_int(soap, "minFetch", -1, &(a->ns1__openHentCursorResponse::minFetch), ""))
		return soap->error;
	if (soap_out_int(soap, "maxFetch", -1, &(a->ns1__openHentCursorResponse::maxFetch), ""))
		return soap->error;
	if (soap_out_int(soap, "count", -1, &(a->ns1__openHentCursorResponse::count), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__openHentCursorResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__openHentCursorResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__openHentCursorResponse * SOAP_FMAC4 soap_in_ns1__openHentCursorResponse(struct soap *soap, const char *tag, ns1__openHentCursorResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__openHentCursorResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__openHentCursorResponse, sizeof(ns1__openHentCursorResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__openHentCursorResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__openHentCursorResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	size_t soap_flag_minFetch1 = 1;
	size_t soap_flag_maxFetch1 = 1;
	size_t soap_flag_count1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__result(soap, "result", &(a->ns1__openHentCursorResponse::result), "ns1:result"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap_flag_minFetch1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "minFetch", &(a->ns1__openHentCursorResponse::minFetch), "xsd:int"))
				{	soap_flag_minFetch1--;
					continue;
				}
			if (soap_flag_maxFetch1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "maxFetch", &(a->ns1__openHentCursorResponse::maxFetch), "xsd:int"))
				{	soap_flag_maxFetch1--;
					continue;
				}
			if (soap_flag_count1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "count", &(a->ns1__openHentCursorResponse::count), "xsd:int"))
				{	soap_flag_count1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__openHentCursorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__openHentCursorResponse, 0, sizeof(ns1__openHentCursorResponse), 0, soap_copy_ns1__openHentCursorResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0 || soap_flag_minFetch1 > 0 || soap_flag_maxFetch1 > 0 || soap_flag_count1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__openHentCursorResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__openHentCursorResponse);
	if (this->soap_out(soap, tag?tag:"ns1:openHentCursorResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__openHentCursorResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__openHentCursorResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__openHentCursorResponse * SOAP_FMAC4 soap_get_ns1__openHentCursorResponse(struct soap *soap, ns1__openHentCursorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__openHentCursorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__openHentCursorResponse * SOAP_FMAC2 soap_instantiate_ns1__openHentCursorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__openHentCursorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__openHentCursorResponse, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__openHentCursorResponse);
		if (size)
			*size = sizeof(ns1__openHentCursorResponse);
		((ns1__openHentCursorResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__openHentCursorResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__openHentCursorResponse);
		for (int i = 0; i < n; i++)
			((ns1__openHentCursorResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__openHentCursorResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__openHentCursorResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__openHentCursorResponse %p -> %p\n", q, p));
	*(ns1__openHentCursorResponse*)p = *(ns1__openHentCursorResponse*)q;
}

void ns1__closeHentCursorResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__closeHentCursorResponse::result = NULL;
	/* transient soap skipped */
}

void ns1__closeHentCursorResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__result(soap, &this->ns1__closeHentCursorResponse::result);
	/* transient soap skipped */
}

int ns1__closeHentCursorResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__closeHentCursorResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__closeHentCursorResponse(struct soap *soap, const char *tag, int id, const ns1__closeHentCursorResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__closeHentCursorResponse), type))
		return soap->error;
	if (a->ns1__closeHentCursorResponse::result)
	{	if (soap_out_PointerTons1__result(soap, "result", -1, &a->ns1__closeHentCursorResponse::result, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "result"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__closeHentCursorResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__closeHentCursorResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__closeHentCursorResponse * SOAP_FMAC4 soap_in_ns1__closeHentCursorResponse(struct soap *soap, const char *tag, ns1__closeHentCursorResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__closeHentCursorResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__closeHentCursorResponse, sizeof(ns1__closeHentCursorResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__closeHentCursorResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__closeHentCursorResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__result(soap, "result", &(a->ns1__closeHentCursorResponse::result), "ns1:result"))
				{	soap_flag_result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__closeHentCursorResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__closeHentCursorResponse, 0, sizeof(ns1__closeHentCursorResponse), 0, soap_copy_ns1__closeHentCursorResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__closeHentCursorResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__closeHentCursorResponse);
	if (this->soap_out(soap, tag?tag:"ns1:closeHentCursorResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__closeHentCursorResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__closeHentCursorResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__closeHentCursorResponse * SOAP_FMAC4 soap_get_ns1__closeHentCursorResponse(struct soap *soap, ns1__closeHentCursorResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__closeHentCursorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__closeHentCursorResponse * SOAP_FMAC2 soap_instantiate_ns1__closeHentCursorResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__closeHentCursorResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__closeHentCursorResponse, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__closeHentCursorResponse);
		if (size)
			*size = sizeof(ns1__closeHentCursorResponse);
		((ns1__closeHentCursorResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__closeHentCursorResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__closeHentCursorResponse);
		for (int i = 0; i < n; i++)
			((ns1__closeHentCursorResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__closeHentCursorResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__closeHentCursorResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__closeHentCursorResponse %p -> %p\n", q, p));
	*(ns1__closeHentCursorResponse*)p = *(ns1__closeHentCursorResponse*)q;
}

void ns1__openSyncTransactionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__openSyncTransactionResponse::result = NULL;
	/* transient soap skipped */
}

void ns1__openSyncTransactionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__result(soap, &this->ns1__openSyncTransactionResponse::result);
	/* transient soap skipped */
}

int ns1__openSyncTransactionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__openSyncTransactionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__openSyncTransactionResponse(struct soap *soap, const char *tag, int id, const ns1__openSyncTransactionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__openSyncTransactionResponse), type))
		return soap->error;
	if (a->ns1__openSyncTransactionResponse::result)
	{	if (soap_out_PointerTons1__result(soap, "result", -1, &a->ns1__openSyncTransactionResponse::result, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "result"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__openSyncTransactionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__openSyncTransactionResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__openSyncTransactionResponse * SOAP_FMAC4 soap_in_ns1__openSyncTransactionResponse(struct soap *soap, const char *tag, ns1__openSyncTransactionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__openSyncTransactionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__openSyncTransactionResponse, sizeof(ns1__openSyncTransactionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__openSyncTransactionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__openSyncTransactionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__result(soap, "result", &(a->ns1__openSyncTransactionResponse::result), "ns1:result"))
				{	soap_flag_result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__openSyncTransactionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__openSyncTransactionResponse, 0, sizeof(ns1__openSyncTransactionResponse), 0, soap_copy_ns1__openSyncTransactionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__openSyncTransactionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__openSyncTransactionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:openSyncTransactionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__openSyncTransactionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__openSyncTransactionResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__openSyncTransactionResponse * SOAP_FMAC4 soap_get_ns1__openSyncTransactionResponse(struct soap *soap, ns1__openSyncTransactionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__openSyncTransactionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__openSyncTransactionResponse * SOAP_FMAC2 soap_instantiate_ns1__openSyncTransactionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__openSyncTransactionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__openSyncTransactionResponse, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__openSyncTransactionResponse);
		if (size)
			*size = sizeof(ns1__openSyncTransactionResponse);
		((ns1__openSyncTransactionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__openSyncTransactionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__openSyncTransactionResponse);
		for (int i = 0; i < n; i++)
			((ns1__openSyncTransactionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__openSyncTransactionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__openSyncTransactionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__openSyncTransactionResponse %p -> %p\n", q, p));
	*(ns1__openSyncTransactionResponse*)p = *(ns1__openSyncTransactionResponse*)q;
}

void ns1__closeSessionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__closeSessionResponse::result = NULL;
	/* transient soap skipped */
}

void ns1__closeSessionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__result(soap, &this->ns1__closeSessionResponse::result);
	/* transient soap skipped */
}

int ns1__closeSessionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__closeSessionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__closeSessionResponse(struct soap *soap, const char *tag, int id, const ns1__closeSessionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__closeSessionResponse), type))
		return soap->error;
	if (a->ns1__closeSessionResponse::result)
	{	if (soap_out_PointerTons1__result(soap, "result", -1, &a->ns1__closeSessionResponse::result, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "result"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__closeSessionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__closeSessionResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__closeSessionResponse * SOAP_FMAC4 soap_in_ns1__closeSessionResponse(struct soap *soap, const char *tag, ns1__closeSessionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__closeSessionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__closeSessionResponse, sizeof(ns1__closeSessionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__closeSessionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__closeSessionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__result(soap, "result", &(a->ns1__closeSessionResponse::result), "ns1:result"))
				{	soap_flag_result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__closeSessionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__closeSessionResponse, 0, sizeof(ns1__closeSessionResponse), 0, soap_copy_ns1__closeSessionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__closeSessionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__closeSessionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:closeSessionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__closeSessionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__closeSessionResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__closeSessionResponse * SOAP_FMAC4 soap_get_ns1__closeSessionResponse(struct soap *soap, ns1__closeSessionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__closeSessionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__closeSessionResponse * SOAP_FMAC2 soap_instantiate_ns1__closeSessionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__closeSessionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__closeSessionResponse, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__closeSessionResponse);
		if (size)
			*size = sizeof(ns1__closeSessionResponse);
		((ns1__closeSessionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__closeSessionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__closeSessionResponse);
		for (int i = 0; i < n; i++)
			((ns1__closeSessionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__closeSessionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__closeSessionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__closeSessionResponse %p -> %p\n", q, p));
	*(ns1__closeSessionResponse*)p = *(ns1__closeSessionResponse*)q;
}

void ns1__fetchHentsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__fetchHentsResponse::result = NULL;
	soap_default_std__vectorTemplateOfPointerTons1__hent(soap, &this->ns1__fetchHentsResponse::hents);
	/* transient soap skipped */
}

void ns1__fetchHentsResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__result(soap, &this->ns1__fetchHentsResponse::result);
	soap_serialize_std__vectorTemplateOfPointerTons1__hent(soap, &this->ns1__fetchHentsResponse::hents);
	/* transient soap skipped */
}

int ns1__fetchHentsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__fetchHentsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__fetchHentsResponse(struct soap *soap, const char *tag, int id, const ns1__fetchHentsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__fetchHentsResponse), type))
		return soap->error;
	if (a->ns1__fetchHentsResponse::result)
	{	if (soap_out_PointerTons1__result(soap, "result", -1, &a->ns1__fetchHentsResponse::result, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "result"))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__hent(soap, "hents", -1, &(a->ns1__fetchHentsResponse::hents), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__fetchHentsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__fetchHentsResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__fetchHentsResponse * SOAP_FMAC4 soap_in_ns1__fetchHentsResponse(struct soap *soap, const char *tag, ns1__fetchHentsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__fetchHentsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__fetchHentsResponse, sizeof(ns1__fetchHentsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__fetchHentsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__fetchHentsResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__result(soap, "result", &(a->ns1__fetchHentsResponse::result), "ns1:result"))
				{	soap_flag_result1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__hent(soap, "hents", &(a->ns1__fetchHentsResponse::hents), "ns1:hent"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__fetchHentsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__fetchHentsResponse, 0, sizeof(ns1__fetchHentsResponse), 0, soap_copy_ns1__fetchHentsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__fetchHentsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__fetchHentsResponse);
	if (this->soap_out(soap, tag?tag:"ns1:fetchHentsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__fetchHentsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__fetchHentsResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__fetchHentsResponse * SOAP_FMAC4 soap_get_ns1__fetchHentsResponse(struct soap *soap, ns1__fetchHentsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__fetchHentsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__fetchHentsResponse * SOAP_FMAC2 soap_instantiate_ns1__fetchHentsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__fetchHentsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__fetchHentsResponse, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__fetchHentsResponse);
		if (size)
			*size = sizeof(ns1__fetchHentsResponse);
		((ns1__fetchHentsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__fetchHentsResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__fetchHentsResponse);
		for (int i = 0; i < n; i++)
			((ns1__fetchHentsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__fetchHentsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__fetchHentsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__fetchHentsResponse %p -> %p\n", q, p));
	*(ns1__fetchHentsResponse*)p = *(ns1__fetchHentsResponse*)q;
}

void ns1__updateStockResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__updateStockResponse::result = NULL;
	/* transient soap skipped */
}

void ns1__updateStockResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__result(soap, &this->ns1__updateStockResponse::result);
	/* transient soap skipped */
}

int ns1__updateStockResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__updateStockResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__updateStockResponse(struct soap *soap, const char *tag, int id, const ns1__updateStockResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__updateStockResponse), type))
		return soap->error;
	if (a->ns1__updateStockResponse::result)
	{	if (soap_out_PointerTons1__result(soap, "result", -1, &a->ns1__updateStockResponse::result, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "result"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__updateStockResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__updateStockResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__updateStockResponse * SOAP_FMAC4 soap_in_ns1__updateStockResponse(struct soap *soap, const char *tag, ns1__updateStockResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__updateStockResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__updateStockResponse, sizeof(ns1__updateStockResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__updateStockResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__updateStockResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__result(soap, "result", &(a->ns1__updateStockResponse::result), "ns1:result"))
				{	soap_flag_result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__updateStockResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__updateStockResponse, 0, sizeof(ns1__updateStockResponse), 0, soap_copy_ns1__updateStockResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__updateStockResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__updateStockResponse);
	if (this->soap_out(soap, tag?tag:"ns1:updateStockResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__updateStockResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__updateStockResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__updateStockResponse * SOAP_FMAC4 soap_get_ns1__updateStockResponse(struct soap *soap, ns1__updateStockResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__updateStockResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__updateStockResponse * SOAP_FMAC2 soap_instantiate_ns1__updateStockResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__updateStockResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__updateStockResponse, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__updateStockResponse);
		if (size)
			*size = sizeof(ns1__updateStockResponse);
		((ns1__updateStockResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__updateStockResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__updateStockResponse);
		for (int i = 0; i < n; i++)
			((ns1__updateStockResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__updateStockResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__updateStockResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__updateStockResponse %p -> %p\n", q, p));
	*(ns1__updateStockResponse*)p = *(ns1__updateStockResponse*)q;
}

void ns1__updateStockRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__updateStockRequest::session = NULL;
	this->ns1__updateStockRequest::stock = NULL;
	/* transient soap skipped */
}

void ns1__updateStockRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__sessionRequest(soap, &this->ns1__updateStockRequest::session);
	soap_serialize_PointerTons1__stock(soap, &this->ns1__updateStockRequest::stock);
	/* transient soap skipped */
}

int ns1__updateStockRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__updateStockRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__updateStockRequest(struct soap *soap, const char *tag, int id, const ns1__updateStockRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__updateStockRequest), type))
		return soap->error;
	if (a->ns1__updateStockRequest::session)
	{	if (soap_out_PointerTons1__sessionRequest(soap, "session", -1, &a->ns1__updateStockRequest::session, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "session"))
		return soap->error;
	if (a->ns1__updateStockRequest::stock)
	{	if (soap_out_PointerTons1__stock(soap, "stock", -1, &a->ns1__updateStockRequest::stock, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "stock"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__updateStockRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__updateStockRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__updateStockRequest * SOAP_FMAC4 soap_in_ns1__updateStockRequest(struct soap *soap, const char *tag, ns1__updateStockRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__updateStockRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__updateStockRequest, sizeof(ns1__updateStockRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__updateStockRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__updateStockRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_session1 = 1;
	size_t soap_flag_stock1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sessionRequest(soap, "session", &(a->ns1__updateStockRequest::session), "ns1:sessionRequest"))
				{	soap_flag_session1--;
					continue;
				}
			if (soap_flag_stock1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__stock(soap, "stock", &(a->ns1__updateStockRequest::stock), "ns1:stock"))
				{	soap_flag_stock1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__updateStockRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__updateStockRequest, 0, sizeof(ns1__updateStockRequest), 0, soap_copy_ns1__updateStockRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_session1 > 0 || soap_flag_stock1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__updateStockRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__updateStockRequest);
	if (this->soap_out(soap, tag?tag:"ns1:updateStockRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__updateStockRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__updateStockRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__updateStockRequest * SOAP_FMAC4 soap_get_ns1__updateStockRequest(struct soap *soap, ns1__updateStockRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__updateStockRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__updateStockRequest * SOAP_FMAC2 soap_instantiate_ns1__updateStockRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__updateStockRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__updateStockRequest, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__updateStockRequest);
		if (size)
			*size = sizeof(ns1__updateStockRequest);
		((ns1__updateStockRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__updateStockRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__updateStockRequest);
		for (int i = 0; i < n; i++)
			((ns1__updateStockRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__updateStockRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__updateStockRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__updateStockRequest %p -> %p\n", q, p));
	*(ns1__updateStockRequest*)p = *(ns1__updateStockRequest*)q;
}

void ns1__updateHentResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__updateHentResponse::result = NULL;
	/* transient soap skipped */
}

void ns1__updateHentResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__result(soap, &this->ns1__updateHentResponse::result);
	/* transient soap skipped */
}

int ns1__updateHentResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__updateHentResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__updateHentResponse(struct soap *soap, const char *tag, int id, const ns1__updateHentResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__updateHentResponse), type))
		return soap->error;
	if (a->ns1__updateHentResponse::result)
	{	if (soap_out_PointerTons1__result(soap, "result", -1, &a->ns1__updateHentResponse::result, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "result"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__updateHentResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__updateHentResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__updateHentResponse * SOAP_FMAC4 soap_in_ns1__updateHentResponse(struct soap *soap, const char *tag, ns1__updateHentResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__updateHentResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__updateHentResponse, sizeof(ns1__updateHentResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__updateHentResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__updateHentResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__result(soap, "result", &(a->ns1__updateHentResponse::result), "ns1:result"))
				{	soap_flag_result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__updateHentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__updateHentResponse, 0, sizeof(ns1__updateHentResponse), 0, soap_copy_ns1__updateHentResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__updateHentResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__updateHentResponse);
	if (this->soap_out(soap, tag?tag:"ns1:updateHentResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__updateHentResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__updateHentResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__updateHentResponse * SOAP_FMAC4 soap_get_ns1__updateHentResponse(struct soap *soap, ns1__updateHentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__updateHentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__updateHentResponse * SOAP_FMAC2 soap_instantiate_ns1__updateHentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__updateHentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__updateHentResponse, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__updateHentResponse);
		if (size)
			*size = sizeof(ns1__updateHentResponse);
		((ns1__updateHentResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__updateHentResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__updateHentResponse);
		for (int i = 0; i < n; i++)
			((ns1__updateHentResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__updateHentResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__updateHentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__updateHentResponse %p -> %p\n", q, p));
	*(ns1__updateHentResponse*)p = *(ns1__updateHentResponse*)q;
}

void ns1__updateHentRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__updateHentRequest::session = NULL;
	this->ns1__updateHentRequest::hent = NULL;
	/* transient soap skipped */
}

void ns1__updateHentRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__sessionRequest(soap, &this->ns1__updateHentRequest::session);
	soap_serialize_PointerTons1__hent(soap, &this->ns1__updateHentRequest::hent);
	/* transient soap skipped */
}

int ns1__updateHentRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__updateHentRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__updateHentRequest(struct soap *soap, const char *tag, int id, const ns1__updateHentRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__updateHentRequest), type))
		return soap->error;
	if (a->ns1__updateHentRequest::session)
	{	if (soap_out_PointerTons1__sessionRequest(soap, "session", -1, &a->ns1__updateHentRequest::session, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "session"))
		return soap->error;
	if (a->ns1__updateHentRequest::hent)
	{	if (soap_out_PointerTons1__hent(soap, "hent", -1, &a->ns1__updateHentRequest::hent, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "hent"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__updateHentRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__updateHentRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__updateHentRequest * SOAP_FMAC4 soap_in_ns1__updateHentRequest(struct soap *soap, const char *tag, ns1__updateHentRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__updateHentRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__updateHentRequest, sizeof(ns1__updateHentRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__updateHentRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__updateHentRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_session1 = 1;
	size_t soap_flag_hent1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sessionRequest(soap, "session", &(a->ns1__updateHentRequest::session), "ns1:sessionRequest"))
				{	soap_flag_session1--;
					continue;
				}
			if (soap_flag_hent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__hent(soap, "hent", &(a->ns1__updateHentRequest::hent), "ns1:hent"))
				{	soap_flag_hent1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__updateHentRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__updateHentRequest, 0, sizeof(ns1__updateHentRequest), 0, soap_copy_ns1__updateHentRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_session1 > 0 || soap_flag_hent1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__updateHentRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__updateHentRequest);
	if (this->soap_out(soap, tag?tag:"ns1:updateHentRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__updateHentRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__updateHentRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__updateHentRequest * SOAP_FMAC4 soap_get_ns1__updateHentRequest(struct soap *soap, ns1__updateHentRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__updateHentRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__updateHentRequest * SOAP_FMAC2 soap_instantiate_ns1__updateHentRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__updateHentRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__updateHentRequest, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__updateHentRequest);
		if (size)
			*size = sizeof(ns1__updateHentRequest);
		((ns1__updateHentRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__updateHentRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__updateHentRequest);
		for (int i = 0; i < n; i++)
			((ns1__updateHentRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__updateHentRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__updateHentRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__updateHentRequest %p -> %p\n", q, p));
	*(ns1__updateHentRequest*)p = *(ns1__updateHentRequest*)q;
}

void ns1__commitSyncTransactionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__commitSyncTransactionResponse::result = NULL;
	/* transient soap skipped */
}

void ns1__commitSyncTransactionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__result(soap, &this->ns1__commitSyncTransactionResponse::result);
	/* transient soap skipped */
}

int ns1__commitSyncTransactionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__commitSyncTransactionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__commitSyncTransactionResponse(struct soap *soap, const char *tag, int id, const ns1__commitSyncTransactionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__commitSyncTransactionResponse), type))
		return soap->error;
	if (a->ns1__commitSyncTransactionResponse::result)
	{	if (soap_out_PointerTons1__result(soap, "result", -1, &a->ns1__commitSyncTransactionResponse::result, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "result"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__commitSyncTransactionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__commitSyncTransactionResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__commitSyncTransactionResponse * SOAP_FMAC4 soap_in_ns1__commitSyncTransactionResponse(struct soap *soap, const char *tag, ns1__commitSyncTransactionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__commitSyncTransactionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__commitSyncTransactionResponse, sizeof(ns1__commitSyncTransactionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__commitSyncTransactionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__commitSyncTransactionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__result(soap, "result", &(a->ns1__commitSyncTransactionResponse::result), "ns1:result"))
				{	soap_flag_result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__commitSyncTransactionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__commitSyncTransactionResponse, 0, sizeof(ns1__commitSyncTransactionResponse), 0, soap_copy_ns1__commitSyncTransactionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__commitSyncTransactionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__commitSyncTransactionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:commitSyncTransactionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__commitSyncTransactionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__commitSyncTransactionResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__commitSyncTransactionResponse * SOAP_FMAC4 soap_get_ns1__commitSyncTransactionResponse(struct soap *soap, ns1__commitSyncTransactionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__commitSyncTransactionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__commitSyncTransactionResponse * SOAP_FMAC2 soap_instantiate_ns1__commitSyncTransactionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__commitSyncTransactionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__commitSyncTransactionResponse, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__commitSyncTransactionResponse);
		if (size)
			*size = sizeof(ns1__commitSyncTransactionResponse);
		((ns1__commitSyncTransactionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__commitSyncTransactionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__commitSyncTransactionResponse);
		for (int i = 0; i < n; i++)
			((ns1__commitSyncTransactionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__commitSyncTransactionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__commitSyncTransactionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__commitSyncTransactionResponse %p -> %p\n", q, p));
	*(ns1__commitSyncTransactionResponse*)p = *(ns1__commitSyncTransactionResponse*)q;
}

void ns1__commitSyncTransactionRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__commitSyncTransactionRequest::session = NULL;
	/* transient soap skipped */
}

void ns1__commitSyncTransactionRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__sessionRequest(soap, &this->ns1__commitSyncTransactionRequest::session);
	/* transient soap skipped */
}

int ns1__commitSyncTransactionRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__commitSyncTransactionRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__commitSyncTransactionRequest(struct soap *soap, const char *tag, int id, const ns1__commitSyncTransactionRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__commitSyncTransactionRequest), type))
		return soap->error;
	if (a->ns1__commitSyncTransactionRequest::session)
	{	if (soap_out_PointerTons1__sessionRequest(soap, "session", -1, &a->ns1__commitSyncTransactionRequest::session, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "session"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__commitSyncTransactionRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__commitSyncTransactionRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__commitSyncTransactionRequest * SOAP_FMAC4 soap_in_ns1__commitSyncTransactionRequest(struct soap *soap, const char *tag, ns1__commitSyncTransactionRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__commitSyncTransactionRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__commitSyncTransactionRequest, sizeof(ns1__commitSyncTransactionRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__commitSyncTransactionRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__commitSyncTransactionRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_session1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sessionRequest(soap, "session", &(a->ns1__commitSyncTransactionRequest::session), "ns1:sessionRequest"))
				{	soap_flag_session1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__commitSyncTransactionRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__commitSyncTransactionRequest, 0, sizeof(ns1__commitSyncTransactionRequest), 0, soap_copy_ns1__commitSyncTransactionRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_session1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__commitSyncTransactionRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__commitSyncTransactionRequest);
	if (this->soap_out(soap, tag?tag:"ns1:commitSyncTransactionRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__commitSyncTransactionRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__commitSyncTransactionRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__commitSyncTransactionRequest * SOAP_FMAC4 soap_get_ns1__commitSyncTransactionRequest(struct soap *soap, ns1__commitSyncTransactionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__commitSyncTransactionRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__commitSyncTransactionRequest * SOAP_FMAC2 soap_instantiate_ns1__commitSyncTransactionRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__commitSyncTransactionRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__commitSyncTransactionRequest, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__commitSyncTransactionRequest);
		if (size)
			*size = sizeof(ns1__commitSyncTransactionRequest);
		((ns1__commitSyncTransactionRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__commitSyncTransactionRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__commitSyncTransactionRequest);
		for (int i = 0; i < n; i++)
			((ns1__commitSyncTransactionRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__commitSyncTransactionRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__commitSyncTransactionRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__commitSyncTransactionRequest %p -> %p\n", q, p));
	*(ns1__commitSyncTransactionRequest*)p = *(ns1__commitSyncTransactionRequest*)q;
}

void ns1__closeSyncTransactionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__closeSyncTransactionResponse::result = NULL;
	/* transient soap skipped */
}

void ns1__closeSyncTransactionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__result(soap, &this->ns1__closeSyncTransactionResponse::result);
	/* transient soap skipped */
}

int ns1__closeSyncTransactionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__closeSyncTransactionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__closeSyncTransactionResponse(struct soap *soap, const char *tag, int id, const ns1__closeSyncTransactionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__closeSyncTransactionResponse), type))
		return soap->error;
	if (a->ns1__closeSyncTransactionResponse::result)
	{	if (soap_out_PointerTons1__result(soap, "result", -1, &a->ns1__closeSyncTransactionResponse::result, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "result"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__closeSyncTransactionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__closeSyncTransactionResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__closeSyncTransactionResponse * SOAP_FMAC4 soap_in_ns1__closeSyncTransactionResponse(struct soap *soap, const char *tag, ns1__closeSyncTransactionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__closeSyncTransactionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__closeSyncTransactionResponse, sizeof(ns1__closeSyncTransactionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__closeSyncTransactionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__closeSyncTransactionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__result(soap, "result", &(a->ns1__closeSyncTransactionResponse::result), "ns1:result"))
				{	soap_flag_result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__closeSyncTransactionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__closeSyncTransactionResponse, 0, sizeof(ns1__closeSyncTransactionResponse), 0, soap_copy_ns1__closeSyncTransactionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__closeSyncTransactionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__closeSyncTransactionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:closeSyncTransactionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__closeSyncTransactionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__closeSyncTransactionResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__closeSyncTransactionResponse * SOAP_FMAC4 soap_get_ns1__closeSyncTransactionResponse(struct soap *soap, ns1__closeSyncTransactionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__closeSyncTransactionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__closeSyncTransactionResponse * SOAP_FMAC2 soap_instantiate_ns1__closeSyncTransactionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__closeSyncTransactionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__closeSyncTransactionResponse, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__closeSyncTransactionResponse);
		if (size)
			*size = sizeof(ns1__closeSyncTransactionResponse);
		((ns1__closeSyncTransactionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__closeSyncTransactionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__closeSyncTransactionResponse);
		for (int i = 0; i < n; i++)
			((ns1__closeSyncTransactionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__closeSyncTransactionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__closeSyncTransactionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__closeSyncTransactionResponse %p -> %p\n", q, p));
	*(ns1__closeSyncTransactionResponse*)p = *(ns1__closeSyncTransactionResponse*)q;
}

void ns1__closeSyncTransactionRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__closeSyncTransactionRequest::session = NULL;
	/* transient soap skipped */
}

void ns1__closeSyncTransactionRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__sessionRequest(soap, &this->ns1__closeSyncTransactionRequest::session);
	/* transient soap skipped */
}

int ns1__closeSyncTransactionRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__closeSyncTransactionRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__closeSyncTransactionRequest(struct soap *soap, const char *tag, int id, const ns1__closeSyncTransactionRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__closeSyncTransactionRequest), type))
		return soap->error;
	if (a->ns1__closeSyncTransactionRequest::session)
	{	if (soap_out_PointerTons1__sessionRequest(soap, "session", -1, &a->ns1__closeSyncTransactionRequest::session, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "session"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__closeSyncTransactionRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__closeSyncTransactionRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__closeSyncTransactionRequest * SOAP_FMAC4 soap_in_ns1__closeSyncTransactionRequest(struct soap *soap, const char *tag, ns1__closeSyncTransactionRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__closeSyncTransactionRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__closeSyncTransactionRequest, sizeof(ns1__closeSyncTransactionRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__closeSyncTransactionRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__closeSyncTransactionRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_session1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_session1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sessionRequest(soap, "session", &(a->ns1__closeSyncTransactionRequest::session), "ns1:sessionRequest"))
				{	soap_flag_session1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__closeSyncTransactionRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__closeSyncTransactionRequest, 0, sizeof(ns1__closeSyncTransactionRequest), 0, soap_copy_ns1__closeSyncTransactionRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_session1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__closeSyncTransactionRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__closeSyncTransactionRequest);
	if (this->soap_out(soap, tag?tag:"ns1:closeSyncTransactionRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__closeSyncTransactionRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__closeSyncTransactionRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__closeSyncTransactionRequest * SOAP_FMAC4 soap_get_ns1__closeSyncTransactionRequest(struct soap *soap, ns1__closeSyncTransactionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__closeSyncTransactionRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__closeSyncTransactionRequest * SOAP_FMAC2 soap_instantiate_ns1__closeSyncTransactionRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__closeSyncTransactionRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__closeSyncTransactionRequest, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__closeSyncTransactionRequest);
		if (size)
			*size = sizeof(ns1__closeSyncTransactionRequest);
		((ns1__closeSyncTransactionRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__closeSyncTransactionRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__closeSyncTransactionRequest);
		for (int i = 0; i < n; i++)
			((ns1__closeSyncTransactionRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__closeSyncTransactionRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__closeSyncTransactionRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__closeSyncTransactionRequest %p -> %p\n", q, p));
	*(ns1__closeSyncTransactionRequest*)p = *(ns1__closeSyncTransactionRequest*)q;
}

void ns1__cursorRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__cursorRequest::size);
	soap_default_std__string(soap, &this->ns1__sessionRequest::sessionId);
	/* transient soap skipped */
}

void ns1__cursorRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__sessionRequest::sessionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__sessionRequest::sessionId);
	/* transient soap skipped */
}

int ns1__cursorRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__cursorRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cursorRequest(struct soap *soap, const char *tag, int id, const ns1__cursorRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cursorRequest), "ns1:cursorRequest"))
		return soap->error;
	if (soap_out_std__string(soap, "sessionId", -1, &(a->ns1__sessionRequest::sessionId), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_int(soap, "size", -1, &(a->ns1__cursorRequest::size), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__cursorRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__cursorRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__cursorRequest * SOAP_FMAC4 soap_in_ns1__cursorRequest(struct soap *soap, const char *tag, ns1__cursorRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__cursorRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cursorRequest, sizeof(ns1__cursorRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__cursorRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__cursorRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sessionId2 = 1;
	size_t soap_flag_size1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sessionId2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sessionId", &(a->ns1__sessionRequest::sessionId), "xsd:string"))
				{	soap_flag_sessionId2--;
					continue;
				}
			/* transient soap skipped */
			if (soap_flag_size1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "size", &(a->ns1__cursorRequest::size), "xsd:int"))
				{	soap_flag_size1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__cursorRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cursorRequest, 0, sizeof(ns1__cursorRequest), 0, soap_copy_ns1__cursorRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sessionId2 > 0 || soap_flag_size1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__cursorRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__cursorRequest);
	if (this->soap_out(soap, tag?tag:"ns1:cursorRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__cursorRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__cursorRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__cursorRequest * SOAP_FMAC4 soap_get_ns1__cursorRequest(struct soap *soap, ns1__cursorRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cursorRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__cursorRequest * SOAP_FMAC2 soap_instantiate_ns1__cursorRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cursorRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cursorRequest, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__cursorRequest);
		if (size)
			*size = sizeof(ns1__cursorRequest);
		((ns1__cursorRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__cursorRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__cursorRequest);
		for (int i = 0; i < n; i++)
			((ns1__cursorRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__cursorRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cursorRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__cursorRequest %p -> %p\n", q, p));
	*(ns1__cursorRequest*)p = *(ns1__cursorRequest*)q;
}

void ns1__sessionRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__sessionRequest::sessionId);
	/* transient soap skipped */
}

void ns1__sessionRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__sessionRequest::sessionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__sessionRequest::sessionId);
	/* transient soap skipped */
}

int ns1__sessionRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__sessionRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__sessionRequest(struct soap *soap, const char *tag, int id, const ns1__sessionRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__sessionRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "sessionId", -1, &(a->ns1__sessionRequest::sessionId), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__sessionRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__sessionRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__sessionRequest * SOAP_FMAC4 soap_in_ns1__sessionRequest(struct soap *soap, const char *tag, ns1__sessionRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__sessionRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__sessionRequest, sizeof(ns1__sessionRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__sessionRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__sessionRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sessionId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sessionId", &(a->ns1__sessionRequest::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__sessionRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__sessionRequest, 0, sizeof(ns1__sessionRequest), 0, soap_copy_ns1__sessionRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sessionId1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__sessionRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__sessionRequest);
	if (this->soap_out(soap, tag?tag:"ns1:sessionRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__sessionRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__sessionRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__sessionRequest * SOAP_FMAC4 soap_get_ns1__sessionRequest(struct soap *soap, ns1__sessionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__sessionRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__sessionRequest * SOAP_FMAC2 soap_instantiate_ns1__sessionRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__sessionRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__sessionRequest, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:cursorRequest"))
	{	cp->type = SOAP_TYPE_ns1__cursorRequest;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__cursorRequest);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__cursorRequest);
			((ns1__cursorRequest*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__cursorRequest[n]);
			if (size)
				*size = n * sizeof(ns1__cursorRequest);
			for (int i = 0; i < n; i++)
				((ns1__cursorRequest*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__cursorRequest*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__sessionRequest);
		if (size)
			*size = sizeof(ns1__sessionRequest);
		((ns1__sessionRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__sessionRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__sessionRequest);
		for (int i = 0; i < n; i++)
			((ns1__sessionRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__sessionRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__sessionRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__sessionRequest %p -> %p\n", q, p));
	*(ns1__sessionRequest*)p = *(ns1__sessionRequest*)q;
}

void ns1__openSessionResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__openSessionResponse::sessionId);
	this->ns1__openSessionResponse::result = NULL;
	/* transient soap skipped */
}

void ns1__openSessionResponse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__openSessionResponse::sessionId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__openSessionResponse::sessionId);
	soap_serialize_PointerTons1__result(soap, &this->ns1__openSessionResponse::result);
	/* transient soap skipped */
}

int ns1__openSessionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__openSessionResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__openSessionResponse(struct soap *soap, const char *tag, int id, const ns1__openSessionResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__openSessionResponse), type))
		return soap->error;
	if (soap_out_std__string(soap, "sessionId", -1, &(a->ns1__openSessionResponse::sessionId), ""))
		return soap->error;
	if (a->ns1__openSessionResponse::result)
	{	if (soap_out_PointerTons1__result(soap, "result", -1, &a->ns1__openSessionResponse::result, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "result"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__openSessionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__openSessionResponse(soap, tag, this, type);
}

SOAP_FMAC3 ns1__openSessionResponse * SOAP_FMAC4 soap_in_ns1__openSessionResponse(struct soap *soap, const char *tag, ns1__openSessionResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__openSessionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__openSessionResponse, sizeof(ns1__openSessionResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__openSessionResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__openSessionResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_sessionId1 = 1;
	size_t soap_flag_result1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_sessionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "sessionId", &(a->ns1__openSessionResponse::sessionId), "xsd:string"))
				{	soap_flag_sessionId1--;
					continue;
				}
			if (soap_flag_result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__result(soap, "result", &(a->ns1__openSessionResponse::result), "ns1:result"))
				{	soap_flag_result1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__openSessionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__openSessionResponse, 0, sizeof(ns1__openSessionResponse), 0, soap_copy_ns1__openSessionResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_sessionId1 > 0 || soap_flag_result1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__openSessionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__openSessionResponse);
	if (this->soap_out(soap, tag?tag:"ns1:openSessionResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__openSessionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__openSessionResponse(soap, this, tag, type);
}

SOAP_FMAC3 ns1__openSessionResponse * SOAP_FMAC4 soap_get_ns1__openSessionResponse(struct soap *soap, ns1__openSessionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__openSessionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__openSessionResponse * SOAP_FMAC2 soap_instantiate_ns1__openSessionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__openSessionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__openSessionResponse, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__openSessionResponse);
		if (size)
			*size = sizeof(ns1__openSessionResponse);
		((ns1__openSessionResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__openSessionResponse[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__openSessionResponse);
		for (int i = 0; i < n; i++)
			((ns1__openSessionResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__openSessionResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__openSessionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__openSessionResponse %p -> %p\n", q, p));
	*(ns1__openSessionResponse*)p = *(ns1__openSessionResponse*)q;
}

void ns1__openOfficeSessionRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__openOfficeSessionRequest::login);
	soap_default_std__string(soap, &this->ns1__openOfficeSessionRequest::password);
	/* transient soap skipped */
}

void ns1__openOfficeSessionRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__openOfficeSessionRequest::login, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__openOfficeSessionRequest::login);
	soap_embedded(soap, &this->ns1__openOfficeSessionRequest::password, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__openOfficeSessionRequest::password);
	/* transient soap skipped */
}

int ns1__openOfficeSessionRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__openOfficeSessionRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__openOfficeSessionRequest(struct soap *soap, const char *tag, int id, const ns1__openOfficeSessionRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__openOfficeSessionRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "login", -1, &(a->ns1__openOfficeSessionRequest::login), ""))
		return soap->error;
	if (soap_out_std__string(soap, "password", -1, &(a->ns1__openOfficeSessionRequest::password), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__openOfficeSessionRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__openOfficeSessionRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__openOfficeSessionRequest * SOAP_FMAC4 soap_in_ns1__openOfficeSessionRequest(struct soap *soap, const char *tag, ns1__openOfficeSessionRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__openOfficeSessionRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__openOfficeSessionRequest, sizeof(ns1__openOfficeSessionRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__openOfficeSessionRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__openOfficeSessionRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_login1 = 1;
	size_t soap_flag_password1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_login1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "login", &(a->ns1__openOfficeSessionRequest::login), "xsd:string"))
				{	soap_flag_login1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "password", &(a->ns1__openOfficeSessionRequest::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__openOfficeSessionRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__openOfficeSessionRequest, 0, sizeof(ns1__openOfficeSessionRequest), 0, soap_copy_ns1__openOfficeSessionRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_login1 > 0 || soap_flag_password1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__openOfficeSessionRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__openOfficeSessionRequest);
	if (this->soap_out(soap, tag?tag:"ns1:openOfficeSessionRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__openOfficeSessionRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__openOfficeSessionRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__openOfficeSessionRequest * SOAP_FMAC4 soap_get_ns1__openOfficeSessionRequest(struct soap *soap, ns1__openOfficeSessionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__openOfficeSessionRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__openOfficeSessionRequest * SOAP_FMAC2 soap_instantiate_ns1__openOfficeSessionRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__openOfficeSessionRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__openOfficeSessionRequest, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__openOfficeSessionRequest);
		if (size)
			*size = sizeof(ns1__openOfficeSessionRequest);
		((ns1__openOfficeSessionRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__openOfficeSessionRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__openOfficeSessionRequest);
		for (int i = 0; i < n; i++)
			((ns1__openOfficeSessionRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__openOfficeSessionRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__openOfficeSessionRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__openOfficeSessionRequest %p -> %p\n", q, p));
	*(ns1__openOfficeSessionRequest*)p = *(ns1__openOfficeSessionRequest*)q;
}

void ns1__openMobileSessionRequest::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__openMobileSessionRequest::login);
	soap_default_std__string(soap, &this->ns1__openMobileSessionRequest::password);
	soap_default_std__string(soap, &this->ns1__openMobileSessionRequest::agent);
	/* transient soap skipped */
}

void ns1__openMobileSessionRequest::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__openMobileSessionRequest::login, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__openMobileSessionRequest::login);
	soap_embedded(soap, &this->ns1__openMobileSessionRequest::password, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__openMobileSessionRequest::password);
	soap_embedded(soap, &this->ns1__openMobileSessionRequest::agent, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__openMobileSessionRequest::agent);
	/* transient soap skipped */
}

int ns1__openMobileSessionRequest::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__openMobileSessionRequest(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__openMobileSessionRequest(struct soap *soap, const char *tag, int id, const ns1__openMobileSessionRequest *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__openMobileSessionRequest), type))
		return soap->error;
	if (soap_out_std__string(soap, "login", -1, &(a->ns1__openMobileSessionRequest::login), ""))
		return soap->error;
	if (soap_out_std__string(soap, "password", -1, &(a->ns1__openMobileSessionRequest::password), ""))
		return soap->error;
	if (soap_out_std__string(soap, "agent", -1, &(a->ns1__openMobileSessionRequest::agent), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__openMobileSessionRequest::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__openMobileSessionRequest(soap, tag, this, type);
}

SOAP_FMAC3 ns1__openMobileSessionRequest * SOAP_FMAC4 soap_in_ns1__openMobileSessionRequest(struct soap *soap, const char *tag, ns1__openMobileSessionRequest *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__openMobileSessionRequest *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__openMobileSessionRequest, sizeof(ns1__openMobileSessionRequest), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__openMobileSessionRequest)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__openMobileSessionRequest *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_login1 = 1;
	size_t soap_flag_password1 = 1;
	size_t soap_flag_agent1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_login1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "login", &(a->ns1__openMobileSessionRequest::login), "xsd:string"))
				{	soap_flag_login1--;
					continue;
				}
			if (soap_flag_password1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "password", &(a->ns1__openMobileSessionRequest::password), "xsd:string"))
				{	soap_flag_password1--;
					continue;
				}
			if (soap_flag_agent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "agent", &(a->ns1__openMobileSessionRequest::agent), "xsd:string"))
				{	soap_flag_agent1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__openMobileSessionRequest *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__openMobileSessionRequest, 0, sizeof(ns1__openMobileSessionRequest), 0, soap_copy_ns1__openMobileSessionRequest);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_login1 > 0 || soap_flag_password1 > 0 || soap_flag_agent1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__openMobileSessionRequest::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__openMobileSessionRequest);
	if (this->soap_out(soap, tag?tag:"ns1:openMobileSessionRequest", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__openMobileSessionRequest::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__openMobileSessionRequest(soap, this, tag, type);
}

SOAP_FMAC3 ns1__openMobileSessionRequest * SOAP_FMAC4 soap_get_ns1__openMobileSessionRequest(struct soap *soap, ns1__openMobileSessionRequest *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__openMobileSessionRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__openMobileSessionRequest * SOAP_FMAC2 soap_instantiate_ns1__openMobileSessionRequest(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__openMobileSessionRequest(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__openMobileSessionRequest, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__openMobileSessionRequest);
		if (size)
			*size = sizeof(ns1__openMobileSessionRequest);
		((ns1__openMobileSessionRequest*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__openMobileSessionRequest[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__openMobileSessionRequest);
		for (int i = 0; i < n; i++)
			((ns1__openMobileSessionRequest*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__openMobileSessionRequest*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__openMobileSessionRequest(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__openMobileSessionRequest %p -> %p\n", q, p));
	*(ns1__openMobileSessionRequest*)p = *(ns1__openMobileSessionRequest*)q;
}

void ns1__result::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__result::msg);
	soap_default_ns1__status(soap, &this->ns1__result::status);
	/* transient soap skipped */
}

void ns1__result::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__result::msg, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__result::msg);
	/* transient soap skipped */
}

int ns1__result::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__result(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__result(struct soap *soap, const char *tag, int id, const ns1__result *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__result), type))
		return soap->error;
	if (soap_out_std__string(soap, "msg", -1, &(a->ns1__result::msg), ""))
		return soap->error;
	if (soap_out_ns1__status(soap, "status", -1, &(a->ns1__result::status), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__result::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__result(soap, tag, this, type);
}

SOAP_FMAC3 ns1__result * SOAP_FMAC4 soap_in_ns1__result(struct soap *soap, const char *tag, ns1__result *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__result *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__result, sizeof(ns1__result), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__result)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__result *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_msg1 = 1;
	size_t soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_msg1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "msg", &(a->ns1__result::msg), "xsd:string"))
				{	soap_flag_msg1--;
					continue;
				}
			if (soap_flag_status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__status(soap, "status", &(a->ns1__result::status), "ns1:status"))
				{	soap_flag_status1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__result *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__result, 0, sizeof(ns1__result), 0, soap_copy_ns1__result);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_msg1 > 0 || soap_flag_status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__result::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__result);
	if (this->soap_out(soap, tag?tag:"ns1:result", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__result::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__result(soap, this, tag, type);
}

SOAP_FMAC3 ns1__result * SOAP_FMAC4 soap_get_ns1__result(struct soap *soap, ns1__result *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__result * SOAP_FMAC2 soap_instantiate_ns1__result(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__result(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__result, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__result);
		if (size)
			*size = sizeof(ns1__result);
		((ns1__result*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__result[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__result);
		for (int i = 0; i < n; i++)
			((ns1__result*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__result*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__result(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__result %p -> %p\n", q, p));
	*(ns1__result*)p = *(ns1__result*)q;
}

void ns1__qualifiedPurchase::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->ns1__qualifiedPurchase::purchaseId);
	soap_default_std__string(soap, &this->ns1__qualifiedPurchase::agent);
	soap_default_bool(soap, &this->ns1__qualifiedPurchase::wasDownloaded);
	soap_default_std__string(soap, &this->ns1__purchase::plateNo);
	soap_default_time(soap, &this->ns1__purchase::startDate);
	soap_default_time(soap, &this->ns1__purchase::endDate);
	soap_default_std__vectorTemplateOfPointerTons1__invoice(soap, &this->ns1__purchase::invoices);
	soap_default_std__vectorTemplateOfPointerTons1__hent(soap, &this->ns1__purchase::hents);
	/* transient soap skipped */
}

void ns1__qualifiedPurchase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__qualifiedPurchase::agent, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__qualifiedPurchase::agent);
	soap_embedded(soap, &this->ns1__purchase::plateNo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__purchase::plateNo);
	soap_embedded(soap, &this->ns1__purchase::startDate, SOAP_TYPE_time);
	soap_embedded(soap, &this->ns1__purchase::endDate, SOAP_TYPE_time);
	soap_serialize_std__vectorTemplateOfPointerTons1__invoice(soap, &this->ns1__purchase::invoices);
	soap_serialize_std__vectorTemplateOfPointerTons1__hent(soap, &this->ns1__purchase::hents);
	/* transient soap skipped */
}

int ns1__qualifiedPurchase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__qualifiedPurchase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__qualifiedPurchase(struct soap *soap, const char *tag, int id, const ns1__qualifiedPurchase *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__qualifiedPurchase), "ns1:qualifiedPurchase"))
		return soap->error;
	if (soap_out_std__string(soap, "plateNo", -1, &(a->ns1__purchase::plateNo), ""))
		return soap->error;
	if (soap_out_time(soap, "startDate", -1, &(a->ns1__purchase::startDate), ""))
		return soap->error;
	if (soap_out_time(soap, "endDate", -1, &(a->ns1__purchase::endDate), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__invoice(soap, "invoices", -1, &(a->ns1__purchase::invoices), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__hent(soap, "hents", -1, &(a->ns1__purchase::hents), ""))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_int(soap, "purchaseId", -1, &(a->ns1__qualifiedPurchase::purchaseId), ""))
		return soap->error;
	if (soap_out_std__string(soap, "agent", -1, &(a->ns1__qualifiedPurchase::agent), ""))
		return soap->error;
	if (soap_out_bool(soap, "wasDownloaded", -1, &(a->ns1__qualifiedPurchase::wasDownloaded), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *ns1__qualifiedPurchase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__qualifiedPurchase(soap, tag, this, type);
}

SOAP_FMAC3 ns1__qualifiedPurchase * SOAP_FMAC4 soap_in_ns1__qualifiedPurchase(struct soap *soap, const char *tag, ns1__qualifiedPurchase *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__qualifiedPurchase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__qualifiedPurchase, sizeof(ns1__qualifiedPurchase), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__qualifiedPurchase)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__qualifiedPurchase *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_plateNo2 = 1;
	size_t soap_flag_startDate2 = 1;
	size_t soap_flag_endDate2 = 1;
	size_t soap_flag_purchaseId1 = 1;
	size_t soap_flag_agent1 = 1;
	size_t soap_flag_wasDownloaded1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_plateNo2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "plateNo", &(a->ns1__purchase::plateNo), "xsd:string"))
				{	soap_flag_plateNo2--;
					continue;
				}
			if (soap_flag_startDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "startDate", &(a->ns1__purchase::startDate), "xsd:dateTime"))
				{	soap_flag_startDate2--;
					continue;
				}
			if (soap_flag_endDate2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "endDate", &(a->ns1__purchase::endDate), "xsd:dateTime"))
				{	soap_flag_endDate2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__invoice(soap, "invoices", &(a->ns1__purchase::invoices), "ns1:invoice"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__hent(soap, "hents", &(a->ns1__purchase::hents), "ns1:hent"))
					continue;
			/* transient soap skipped */
			if (soap_flag_purchaseId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "purchaseId", &(a->ns1__qualifiedPurchase::purchaseId), "xsd:int"))
				{	soap_flag_purchaseId1--;
					continue;
				}
			if (soap_flag_agent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "agent", &(a->ns1__qualifiedPurchase::agent), "xsd:string"))
				{	soap_flag_agent1--;
					continue;
				}
			if (soap_flag_wasDownloaded1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "wasDownloaded", &(a->ns1__qualifiedPurchase::wasDownloaded), "xsd:boolean"))
				{	soap_flag_wasDownloaded1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__qualifiedPurchase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__qualifiedPurchase, 0, sizeof(ns1__qualifiedPurchase), 0, soap_copy_ns1__qualifiedPurchase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_plateNo2 > 0 || soap_flag_startDate2 > 0 || soap_flag_endDate2 > 0 || a->ns1__purchase::invoices.size() < 1 || a->ns1__purchase::hents.size() < 1 || soap_flag_purchaseId1 > 0 || soap_flag_agent1 > 0 || soap_flag_wasDownloaded1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__qualifiedPurchase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__qualifiedPurchase);
	if (this->soap_out(soap, tag?tag:"ns1:qualifiedPurchase", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__qualifiedPurchase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__qualifiedPurchase(soap, this, tag, type);
}

SOAP_FMAC3 ns1__qualifiedPurchase * SOAP_FMAC4 soap_get_ns1__qualifiedPurchase(struct soap *soap, ns1__qualifiedPurchase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__qualifiedPurchase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__qualifiedPurchase * SOAP_FMAC2 soap_instantiate_ns1__qualifiedPurchase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__qualifiedPurchase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__qualifiedPurchase, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__qualifiedPurchase);
		if (size)
			*size = sizeof(ns1__qualifiedPurchase);
		((ns1__qualifiedPurchase*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__qualifiedPurchase[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__qualifiedPurchase);
		for (int i = 0; i < n; i++)
			((ns1__qualifiedPurchase*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__qualifiedPurchase*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__qualifiedPurchase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__qualifiedPurchase %p -> %p\n", q, p));
	*(ns1__qualifiedPurchase*)p = *(ns1__qualifiedPurchase*)q;
}

void ns1__purchase::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__purchase::plateNo);
	soap_default_time(soap, &this->ns1__purchase::startDate);
	soap_default_time(soap, &this->ns1__purchase::endDate);
	soap_default_std__vectorTemplateOfPointerTons1__invoice(soap, &this->ns1__purchase::invoices);
	soap_default_std__vectorTemplateOfPointerTons1__hent(soap, &this->ns1__purchase::hents);
	/* transient soap skipped */
}

void ns1__purchase::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__purchase::plateNo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__purchase::plateNo);
	soap_embedded(soap, &this->ns1__purchase::startDate, SOAP_TYPE_time);
	soap_embedded(soap, &this->ns1__purchase::endDate, SOAP_TYPE_time);
	soap_serialize_std__vectorTemplateOfPointerTons1__invoice(soap, &this->ns1__purchase::invoices);
	soap_serialize_std__vectorTemplateOfPointerTons1__hent(soap, &this->ns1__purchase::hents);
	/* transient soap skipped */
}

int ns1__purchase::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__purchase(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__purchase(struct soap *soap, const char *tag, int id, const ns1__purchase *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__purchase), type))
		return soap->error;
	if (soap_out_std__string(soap, "plateNo", -1, &(a->ns1__purchase::plateNo), ""))
		return soap->error;
	if (soap_out_time(soap, "startDate", -1, &(a->ns1__purchase::startDate), ""))
		return soap->error;
	if (soap_out_time(soap, "endDate", -1, &(a->ns1__purchase::endDate), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__invoice(soap, "invoices", -1, &(a->ns1__purchase::invoices), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__hent(soap, "hents", -1, &(a->ns1__purchase::hents), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__purchase::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__purchase(soap, tag, this, type);
}

SOAP_FMAC3 ns1__purchase * SOAP_FMAC4 soap_in_ns1__purchase(struct soap *soap, const char *tag, ns1__purchase *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__purchase *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__purchase, sizeof(ns1__purchase), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__purchase)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__purchase *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_plateNo1 = 1;
	size_t soap_flag_startDate1 = 1;
	size_t soap_flag_endDate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_plateNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "plateNo", &(a->ns1__purchase::plateNo), "xsd:string"))
				{	soap_flag_plateNo1--;
					continue;
				}
			if (soap_flag_startDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "startDate", &(a->ns1__purchase::startDate), "xsd:dateTime"))
				{	soap_flag_startDate1--;
					continue;
				}
			if (soap_flag_endDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "endDate", &(a->ns1__purchase::endDate), "xsd:dateTime"))
				{	soap_flag_endDate1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__invoice(soap, "invoices", &(a->ns1__purchase::invoices), "ns1:invoice"))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__hent(soap, "hents", &(a->ns1__purchase::hents), "ns1:hent"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__purchase *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__purchase, 0, sizeof(ns1__purchase), 0, soap_copy_ns1__purchase);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_plateNo1 > 0 || soap_flag_startDate1 > 0 || soap_flag_endDate1 > 0 || a->ns1__purchase::invoices.size() < 1 || a->ns1__purchase::hents.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__purchase::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__purchase);
	if (this->soap_out(soap, tag?tag:"ns1:purchase", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__purchase::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__purchase(soap, this, tag, type);
}

SOAP_FMAC3 ns1__purchase * SOAP_FMAC4 soap_get_ns1__purchase(struct soap *soap, ns1__purchase *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__purchase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__purchase * SOAP_FMAC2 soap_instantiate_ns1__purchase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__purchase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__purchase, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "ns1:qualifiedPurchase"))
	{	cp->type = SOAP_TYPE_ns1__qualifiedPurchase;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(ns1__qualifiedPurchase);
			if (!cp->ptr)
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (size)
				*size = sizeof(ns1__qualifiedPurchase);
			((ns1__qualifiedPurchase*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW(ns1__qualifiedPurchase[n]);
			if (size)
				*size = n * sizeof(ns1__qualifiedPurchase);
			for (int i = 0; i < n; i++)
				((ns1__qualifiedPurchase*)cp->ptr)[i].soap = soap;
		}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		return (ns1__qualifiedPurchase*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__purchase);
		if (size)
			*size = sizeof(ns1__purchase);
		((ns1__purchase*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__purchase[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__purchase);
		for (int i = 0; i < n; i++)
			((ns1__purchase*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__purchase*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__purchase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__purchase %p -> %p\n", q, p));
	*(ns1__purchase*)p = *(ns1__purchase*)q;
}

void ns1__invoice::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_time(soap, &this->ns1__invoice::invoiceDate);
	this->ns1__invoice::transactionDate = NULL;
	this->ns1__invoice::transactionPlace = NULL;
	soap_default_double(soap, &this->ns1__invoice::vatrate);
	soap_default_ns1__payWay(soap, &this->ns1__invoice::payWay);
	this->ns1__invoice::customNumber = NULL;
	soap_default_int(soap, &this->ns1__invoice::payDueDays);
	soap_default_std__string(soap, &this->ns1__invoice::invoiceHentNo);
	soap_default_ns1__invoiceType(soap, &this->ns1__invoice::invoiceType);
	soap_default_std__vectorTemplateOfPointerTons1__cow(soap, &this->ns1__invoice::cows);
	/* transient soap skipped */
}

void ns1__invoice::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__invoice::invoiceDate, SOAP_TYPE_time);
	soap_serialize_PointerTotime(soap, &this->ns1__invoice::transactionDate);
	soap_serialize_PointerTostd__string(soap, &this->ns1__invoice::transactionPlace);
	soap_embedded(soap, &this->ns1__invoice::vatrate, SOAP_TYPE_double);
	soap_serialize_PointerTostd__string(soap, &this->ns1__invoice::customNumber);
	soap_embedded(soap, &this->ns1__invoice::invoiceHentNo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__invoice::invoiceHentNo);
	soap_serialize_std__vectorTemplateOfPointerTons1__cow(soap, &this->ns1__invoice::cows);
	/* transient soap skipped */
}

int ns1__invoice::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__invoice(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__invoice(struct soap *soap, const char *tag, int id, const ns1__invoice *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__invoice), type))
		return soap->error;
	if (soap_out_time(soap, "invoiceDate", -1, &(a->ns1__invoice::invoiceDate), ""))
		return soap->error;
	if (a->ns1__invoice::transactionDate)
	{	if (soap_out_PointerTotime(soap, "transactionDate", -1, &a->ns1__invoice::transactionDate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "transactionDate"))
		return soap->error;
	if (a->ns1__invoice::transactionPlace)
	{	if (soap_out_PointerTostd__string(soap, "transactionPlace", -1, &a->ns1__invoice::transactionPlace, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "transactionPlace"))
		return soap->error;
	if (soap_out_double(soap, "vatrate", -1, &(a->ns1__invoice::vatrate), ""))
		return soap->error;
	if (soap_out_ns1__payWay(soap, "payWay", -1, &(a->ns1__invoice::payWay), ""))
		return soap->error;
	if (a->ns1__invoice::customNumber)
	{	if (soap_out_PointerTostd__string(soap, "customNumber", -1, &a->ns1__invoice::customNumber, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "customNumber"))
		return soap->error;
	if (soap_out_int(soap, "payDueDays", -1, &(a->ns1__invoice::payDueDays), ""))
		return soap->error;
	if (soap_out_std__string(soap, "invoiceHentNo", -1, &(a->ns1__invoice::invoiceHentNo), ""))
		return soap->error;
	if (soap_out_ns1__invoiceType(soap, "invoiceType", -1, &(a->ns1__invoice::invoiceType), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTons1__cow(soap, "cows", -1, &(a->ns1__invoice::cows), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__invoice::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__invoice(soap, tag, this, type);
}

SOAP_FMAC3 ns1__invoice * SOAP_FMAC4 soap_in_ns1__invoice(struct soap *soap, const char *tag, ns1__invoice *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__invoice *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__invoice, sizeof(ns1__invoice), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__invoice)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__invoice *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_invoiceDate1 = 1;
	size_t soap_flag_transactionDate1 = 1;
	size_t soap_flag_transactionPlace1 = 1;
	size_t soap_flag_vatrate1 = 1;
	size_t soap_flag_payWay1 = 1;
	size_t soap_flag_customNumber1 = 1;
	size_t soap_flag_payDueDays1 = 1;
	size_t soap_flag_invoiceHentNo1 = 1;
	size_t soap_flag_invoiceType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_invoiceDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "invoiceDate", &(a->ns1__invoice::invoiceDate), "xsd:dateTime"))
				{	soap_flag_invoiceDate1--;
					continue;
				}
			if (soap_flag_transactionDate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "transactionDate", &(a->ns1__invoice::transactionDate), "xsd:dateTime"))
				{	soap_flag_transactionDate1--;
					continue;
				}
			if (soap_flag_transactionPlace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "transactionPlace", &(a->ns1__invoice::transactionPlace), "xsd:string"))
				{	soap_flag_transactionPlace1--;
					continue;
				}
			if (soap_flag_vatrate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "vatrate", &(a->ns1__invoice::vatrate), "xsd:double"))
				{	soap_flag_vatrate1--;
					continue;
				}
			if (soap_flag_payWay1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__payWay(soap, "payWay", &(a->ns1__invoice::payWay), "ns1:payWay"))
				{	soap_flag_payWay1--;
					continue;
				}
			if (soap_flag_customNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "customNumber", &(a->ns1__invoice::customNumber), "xsd:string"))
				{	soap_flag_customNumber1--;
					continue;
				}
			if (soap_flag_payDueDays1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "payDueDays", &(a->ns1__invoice::payDueDays), "xsd:int"))
				{	soap_flag_payDueDays1--;
					continue;
				}
			if (soap_flag_invoiceHentNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "invoiceHentNo", &(a->ns1__invoice::invoiceHentNo), "xsd:string"))
				{	soap_flag_invoiceHentNo1--;
					continue;
				}
			if (soap_flag_invoiceType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__invoiceType(soap, "invoiceType", &(a->ns1__invoice::invoiceType), "ns1:invoiceType"))
				{	soap_flag_invoiceType1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTons1__cow(soap, "cows", &(a->ns1__invoice::cows), "ns1:cow"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__invoice *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__invoice, 0, sizeof(ns1__invoice), 0, soap_copy_ns1__invoice);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_invoiceDate1 > 0 || soap_flag_transactionDate1 > 0 || soap_flag_transactionPlace1 > 0 || soap_flag_vatrate1 > 0 || soap_flag_payWay1 > 0 || soap_flag_customNumber1 > 0 || soap_flag_payDueDays1 > 0 || soap_flag_invoiceHentNo1 > 0 || soap_flag_invoiceType1 > 0 || a->ns1__invoice::cows.size() < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__invoice::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__invoice);
	if (this->soap_out(soap, tag?tag:"ns1:invoice", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__invoice::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__invoice(soap, this, tag, type);
}

SOAP_FMAC3 ns1__invoice * SOAP_FMAC4 soap_get_ns1__invoice(struct soap *soap, ns1__invoice *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__invoice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__invoice * SOAP_FMAC2 soap_instantiate_ns1__invoice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__invoice(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__invoice, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__invoice);
		if (size)
			*size = sizeof(ns1__invoice);
		((ns1__invoice*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__invoice[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__invoice);
		for (int i = 0; i < n; i++)
			((ns1__invoice*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__invoice*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__invoice(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__invoice %p -> %p\n", q, p));
	*(ns1__invoice*)p = *(ns1__invoice*)q;
}

void ns1__cow::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__cow::cowNo);
	soap_default_ns1__cowSex(soap, &this->ns1__cow::sex);
	soap_default_std__string(soap, &this->ns1__cow::stockCode);
	soap_default_double(soap, &this->ns1__cow::weight);
	soap_default_double(soap, &this->ns1__cow::price);
	this->ns1__cow::latitude = NULL;
	this->ns1__cow::longitude = NULL;
	this->ns1__cow::passportNo = NULL;
	this->ns1__cow::firstOwnerNo = NULL;
	this->ns1__cow::passportIssueDt = NULL;
	this->ns1__cow::healthCertNo = NULL;
	this->ns1__cow::motherNo = NULL;
	this->ns1__cow::birthPlace = NULL;
	this->ns1__cow::birthDt = NULL;
	/* transient soap skipped */
}

void ns1__cow::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__cow::cowNo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__cow::cowNo);
	soap_embedded(soap, &this->ns1__cow::stockCode, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__cow::stockCode);
	soap_embedded(soap, &this->ns1__cow::weight, SOAP_TYPE_double);
	soap_embedded(soap, &this->ns1__cow::price, SOAP_TYPE_double);
	soap_serialize_PointerTodouble(soap, &this->ns1__cow::latitude);
	soap_serialize_PointerTodouble(soap, &this->ns1__cow::longitude);
	soap_serialize_PointerTostd__string(soap, &this->ns1__cow::passportNo);
	soap_serialize_PointerTostd__string(soap, &this->ns1__cow::firstOwnerNo);
	soap_serialize_PointerTotime(soap, &this->ns1__cow::passportIssueDt);
	soap_serialize_PointerTostd__string(soap, &this->ns1__cow::healthCertNo);
	soap_serialize_PointerTostd__string(soap, &this->ns1__cow::motherNo);
	soap_serialize_PointerTostd__string(soap, &this->ns1__cow::birthPlace);
	soap_serialize_PointerTotime(soap, &this->ns1__cow::birthDt);
	/* transient soap skipped */
}

int ns1__cow::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__cow(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__cow(struct soap *soap, const char *tag, int id, const ns1__cow *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__cow), type))
		return soap->error;
	if (soap_out_std__string(soap, "cowNo", -1, &(a->ns1__cow::cowNo), ""))
		return soap->error;
	if (soap_out_ns1__cowSex(soap, "sex", -1, &(a->ns1__cow::sex), ""))
		return soap->error;
	if (soap_out_std__string(soap, "stockCode", -1, &(a->ns1__cow::stockCode), ""))
		return soap->error;
	if (soap_out_double(soap, "weight", -1, &(a->ns1__cow::weight), ""))
		return soap->error;
	if (soap_out_double(soap, "price", -1, &(a->ns1__cow::price), ""))
		return soap->error;
	if (a->ns1__cow::latitude)
	{	if (soap_out_PointerTodouble(soap, "latitude", -1, &a->ns1__cow::latitude, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "latitude"))
		return soap->error;
	if (a->ns1__cow::longitude)
	{	if (soap_out_PointerTodouble(soap, "longitude", -1, &a->ns1__cow::longitude, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "longitude"))
		return soap->error;
	if (a->ns1__cow::passportNo)
	{	if (soap_out_PointerTostd__string(soap, "passportNo", -1, &a->ns1__cow::passportNo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "passportNo"))
		return soap->error;
	if (a->ns1__cow::firstOwnerNo)
	{	if (soap_out_PointerTostd__string(soap, "firstOwnerNo", -1, &a->ns1__cow::firstOwnerNo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "firstOwnerNo"))
		return soap->error;
	if (a->ns1__cow::passportIssueDt)
	{	if (soap_out_PointerTotime(soap, "passportIssueDt", -1, &a->ns1__cow::passportIssueDt, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "passportIssueDt"))
		return soap->error;
	if (a->ns1__cow::healthCertNo)
	{	if (soap_out_PointerTostd__string(soap, "healthCertNo", -1, &a->ns1__cow::healthCertNo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "healthCertNo"))
		return soap->error;
	if (a->ns1__cow::motherNo)
	{	if (soap_out_PointerTostd__string(soap, "motherNo", -1, &a->ns1__cow::motherNo, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "motherNo"))
		return soap->error;
	if (a->ns1__cow::birthPlace)
	{	if (soap_out_PointerTostd__string(soap, "birthPlace", -1, &a->ns1__cow::birthPlace, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "birthPlace"))
		return soap->error;
	if (a->ns1__cow::birthDt)
	{	if (soap_out_PointerTotime(soap, "birthDt", -1, &a->ns1__cow::birthDt, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "birthDt"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__cow::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__cow(soap, tag, this, type);
}

SOAP_FMAC3 ns1__cow * SOAP_FMAC4 soap_in_ns1__cow(struct soap *soap, const char *tag, ns1__cow *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__cow *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__cow, sizeof(ns1__cow), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__cow)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__cow *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_cowNo1 = 1;
	size_t soap_flag_sex1 = 1;
	size_t soap_flag_stockCode1 = 1;
	size_t soap_flag_weight1 = 1;
	size_t soap_flag_price1 = 1;
	size_t soap_flag_latitude1 = 1;
	size_t soap_flag_longitude1 = 1;
	size_t soap_flag_passportNo1 = 1;
	size_t soap_flag_firstOwnerNo1 = 1;
	size_t soap_flag_passportIssueDt1 = 1;
	size_t soap_flag_healthCertNo1 = 1;
	size_t soap_flag_motherNo1 = 1;
	size_t soap_flag_birthPlace1 = 1;
	size_t soap_flag_birthDt1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cowNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cowNo", &(a->ns1__cow::cowNo), "xsd:string"))
				{	soap_flag_cowNo1--;
					continue;
				}
			if (soap_flag_sex1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__cowSex(soap, "sex", &(a->ns1__cow::sex), "ns1:cowSex"))
				{	soap_flag_sex1--;
					continue;
				}
			if (soap_flag_stockCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "stockCode", &(a->ns1__cow::stockCode), "xsd:string"))
				{	soap_flag_stockCode1--;
					continue;
				}
			if (soap_flag_weight1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "weight", &(a->ns1__cow::weight), "xsd:double"))
				{	soap_flag_weight1--;
					continue;
				}
			if (soap_flag_price1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_double(soap, "price", &(a->ns1__cow::price), "xsd:double"))
				{	soap_flag_price1--;
					continue;
				}
			if (soap_flag_latitude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "latitude", &(a->ns1__cow::latitude), "xsd:double"))
				{	soap_flag_latitude1--;
					continue;
				}
			if (soap_flag_longitude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "longitude", &(a->ns1__cow::longitude), "xsd:double"))
				{	soap_flag_longitude1--;
					continue;
				}
			if (soap_flag_passportNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "passportNo", &(a->ns1__cow::passportNo), "xsd:string"))
				{	soap_flag_passportNo1--;
					continue;
				}
			if (soap_flag_firstOwnerNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "firstOwnerNo", &(a->ns1__cow::firstOwnerNo), "xsd:string"))
				{	soap_flag_firstOwnerNo1--;
					continue;
				}
			if (soap_flag_passportIssueDt1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "passportIssueDt", &(a->ns1__cow::passportIssueDt), "xsd:dateTime"))
				{	soap_flag_passportIssueDt1--;
					continue;
				}
			if (soap_flag_healthCertNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "healthCertNo", &(a->ns1__cow::healthCertNo), "xsd:string"))
				{	soap_flag_healthCertNo1--;
					continue;
				}
			if (soap_flag_motherNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "motherNo", &(a->ns1__cow::motherNo), "xsd:string"))
				{	soap_flag_motherNo1--;
					continue;
				}
			if (soap_flag_birthPlace1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "birthPlace", &(a->ns1__cow::birthPlace), "xsd:string"))
				{	soap_flag_birthPlace1--;
					continue;
				}
			if (soap_flag_birthDt1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "birthDt", &(a->ns1__cow::birthDt), "xsd:dateTime"))
				{	soap_flag_birthDt1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__cow *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__cow, 0, sizeof(ns1__cow), 0, soap_copy_ns1__cow);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cowNo1 > 0 || soap_flag_sex1 > 0 || soap_flag_stockCode1 > 0 || soap_flag_weight1 > 0 || soap_flag_price1 > 0 || soap_flag_latitude1 > 0 || soap_flag_longitude1 > 0 || soap_flag_passportNo1 > 0 || soap_flag_firstOwnerNo1 > 0 || soap_flag_passportIssueDt1 > 0 || soap_flag_healthCertNo1 > 0 || soap_flag_motherNo1 > 0 || soap_flag_birthPlace1 > 0 || soap_flag_birthDt1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__cow::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__cow);
	if (this->soap_out(soap, tag?tag:"ns1:cow", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__cow::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__cow(soap, this, tag, type);
}

SOAP_FMAC3 ns1__cow * SOAP_FMAC4 soap_get_ns1__cow(struct soap *soap, ns1__cow *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__cow(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__cow * SOAP_FMAC2 soap_instantiate_ns1__cow(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__cow(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__cow, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__cow);
		if (size)
			*size = sizeof(ns1__cow);
		((ns1__cow*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__cow[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__cow);
		for (int i = 0; i < n; i++)
			((ns1__cow*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__cow*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__cow(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__cow %p -> %p\n", q, p));
	*(ns1__cow*)p = *(ns1__cow*)q;
}

void ns1__company::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__company::name);
	soap_default_std__string(soap, &this->ns1__company::street);
	soap_default_std__string(soap, &this->ns1__company::POBox);
	soap_default_std__string(soap, &this->ns1__company::city);
	soap_default_std__string(soap, &this->ns1__company::zip);
	soap_default_std__string(soap, &this->ns1__company::farmNo);
	soap_default_std__string(soap, &this->ns1__company::cellPhoneNo);
	soap_default_std__string(soap, &this->ns1__company::phoneNo);
	soap_default_std__string(soap, &this->ns1__company::emailAddress);
	soap_default_std__string(soap, &this->ns1__company::nip);
	/* transient soap skipped */
}

void ns1__company::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__company::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__company::name);
	soap_embedded(soap, &this->ns1__company::street, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__company::street);
	soap_embedded(soap, &this->ns1__company::POBox, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__company::POBox);
	soap_embedded(soap, &this->ns1__company::city, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__company::city);
	soap_embedded(soap, &this->ns1__company::zip, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__company::zip);
	soap_embedded(soap, &this->ns1__company::farmNo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__company::farmNo);
	soap_embedded(soap, &this->ns1__company::cellPhoneNo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__company::cellPhoneNo);
	soap_embedded(soap, &this->ns1__company::phoneNo, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__company::phoneNo);
	soap_embedded(soap, &this->ns1__company::emailAddress, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__company::emailAddress);
	soap_embedded(soap, &this->ns1__company::nip, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__company::nip);
	/* transient soap skipped */
}

int ns1__company::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__company(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__company(struct soap *soap, const char *tag, int id, const ns1__company *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__company), type))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->ns1__company::name), ""))
		return soap->error;
	if (soap_out_std__string(soap, "street", -1, &(a->ns1__company::street), ""))
		return soap->error;
	if (soap_out_std__string(soap, "POBox", -1, &(a->ns1__company::POBox), ""))
		return soap->error;
	if (soap_out_std__string(soap, "city", -1, &(a->ns1__company::city), ""))
		return soap->error;
	if (soap_out_std__string(soap, "zip", -1, &(a->ns1__company::zip), ""))
		return soap->error;
	if (soap_out_std__string(soap, "farmNo", -1, &(a->ns1__company::farmNo), ""))
		return soap->error;
	if (soap_out_std__string(soap, "cellPhoneNo", -1, &(a->ns1__company::cellPhoneNo), ""))
		return soap->error;
	if (soap_out_std__string(soap, "phoneNo", -1, &(a->ns1__company::phoneNo), ""))
		return soap->error;
	if (soap_out_std__string(soap, "emailAddress", -1, &(a->ns1__company::emailAddress), ""))
		return soap->error;
	if (soap_out_std__string(soap, "nip", -1, &(a->ns1__company::nip), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__company::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__company(soap, tag, this, type);
}

SOAP_FMAC3 ns1__company * SOAP_FMAC4 soap_in_ns1__company(struct soap *soap, const char *tag, ns1__company *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__company *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__company, sizeof(ns1__company), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__company)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__company *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_name1 = 1;
	size_t soap_flag_street1 = 1;
	size_t soap_flag_POBox1 = 1;
	size_t soap_flag_city1 = 1;
	size_t soap_flag_zip1 = 1;
	size_t soap_flag_farmNo1 = 1;
	size_t soap_flag_cellPhoneNo1 = 1;
	size_t soap_flag_phoneNo1 = 1;
	size_t soap_flag_emailAddress1 = 1;
	size_t soap_flag_nip1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->ns1__company::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_street1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "street", &(a->ns1__company::street), "xsd:string"))
				{	soap_flag_street1--;
					continue;
				}
			if (soap_flag_POBox1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "POBox", &(a->ns1__company::POBox), "xsd:string"))
				{	soap_flag_POBox1--;
					continue;
				}
			if (soap_flag_city1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "city", &(a->ns1__company::city), "xsd:string"))
				{	soap_flag_city1--;
					continue;
				}
			if (soap_flag_zip1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "zip", &(a->ns1__company::zip), "xsd:string"))
				{	soap_flag_zip1--;
					continue;
				}
			if (soap_flag_farmNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "farmNo", &(a->ns1__company::farmNo), "xsd:string"))
				{	soap_flag_farmNo1--;
					continue;
				}
			if (soap_flag_cellPhoneNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cellPhoneNo", &(a->ns1__company::cellPhoneNo), "xsd:string"))
				{	soap_flag_cellPhoneNo1--;
					continue;
				}
			if (soap_flag_phoneNo1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "phoneNo", &(a->ns1__company::phoneNo), "xsd:string"))
				{	soap_flag_phoneNo1--;
					continue;
				}
			if (soap_flag_emailAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "emailAddress", &(a->ns1__company::emailAddress), "xsd:string"))
				{	soap_flag_emailAddress1--;
					continue;
				}
			if (soap_flag_nip1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "nip", &(a->ns1__company::nip), "xsd:string"))
				{	soap_flag_nip1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__company *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__company, 0, sizeof(ns1__company), 0, soap_copy_ns1__company);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0 || soap_flag_street1 > 0 || soap_flag_POBox1 > 0 || soap_flag_city1 > 0 || soap_flag_zip1 > 0 || soap_flag_farmNo1 > 0 || soap_flag_cellPhoneNo1 > 0 || soap_flag_phoneNo1 > 0 || soap_flag_emailAddress1 > 0 || soap_flag_nip1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__company::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__company);
	if (this->soap_out(soap, tag?tag:"ns1:company", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__company::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__company(soap, this, tag, type);
}

SOAP_FMAC3 ns1__company * SOAP_FMAC4 soap_get_ns1__company(struct soap *soap, ns1__company *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__company(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__company * SOAP_FMAC2 soap_instantiate_ns1__company(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__company(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__company, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__company);
		if (size)
			*size = sizeof(ns1__company);
		((ns1__company*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__company[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__company);
		for (int i = 0; i < n; i++)
			((ns1__company*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__company*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__company(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__company %p -> %p\n", q, p));
	*(ns1__company*)p = *(ns1__company*)q;
}

void ns1__stock::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->ns1__stock::stockCode);
	this->ns1__stock::stockName = NULL;
	this->ns1__stock::pricePerKg = NULL;
	soap_default_ns1__cowSex(soap, &this->ns1__stock::preDefSex);
	/* transient soap skipped */
}

void ns1__stock::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->ns1__stock::stockCode, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__stock::stockCode);
	soap_serialize_PointerTostd__string(soap, &this->ns1__stock::stockName);
	soap_serialize_PointerTodouble(soap, &this->ns1__stock::pricePerKg);
	/* transient soap skipped */
}

int ns1__stock::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__stock(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__stock(struct soap *soap, const char *tag, int id, const ns1__stock *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__stock), type))
		return soap->error;
	if (soap_out_std__string(soap, "stockCode", -1, &(a->ns1__stock::stockCode), ""))
		return soap->error;
	if (a->ns1__stock::stockName)
	{	if (soap_out_PointerTostd__string(soap, "stockName", -1, &a->ns1__stock::stockName, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "stockName"))
		return soap->error;
	if (a->ns1__stock::pricePerKg)
	{	if (soap_out_PointerTodouble(soap, "pricePerKg", -1, &a->ns1__stock::pricePerKg, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "pricePerKg"))
		return soap->error;
	if (soap_out_ns1__cowSex(soap, "preDefSex", -1, &(a->ns1__stock::preDefSex), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__stock::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__stock(soap, tag, this, type);
}

SOAP_FMAC3 ns1__stock * SOAP_FMAC4 soap_in_ns1__stock(struct soap *soap, const char *tag, ns1__stock *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__stock *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__stock, sizeof(ns1__stock), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__stock)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__stock *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_stockCode1 = 1;
	size_t soap_flag_stockName1 = 1;
	size_t soap_flag_pricePerKg1 = 1;
	size_t soap_flag_preDefSex1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_stockCode1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "stockCode", &(a->ns1__stock::stockCode), "xsd:string"))
				{	soap_flag_stockCode1--;
					continue;
				}
			if (soap_flag_stockName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "stockName", &(a->ns1__stock::stockName), "xsd:string"))
				{	soap_flag_stockName1--;
					continue;
				}
			if (soap_flag_pricePerKg1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "pricePerKg", &(a->ns1__stock::pricePerKg), "xsd:double"))
				{	soap_flag_pricePerKg1--;
					continue;
				}
			if (soap_flag_preDefSex1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__cowSex(soap, "preDefSex", &(a->ns1__stock::preDefSex), "ns1:cowSex"))
				{	soap_flag_preDefSex1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__stock *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__stock, 0, sizeof(ns1__stock), 0, soap_copy_ns1__stock);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_stockCode1 > 0 || soap_flag_stockName1 > 0 || soap_flag_pricePerKg1 > 0 || soap_flag_preDefSex1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__stock::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__stock);
	if (this->soap_out(soap, tag?tag:"ns1:stock", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__stock::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__stock(soap, this, tag, type);
}

SOAP_FMAC3 ns1__stock * SOAP_FMAC4 soap_get_ns1__stock(struct soap *soap, ns1__stock *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__stock(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__stock * SOAP_FMAC2 soap_instantiate_ns1__stock(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__stock(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__stock, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__stock);
		if (size)
			*size = sizeof(ns1__stock);
		((ns1__stock*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__stock[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__stock);
		for (int i = 0; i < n; i++)
			((ns1__stock*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__stock*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__stock(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__stock %p -> %p\n", q, p));
	*(ns1__stock*)p = *(ns1__stock*)q;
}

void ns1__hent::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->ns1__hent::bankaccountno = NULL;
	soap_default_std__string(soap, &this->ns1__hent::alias);
	soap_default_std__string(soap, &this->ns1__hent::farmno);
	this->ns1__hent::bankname = NULL;
	this->ns1__hent::cellphoneno = NULL;
	soap_default_std__string(soap, &this->ns1__hent::city);
	this->ns1__hent::emailaddress = NULL;
	this->ns1__hent::extras = NULL;
	soap_default_ns1__hentType(soap, &this->ns1__hent::henttype);
	this->ns1__hent::idno = NULL;
	this->ns1__hent::issuedate = NULL;
	this->ns1__hent::issuepost = NULL;
	this->ns1__hent::latitude = NULL;
	this->ns1__hent::longitude = NULL;
	soap_default_std__string(soap, &this->ns1__hent::name);
	this->ns1__hent::nip = NULL;
	this->ns1__hent::pesel = NULL;
	this->ns1__hent::phone = NULL;
	this->ns1__hent::plate = NULL;
	soap_default_std__string(soap, &this->ns1__hent::pobox);
	this->ns1__hent::regon = NULL;
	soap_default_std__string(soap, &this->ns1__hent::street);
	this->ns1__hent::wetlicenceno = NULL;
	this->ns1__hent::wetno = NULL;
	soap_default_std__string(soap, &this->ns1__hent::zip);
	/* transient soap skipped */
}

void ns1__hent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &this->ns1__hent::bankaccountno);
	soap_embedded(soap, &this->ns1__hent::alias, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__hent::alias);
	soap_embedded(soap, &this->ns1__hent::farmno, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__hent::farmno);
	soap_serialize_PointerTostd__string(soap, &this->ns1__hent::bankname);
	soap_serialize_PointerTostd__string(soap, &this->ns1__hent::cellphoneno);
	soap_embedded(soap, &this->ns1__hent::city, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__hent::city);
	soap_serialize_PointerTostd__string(soap, &this->ns1__hent::emailaddress);
	soap_serialize_PointerTostd__string(soap, &this->ns1__hent::extras);
	soap_serialize_PointerTostd__string(soap, &this->ns1__hent::idno);
	soap_serialize_PointerTotime(soap, &this->ns1__hent::issuedate);
	soap_serialize_PointerTostd__string(soap, &this->ns1__hent::issuepost);
	soap_serialize_PointerTodouble(soap, &this->ns1__hent::latitude);
	soap_serialize_PointerTodouble(soap, &this->ns1__hent::longitude);
	soap_embedded(soap, &this->ns1__hent::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__hent::name);
	soap_serialize_PointerTostd__string(soap, &this->ns1__hent::nip);
	soap_serialize_PointerTostd__string(soap, &this->ns1__hent::pesel);
	soap_serialize_PointerTostd__string(soap, &this->ns1__hent::phone);
	soap_serialize_PointerTostd__string(soap, &this->ns1__hent::plate);
	soap_embedded(soap, &this->ns1__hent::pobox, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__hent::pobox);
	soap_serialize_PointerTostd__string(soap, &this->ns1__hent::regon);
	soap_embedded(soap, &this->ns1__hent::street, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__hent::street);
	soap_serialize_PointerTostd__string(soap, &this->ns1__hent::wetlicenceno);
	soap_serialize_PointerTostd__string(soap, &this->ns1__hent::wetno);
	soap_embedded(soap, &this->ns1__hent::zip, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->ns1__hent::zip);
	/* transient soap skipped */
}

int ns1__hent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__hent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__hent(struct soap *soap, const char *tag, int id, const ns1__hent *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__hent), type))
		return soap->error;
	if (a->ns1__hent::bankaccountno)
	{	if (soap_out_PointerTostd__string(soap, "bankaccountno", -1, &a->ns1__hent::bankaccountno, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "bankaccountno"))
		return soap->error;
	if (soap_out_std__string(soap, "alias", -1, &(a->ns1__hent::alias), ""))
		return soap->error;
	if (soap_out_std__string(soap, "farmno", -1, &(a->ns1__hent::farmno), ""))
		return soap->error;
	if (a->ns1__hent::bankname)
	{	if (soap_out_PointerTostd__string(soap, "bankname", -1, &a->ns1__hent::bankname, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "bankname"))
		return soap->error;
	if (a->ns1__hent::cellphoneno)
	{	if (soap_out_PointerTostd__string(soap, "cellphoneno", -1, &a->ns1__hent::cellphoneno, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "cellphoneno"))
		return soap->error;
	if (soap_out_std__string(soap, "city", -1, &(a->ns1__hent::city), ""))
		return soap->error;
	if (a->ns1__hent::emailaddress)
	{	if (soap_out_PointerTostd__string(soap, "emailaddress", -1, &a->ns1__hent::emailaddress, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "emailaddress"))
		return soap->error;
	if (a->ns1__hent::extras)
	{	if (soap_out_PointerTostd__string(soap, "extras", -1, &a->ns1__hent::extras, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "extras"))
		return soap->error;
	if (soap_out_ns1__hentType(soap, "henttype", -1, &(a->ns1__hent::henttype), ""))
		return soap->error;
	if (a->ns1__hent::idno)
	{	if (soap_out_PointerTostd__string(soap, "idno", -1, &a->ns1__hent::idno, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "idno"))
		return soap->error;
	if (a->ns1__hent::issuedate)
	{	if (soap_out_PointerTotime(soap, "issuedate", -1, &a->ns1__hent::issuedate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "issuedate"))
		return soap->error;
	if (a->ns1__hent::issuepost)
	{	if (soap_out_PointerTostd__string(soap, "issuepost", -1, &a->ns1__hent::issuepost, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "issuepost"))
		return soap->error;
	if (a->ns1__hent::latitude)
	{	if (soap_out_PointerTodouble(soap, "latitude", -1, &a->ns1__hent::latitude, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "latitude"))
		return soap->error;
	if (a->ns1__hent::longitude)
	{	if (soap_out_PointerTodouble(soap, "longitude", -1, &a->ns1__hent::longitude, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "longitude"))
		return soap->error;
	if (soap_out_std__string(soap, "name", -1, &(a->ns1__hent::name), ""))
		return soap->error;
	if (a->ns1__hent::nip)
	{	if (soap_out_PointerTostd__string(soap, "nip", -1, &a->ns1__hent::nip, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "nip"))
		return soap->error;
	if (a->ns1__hent::pesel)
	{	if (soap_out_PointerTostd__string(soap, "pesel", -1, &a->ns1__hent::pesel, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "pesel"))
		return soap->error;
	if (a->ns1__hent::phone)
	{	if (soap_out_PointerTostd__string(soap, "phone", -1, &a->ns1__hent::phone, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "phone"))
		return soap->error;
	if (a->ns1__hent::plate)
	{	if (soap_out_PointerTostd__string(soap, "plate", -1, &a->ns1__hent::plate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "plate"))
		return soap->error;
	if (soap_out_std__string(soap, "pobox", -1, &(a->ns1__hent::pobox), ""))
		return soap->error;
	if (a->ns1__hent::regon)
	{	if (soap_out_PointerTostd__string(soap, "regon", -1, &a->ns1__hent::regon, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "regon"))
		return soap->error;
	if (soap_out_std__string(soap, "street", -1, &(a->ns1__hent::street), ""))
		return soap->error;
	if (a->ns1__hent::wetlicenceno)
	{	if (soap_out_PointerTostd__string(soap, "wetlicenceno", -1, &a->ns1__hent::wetlicenceno, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "wetlicenceno"))
		return soap->error;
	if (a->ns1__hent::wetno)
	{	if (soap_out_PointerTostd__string(soap, "wetno", -1, &a->ns1__hent::wetno, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "wetno"))
		return soap->error;
	if (soap_out_std__string(soap, "zip", -1, &(a->ns1__hent::zip), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *ns1__hent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__hent(soap, tag, this, type);
}

SOAP_FMAC3 ns1__hent * SOAP_FMAC4 soap_in_ns1__hent(struct soap *soap, const char *tag, ns1__hent *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__hent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__hent, sizeof(ns1__hent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__hent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__hent *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_bankaccountno1 = 1;
	size_t soap_flag_alias1 = 1;
	size_t soap_flag_farmno1 = 1;
	size_t soap_flag_bankname1 = 1;
	size_t soap_flag_cellphoneno1 = 1;
	size_t soap_flag_city1 = 1;
	size_t soap_flag_emailaddress1 = 1;
	size_t soap_flag_extras1 = 1;
	size_t soap_flag_henttype1 = 1;
	size_t soap_flag_idno1 = 1;
	size_t soap_flag_issuedate1 = 1;
	size_t soap_flag_issuepost1 = 1;
	size_t soap_flag_latitude1 = 1;
	size_t soap_flag_longitude1 = 1;
	size_t soap_flag_name1 = 1;
	size_t soap_flag_nip1 = 1;
	size_t soap_flag_pesel1 = 1;
	size_t soap_flag_phone1 = 1;
	size_t soap_flag_plate1 = 1;
	size_t soap_flag_pobox1 = 1;
	size_t soap_flag_regon1 = 1;
	size_t soap_flag_street1 = 1;
	size_t soap_flag_wetlicenceno1 = 1;
	size_t soap_flag_wetno1 = 1;
	size_t soap_flag_zip1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bankaccountno1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "bankaccountno", &(a->ns1__hent::bankaccountno), "xsd:string"))
				{	soap_flag_bankaccountno1--;
					continue;
				}
			if (soap_flag_alias1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "alias", &(a->ns1__hent::alias), "xsd:string"))
				{	soap_flag_alias1--;
					continue;
				}
			if (soap_flag_farmno1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "farmno", &(a->ns1__hent::farmno), "xsd:string"))
				{	soap_flag_farmno1--;
					continue;
				}
			if (soap_flag_bankname1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "bankname", &(a->ns1__hent::bankname), "xsd:string"))
				{	soap_flag_bankname1--;
					continue;
				}
			if (soap_flag_cellphoneno1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "cellphoneno", &(a->ns1__hent::cellphoneno), "xsd:string"))
				{	soap_flag_cellphoneno1--;
					continue;
				}
			if (soap_flag_city1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "city", &(a->ns1__hent::city), "xsd:string"))
				{	soap_flag_city1--;
					continue;
				}
			if (soap_flag_emailaddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "emailaddress", &(a->ns1__hent::emailaddress), "xsd:string"))
				{	soap_flag_emailaddress1--;
					continue;
				}
			if (soap_flag_extras1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "extras", &(a->ns1__hent::extras), "xsd:string"))
				{	soap_flag_extras1--;
					continue;
				}
			if (soap_flag_henttype1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__hentType(soap, "henttype", &(a->ns1__hent::henttype), "ns1:hentType"))
				{	soap_flag_henttype1--;
					continue;
				}
			if (soap_flag_idno1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "idno", &(a->ns1__hent::idno), "xsd:string"))
				{	soap_flag_idno1--;
					continue;
				}
			if (soap_flag_issuedate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "issuedate", &(a->ns1__hent::issuedate), "xsd:dateTime"))
				{	soap_flag_issuedate1--;
					continue;
				}
			if (soap_flag_issuepost1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "issuepost", &(a->ns1__hent::issuepost), "xsd:string"))
				{	soap_flag_issuepost1--;
					continue;
				}
			if (soap_flag_latitude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "latitude", &(a->ns1__hent::latitude), "xsd:double"))
				{	soap_flag_latitude1--;
					continue;
				}
			if (soap_flag_longitude1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTodouble(soap, "longitude", &(a->ns1__hent::longitude), "xsd:double"))
				{	soap_flag_longitude1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(a->ns1__hent::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_nip1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "nip", &(a->ns1__hent::nip), "xsd:string"))
				{	soap_flag_nip1--;
					continue;
				}
			if (soap_flag_pesel1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "pesel", &(a->ns1__hent::pesel), "xsd:string"))
				{	soap_flag_pesel1--;
					continue;
				}
			if (soap_flag_phone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "phone", &(a->ns1__hent::phone), "xsd:string"))
				{	soap_flag_phone1--;
					continue;
				}
			if (soap_flag_plate1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "plate", &(a->ns1__hent::plate), "xsd:string"))
				{	soap_flag_plate1--;
					continue;
				}
			if (soap_flag_pobox1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "pobox", &(a->ns1__hent::pobox), "xsd:string"))
				{	soap_flag_pobox1--;
					continue;
				}
			if (soap_flag_regon1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "regon", &(a->ns1__hent::regon), "xsd:string"))
				{	soap_flag_regon1--;
					continue;
				}
			if (soap_flag_street1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "street", &(a->ns1__hent::street), "xsd:string"))
				{	soap_flag_street1--;
					continue;
				}
			if (soap_flag_wetlicenceno1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "wetlicenceno", &(a->ns1__hent::wetlicenceno), "xsd:string"))
				{	soap_flag_wetlicenceno1--;
					continue;
				}
			if (soap_flag_wetno1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "wetno", &(a->ns1__hent::wetno), "xsd:string"))
				{	soap_flag_wetno1--;
					continue;
				}
			if (soap_flag_zip1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "zip", &(a->ns1__hent::zip), "xsd:string"))
				{	soap_flag_zip1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__hent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__hent, 0, sizeof(ns1__hent), 0, soap_copy_ns1__hent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bankaccountno1 > 0 || soap_flag_alias1 > 0 || soap_flag_farmno1 > 0 || soap_flag_bankname1 > 0 || soap_flag_cellphoneno1 > 0 || soap_flag_city1 > 0 || soap_flag_emailaddress1 > 0 || soap_flag_extras1 > 0 || soap_flag_henttype1 > 0 || soap_flag_idno1 > 0 || soap_flag_issuedate1 > 0 || soap_flag_issuepost1 > 0 || soap_flag_latitude1 > 0 || soap_flag_longitude1 > 0 || soap_flag_name1 > 0 || soap_flag_nip1 > 0 || soap_flag_pesel1 > 0 || soap_flag_phone1 > 0 || soap_flag_plate1 > 0 || soap_flag_pobox1 > 0 || soap_flag_regon1 > 0 || soap_flag_street1 > 0 || soap_flag_wetlicenceno1 > 0 || soap_flag_wetno1 > 0 || soap_flag_zip1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int ns1__hent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__hent);
	if (this->soap_out(soap, tag?tag:"ns1:hent", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *ns1__hent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__hent(soap, this, tag, type);
}

SOAP_FMAC3 ns1__hent * SOAP_FMAC4 soap_get_ns1__hent(struct soap *soap, ns1__hent *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__hent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 ns1__hent * SOAP_FMAC2 soap_instantiate_ns1__hent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__hent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__hent, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(ns1__hent);
		if (size)
			*size = sizeof(ns1__hent);
		((ns1__hent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(ns1__hent[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__hent);
		for (int i = 0; i < n; i++)
			((ns1__hent*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__hent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__hent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__hent %p -> %p\n", q, p));
	*(ns1__hent*)p = *(ns1__hent*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__downloadPurchase(struct soap *soap, struct __ns1__downloadPurchase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__downloadPurchaseRequest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__downloadPurchase(struct soap *soap, const struct __ns1__downloadPurchase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__downloadPurchaseRequest(soap, &a->ns1__downloadPurchaseRequest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__downloadPurchase(struct soap *soap, const char *tag, int id, const struct __ns1__downloadPurchase *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__downloadPurchaseRequest(soap, "ns1:downloadPurchaseRequest", -1, &a->ns1__downloadPurchaseRequest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__downloadPurchase * SOAP_FMAC4 soap_in___ns1__downloadPurchase(struct soap *soap, const char *tag, struct __ns1__downloadPurchase *a, const char *type)
{
	size_t soap_flag_ns1__downloadPurchaseRequest_ = 1;
	short soap_flag;
	a = (struct __ns1__downloadPurchase *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__downloadPurchase, sizeof(struct __ns1__downloadPurchase), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__downloadPurchase(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__downloadPurchaseRequest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__downloadPurchaseRequest(soap, "ns1:downloadPurchaseRequest", &a->ns1__downloadPurchaseRequest_, "ns1:downloadPurchaseRequest"))
				{	soap_flag_ns1__downloadPurchaseRequest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__downloadPurchase(struct soap *soap, const struct __ns1__downloadPurchase *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__downloadPurchase(soap, tag?tag:"-ns1:downloadPurchase", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__downloadPurchase * SOAP_FMAC4 soap_get___ns1__downloadPurchase(struct soap *soap, struct __ns1__downloadPurchase *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__downloadPurchase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__downloadPurchase * SOAP_FMAC2 soap_instantiate___ns1__downloadPurchase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__downloadPurchase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__downloadPurchase, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__downloadPurchase);
		if (size)
			*size = sizeof(struct __ns1__downloadPurchase);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__downloadPurchase[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__downloadPurchase);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__downloadPurchase*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__downloadPurchase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__downloadPurchase %p -> %p\n", q, p));
	*(struct __ns1__downloadPurchase*)p = *(struct __ns1__downloadPurchase*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__fetchPurchases(struct soap *soap, struct __ns1__fetchPurchases *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__fetchPurchasesRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__fetchPurchases(struct soap *soap, const struct __ns1__fetchPurchases *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__cursorRequest(soap, &a->ns1__fetchPurchasesRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__fetchPurchases(struct soap *soap, const char *tag, int id, const struct __ns1__fetchPurchases *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__cursorRequest(soap, "ns1:fetchPurchasesRequest", -1, &a->ns1__fetchPurchasesRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__fetchPurchases * SOAP_FMAC4 soap_in___ns1__fetchPurchases(struct soap *soap, const char *tag, struct __ns1__fetchPurchases *a, const char *type)
{
	size_t soap_flag_ns1__fetchPurchasesRequest = 1;
	short soap_flag;
	a = (struct __ns1__fetchPurchases *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__fetchPurchases, sizeof(struct __ns1__fetchPurchases), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__fetchPurchases(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__fetchPurchasesRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__cursorRequest(soap, "ns1:fetchPurchasesRequest", &a->ns1__fetchPurchasesRequest, "ns1:cursorRequest"))
				{	soap_flag_ns1__fetchPurchasesRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__fetchPurchases(struct soap *soap, const struct __ns1__fetchPurchases *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__fetchPurchases(soap, tag?tag:"-ns1:fetchPurchases", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__fetchPurchases * SOAP_FMAC4 soap_get___ns1__fetchPurchases(struct soap *soap, struct __ns1__fetchPurchases *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__fetchPurchases(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__fetchPurchases * SOAP_FMAC2 soap_instantiate___ns1__fetchPurchases(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__fetchPurchases(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__fetchPurchases, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__fetchPurchases);
		if (size)
			*size = sizeof(struct __ns1__fetchPurchases);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__fetchPurchases[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__fetchPurchases);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__fetchPurchases*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__fetchPurchases(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__fetchPurchases %p -> %p\n", q, p));
	*(struct __ns1__fetchPurchases*)p = *(struct __ns1__fetchPurchases*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__closePurchaseCursor(struct soap *soap, struct __ns1__closePurchaseCursor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__closePurchaseCursorRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__closePurchaseCursor(struct soap *soap, const struct __ns1__closePurchaseCursor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__sessionRequest(soap, &a->ns1__closePurchaseCursorRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__closePurchaseCursor(struct soap *soap, const char *tag, int id, const struct __ns1__closePurchaseCursor *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__sessionRequest(soap, "ns1:closePurchaseCursorRequest", -1, &a->ns1__closePurchaseCursorRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__closePurchaseCursor * SOAP_FMAC4 soap_in___ns1__closePurchaseCursor(struct soap *soap, const char *tag, struct __ns1__closePurchaseCursor *a, const char *type)
{
	size_t soap_flag_ns1__closePurchaseCursorRequest = 1;
	short soap_flag;
	a = (struct __ns1__closePurchaseCursor *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__closePurchaseCursor, sizeof(struct __ns1__closePurchaseCursor), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__closePurchaseCursor(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__closePurchaseCursorRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sessionRequest(soap, "ns1:closePurchaseCursorRequest", &a->ns1__closePurchaseCursorRequest, "ns1:sessionRequest"))
				{	soap_flag_ns1__closePurchaseCursorRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__closePurchaseCursor(struct soap *soap, const struct __ns1__closePurchaseCursor *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__closePurchaseCursor(soap, tag?tag:"-ns1:closePurchaseCursor", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__closePurchaseCursor * SOAP_FMAC4 soap_get___ns1__closePurchaseCursor(struct soap *soap, struct __ns1__closePurchaseCursor *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__closePurchaseCursor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__closePurchaseCursor * SOAP_FMAC2 soap_instantiate___ns1__closePurchaseCursor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__closePurchaseCursor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__closePurchaseCursor, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__closePurchaseCursor);
		if (size)
			*size = sizeof(struct __ns1__closePurchaseCursor);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__closePurchaseCursor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__closePurchaseCursor);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__closePurchaseCursor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__closePurchaseCursor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__closePurchaseCursor %p -> %p\n", q, p));
	*(struct __ns1__closePurchaseCursor*)p = *(struct __ns1__closePurchaseCursor*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__openPurchaseCursor(struct soap *soap, struct __ns1__openPurchaseCursor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__openPurchaseCursorRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__openPurchaseCursor(struct soap *soap, const struct __ns1__openPurchaseCursor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__sessionRequest(soap, &a->ns1__openPurchaseCursorRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__openPurchaseCursor(struct soap *soap, const char *tag, int id, const struct __ns1__openPurchaseCursor *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__sessionRequest(soap, "ns1:openPurchaseCursorRequest", -1, &a->ns1__openPurchaseCursorRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__openPurchaseCursor * SOAP_FMAC4 soap_in___ns1__openPurchaseCursor(struct soap *soap, const char *tag, struct __ns1__openPurchaseCursor *a, const char *type)
{
	size_t soap_flag_ns1__openPurchaseCursorRequest = 1;
	short soap_flag;
	a = (struct __ns1__openPurchaseCursor *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__openPurchaseCursor, sizeof(struct __ns1__openPurchaseCursor), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__openPurchaseCursor(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__openPurchaseCursorRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sessionRequest(soap, "ns1:openPurchaseCursorRequest", &a->ns1__openPurchaseCursorRequest, "ns1:sessionRequest"))
				{	soap_flag_ns1__openPurchaseCursorRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__openPurchaseCursor(struct soap *soap, const struct __ns1__openPurchaseCursor *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__openPurchaseCursor(soap, tag?tag:"-ns1:openPurchaseCursor", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__openPurchaseCursor * SOAP_FMAC4 soap_get___ns1__openPurchaseCursor(struct soap *soap, struct __ns1__openPurchaseCursor *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__openPurchaseCursor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__openPurchaseCursor * SOAP_FMAC2 soap_instantiate___ns1__openPurchaseCursor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__openPurchaseCursor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__openPurchaseCursor, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__openPurchaseCursor);
		if (size)
			*size = sizeof(struct __ns1__openPurchaseCursor);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__openPurchaseCursor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__openPurchaseCursor);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__openPurchaseCursor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__openPurchaseCursor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__openPurchaseCursor %p -> %p\n", q, p));
	*(struct __ns1__openPurchaseCursor*)p = *(struct __ns1__openPurchaseCursor*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__uploadPurchase(struct soap *soap, struct __ns1__uploadPurchase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__uploadPurchaseRequest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__uploadPurchase(struct soap *soap, const struct __ns1__uploadPurchase *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__uploadPurchaseRequest(soap, &a->ns1__uploadPurchaseRequest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__uploadPurchase(struct soap *soap, const char *tag, int id, const struct __ns1__uploadPurchase *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__uploadPurchaseRequest(soap, "ns1:uploadPurchaseRequest", -1, &a->ns1__uploadPurchaseRequest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__uploadPurchase * SOAP_FMAC4 soap_in___ns1__uploadPurchase(struct soap *soap, const char *tag, struct __ns1__uploadPurchase *a, const char *type)
{
	size_t soap_flag_ns1__uploadPurchaseRequest_ = 1;
	short soap_flag;
	a = (struct __ns1__uploadPurchase *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__uploadPurchase, sizeof(struct __ns1__uploadPurchase), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__uploadPurchase(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__uploadPurchaseRequest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__uploadPurchaseRequest(soap, "ns1:uploadPurchaseRequest", &a->ns1__uploadPurchaseRequest_, "ns1:uploadPurchaseRequest"))
				{	soap_flag_ns1__uploadPurchaseRequest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__uploadPurchase(struct soap *soap, const struct __ns1__uploadPurchase *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__uploadPurchase(soap, tag?tag:"-ns1:uploadPurchase", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__uploadPurchase * SOAP_FMAC4 soap_get___ns1__uploadPurchase(struct soap *soap, struct __ns1__uploadPurchase *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__uploadPurchase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__uploadPurchase * SOAP_FMAC2 soap_instantiate___ns1__uploadPurchase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__uploadPurchase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__uploadPurchase, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__uploadPurchase);
		if (size)
			*size = sizeof(struct __ns1__uploadPurchase);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__uploadPurchase[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__uploadPurchase);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__uploadPurchase*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__uploadPurchase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__uploadPurchase %p -> %p\n", q, p));
	*(struct __ns1__uploadPurchase*)p = *(struct __ns1__uploadPurchase*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__fetchCompany(struct soap *soap, struct __ns1__fetchCompany *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__fetchCompanyRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__fetchCompany(struct soap *soap, const struct __ns1__fetchCompany *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__sessionRequest(soap, &a->ns1__fetchCompanyRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__fetchCompany(struct soap *soap, const char *tag, int id, const struct __ns1__fetchCompany *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__sessionRequest(soap, "ns1:fetchCompanyRequest", -1, &a->ns1__fetchCompanyRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__fetchCompany * SOAP_FMAC4 soap_in___ns1__fetchCompany(struct soap *soap, const char *tag, struct __ns1__fetchCompany *a, const char *type)
{
	size_t soap_flag_ns1__fetchCompanyRequest = 1;
	short soap_flag;
	a = (struct __ns1__fetchCompany *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__fetchCompany, sizeof(struct __ns1__fetchCompany), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__fetchCompany(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__fetchCompanyRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sessionRequest(soap, "ns1:fetchCompanyRequest", &a->ns1__fetchCompanyRequest, "ns1:sessionRequest"))
				{	soap_flag_ns1__fetchCompanyRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__fetchCompany(struct soap *soap, const struct __ns1__fetchCompany *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__fetchCompany(soap, tag?tag:"-ns1:fetchCompany", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__fetchCompany * SOAP_FMAC4 soap_get___ns1__fetchCompany(struct soap *soap, struct __ns1__fetchCompany *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__fetchCompany(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__fetchCompany * SOAP_FMAC2 soap_instantiate___ns1__fetchCompany(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__fetchCompany(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__fetchCompany, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__fetchCompany);
		if (size)
			*size = sizeof(struct __ns1__fetchCompany);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__fetchCompany[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__fetchCompany);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__fetchCompany*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__fetchCompany(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__fetchCompany %p -> %p\n", q, p));
	*(struct __ns1__fetchCompany*)p = *(struct __ns1__fetchCompany*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateCompany(struct soap *soap, struct __ns1__updateCompany *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__updateCompanyRequest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateCompany(struct soap *soap, const struct __ns1__updateCompany *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__updateCompanyRequest(soap, &a->ns1__updateCompanyRequest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateCompany(struct soap *soap, const char *tag, int id, const struct __ns1__updateCompany *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__updateCompanyRequest(soap, "ns1:updateCompanyRequest", -1, &a->ns1__updateCompanyRequest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateCompany * SOAP_FMAC4 soap_in___ns1__updateCompany(struct soap *soap, const char *tag, struct __ns1__updateCompany *a, const char *type)
{
	size_t soap_flag_ns1__updateCompanyRequest_ = 1;
	short soap_flag;
	a = (struct __ns1__updateCompany *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateCompany, sizeof(struct __ns1__updateCompany), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateCompany(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__updateCompanyRequest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__updateCompanyRequest(soap, "ns1:updateCompanyRequest", &a->ns1__updateCompanyRequest_, "ns1:updateCompanyRequest"))
				{	soap_flag_ns1__updateCompanyRequest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateCompany(struct soap *soap, const struct __ns1__updateCompany *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__updateCompany(soap, tag?tag:"-ns1:updateCompany", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateCompany * SOAP_FMAC4 soap_get___ns1__updateCompany(struct soap *soap, struct __ns1__updateCompany *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateCompany(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__updateCompany * SOAP_FMAC2 soap_instantiate___ns1__updateCompany(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__updateCompany(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__updateCompany, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__updateCompany);
		if (size)
			*size = sizeof(struct __ns1__updateCompany);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__updateCompany[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__updateCompany);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__updateCompany*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__updateCompany(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__updateCompany %p -> %p\n", q, p));
	*(struct __ns1__updateCompany*)p = *(struct __ns1__updateCompany*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__closeStockCursor(struct soap *soap, struct __ns1__closeStockCursor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__closeStockCursorRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__closeStockCursor(struct soap *soap, const struct __ns1__closeStockCursor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__sessionRequest(soap, &a->ns1__closeStockCursorRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__closeStockCursor(struct soap *soap, const char *tag, int id, const struct __ns1__closeStockCursor *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__sessionRequest(soap, "ns1:closeStockCursorRequest", -1, &a->ns1__closeStockCursorRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__closeStockCursor * SOAP_FMAC4 soap_in___ns1__closeStockCursor(struct soap *soap, const char *tag, struct __ns1__closeStockCursor *a, const char *type)
{
	size_t soap_flag_ns1__closeStockCursorRequest = 1;
	short soap_flag;
	a = (struct __ns1__closeStockCursor *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__closeStockCursor, sizeof(struct __ns1__closeStockCursor), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__closeStockCursor(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__closeStockCursorRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sessionRequest(soap, "ns1:closeStockCursorRequest", &a->ns1__closeStockCursorRequest, "ns1:sessionRequest"))
				{	soap_flag_ns1__closeStockCursorRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__closeStockCursor(struct soap *soap, const struct __ns1__closeStockCursor *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__closeStockCursor(soap, tag?tag:"-ns1:closeStockCursor", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__closeStockCursor * SOAP_FMAC4 soap_get___ns1__closeStockCursor(struct soap *soap, struct __ns1__closeStockCursor *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__closeStockCursor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__closeStockCursor * SOAP_FMAC2 soap_instantiate___ns1__closeStockCursor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__closeStockCursor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__closeStockCursor, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__closeStockCursor);
		if (size)
			*size = sizeof(struct __ns1__closeStockCursor);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__closeStockCursor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__closeStockCursor);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__closeStockCursor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__closeStockCursor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__closeStockCursor %p -> %p\n", q, p));
	*(struct __ns1__closeStockCursor*)p = *(struct __ns1__closeStockCursor*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__fetchStocks(struct soap *soap, struct __ns1__fetchStocks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__fetchStocksRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__fetchStocks(struct soap *soap, const struct __ns1__fetchStocks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__cursorRequest(soap, &a->ns1__fetchStocksRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__fetchStocks(struct soap *soap, const char *tag, int id, const struct __ns1__fetchStocks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__cursorRequest(soap, "ns1:fetchStocksRequest", -1, &a->ns1__fetchStocksRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__fetchStocks * SOAP_FMAC4 soap_in___ns1__fetchStocks(struct soap *soap, const char *tag, struct __ns1__fetchStocks *a, const char *type)
{
	size_t soap_flag_ns1__fetchStocksRequest = 1;
	short soap_flag;
	a = (struct __ns1__fetchStocks *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__fetchStocks, sizeof(struct __ns1__fetchStocks), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__fetchStocks(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__fetchStocksRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__cursorRequest(soap, "ns1:fetchStocksRequest", &a->ns1__fetchStocksRequest, "ns1:cursorRequest"))
				{	soap_flag_ns1__fetchStocksRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__fetchStocks(struct soap *soap, const struct __ns1__fetchStocks *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__fetchStocks(soap, tag?tag:"-ns1:fetchStocks", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__fetchStocks * SOAP_FMAC4 soap_get___ns1__fetchStocks(struct soap *soap, struct __ns1__fetchStocks *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__fetchStocks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__fetchStocks * SOAP_FMAC2 soap_instantiate___ns1__fetchStocks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__fetchStocks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__fetchStocks, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__fetchStocks);
		if (size)
			*size = sizeof(struct __ns1__fetchStocks);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__fetchStocks[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__fetchStocks);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__fetchStocks*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__fetchStocks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__fetchStocks %p -> %p\n", q, p));
	*(struct __ns1__fetchStocks*)p = *(struct __ns1__fetchStocks*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__openStockCursor(struct soap *soap, struct __ns1__openStockCursor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__openStockCursorRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__openStockCursor(struct soap *soap, const struct __ns1__openStockCursor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__sessionRequest(soap, &a->ns1__openStockCursorRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__openStockCursor(struct soap *soap, const char *tag, int id, const struct __ns1__openStockCursor *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__sessionRequest(soap, "ns1:openStockCursorRequest", -1, &a->ns1__openStockCursorRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__openStockCursor * SOAP_FMAC4 soap_in___ns1__openStockCursor(struct soap *soap, const char *tag, struct __ns1__openStockCursor *a, const char *type)
{
	size_t soap_flag_ns1__openStockCursorRequest = 1;
	short soap_flag;
	a = (struct __ns1__openStockCursor *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__openStockCursor, sizeof(struct __ns1__openStockCursor), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__openStockCursor(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__openStockCursorRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sessionRequest(soap, "ns1:openStockCursorRequest", &a->ns1__openStockCursorRequest, "ns1:sessionRequest"))
				{	soap_flag_ns1__openStockCursorRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__openStockCursor(struct soap *soap, const struct __ns1__openStockCursor *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__openStockCursor(soap, tag?tag:"-ns1:openStockCursor", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__openStockCursor * SOAP_FMAC4 soap_get___ns1__openStockCursor(struct soap *soap, struct __ns1__openStockCursor *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__openStockCursor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__openStockCursor * SOAP_FMAC2 soap_instantiate___ns1__openStockCursor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__openStockCursor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__openStockCursor, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__openStockCursor);
		if (size)
			*size = sizeof(struct __ns1__openStockCursor);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__openStockCursor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__openStockCursor);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__openStockCursor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__openStockCursor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__openStockCursor %p -> %p\n", q, p));
	*(struct __ns1__openStockCursor*)p = *(struct __ns1__openStockCursor*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__commitSyncTransaction(struct soap *soap, struct __ns1__commitSyncTransaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__commitSyncTransactionRequest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__commitSyncTransaction(struct soap *soap, const struct __ns1__commitSyncTransaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__sessionRequest(soap, &a->ns1__commitSyncTransactionRequest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__commitSyncTransaction(struct soap *soap, const char *tag, int id, const struct __ns1__commitSyncTransaction *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__sessionRequest(soap, "ns1:commitSyncTransactionRequest", -1, &a->ns1__commitSyncTransactionRequest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__commitSyncTransaction * SOAP_FMAC4 soap_in___ns1__commitSyncTransaction(struct soap *soap, const char *tag, struct __ns1__commitSyncTransaction *a, const char *type)
{
	size_t soap_flag_ns1__commitSyncTransactionRequest_ = 1;
	short soap_flag;
	a = (struct __ns1__commitSyncTransaction *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__commitSyncTransaction, sizeof(struct __ns1__commitSyncTransaction), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__commitSyncTransaction(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__commitSyncTransactionRequest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sessionRequest(soap, "ns1:commitSyncTransactionRequest", &a->ns1__commitSyncTransactionRequest_, "ns1:sessionRequest"))
				{	soap_flag_ns1__commitSyncTransactionRequest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__commitSyncTransaction(struct soap *soap, const struct __ns1__commitSyncTransaction *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__commitSyncTransaction(soap, tag?tag:"-ns1:commitSyncTransaction", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__commitSyncTransaction * SOAP_FMAC4 soap_get___ns1__commitSyncTransaction(struct soap *soap, struct __ns1__commitSyncTransaction *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__commitSyncTransaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__commitSyncTransaction * SOAP_FMAC2 soap_instantiate___ns1__commitSyncTransaction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__commitSyncTransaction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__commitSyncTransaction, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__commitSyncTransaction);
		if (size)
			*size = sizeof(struct __ns1__commitSyncTransaction);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__commitSyncTransaction[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__commitSyncTransaction);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__commitSyncTransaction*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__commitSyncTransaction(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__commitSyncTransaction %p -> %p\n", q, p));
	*(struct __ns1__commitSyncTransaction*)p = *(struct __ns1__commitSyncTransaction*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__closeSyncTransaction(struct soap *soap, struct __ns1__closeSyncTransaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__closeSyncTransactionRequest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__closeSyncTransaction(struct soap *soap, const struct __ns1__closeSyncTransaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__sessionRequest(soap, &a->ns1__closeSyncTransactionRequest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__closeSyncTransaction(struct soap *soap, const char *tag, int id, const struct __ns1__closeSyncTransaction *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__sessionRequest(soap, "ns1:closeSyncTransactionRequest", -1, &a->ns1__closeSyncTransactionRequest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__closeSyncTransaction * SOAP_FMAC4 soap_in___ns1__closeSyncTransaction(struct soap *soap, const char *tag, struct __ns1__closeSyncTransaction *a, const char *type)
{
	size_t soap_flag_ns1__closeSyncTransactionRequest_ = 1;
	short soap_flag;
	a = (struct __ns1__closeSyncTransaction *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__closeSyncTransaction, sizeof(struct __ns1__closeSyncTransaction), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__closeSyncTransaction(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__closeSyncTransactionRequest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sessionRequest(soap, "ns1:closeSyncTransactionRequest", &a->ns1__closeSyncTransactionRequest_, "ns1:sessionRequest"))
				{	soap_flag_ns1__closeSyncTransactionRequest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__closeSyncTransaction(struct soap *soap, const struct __ns1__closeSyncTransaction *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__closeSyncTransaction(soap, tag?tag:"-ns1:closeSyncTransaction", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__closeSyncTransaction * SOAP_FMAC4 soap_get___ns1__closeSyncTransaction(struct soap *soap, struct __ns1__closeSyncTransaction *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__closeSyncTransaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__closeSyncTransaction * SOAP_FMAC2 soap_instantiate___ns1__closeSyncTransaction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__closeSyncTransaction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__closeSyncTransaction, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__closeSyncTransaction);
		if (size)
			*size = sizeof(struct __ns1__closeSyncTransaction);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__closeSyncTransaction[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__closeSyncTransaction);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__closeSyncTransaction*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__closeSyncTransaction(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__closeSyncTransaction %p -> %p\n", q, p));
	*(struct __ns1__closeSyncTransaction*)p = *(struct __ns1__closeSyncTransaction*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateStock(struct soap *soap, struct __ns1__updateStock *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__updateStockRequest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateStock(struct soap *soap, const struct __ns1__updateStock *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__updateStockRequest(soap, &a->ns1__updateStockRequest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateStock(struct soap *soap, const char *tag, int id, const struct __ns1__updateStock *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__updateStockRequest(soap, "ns1:updateStockRequest", -1, &a->ns1__updateStockRequest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateStock * SOAP_FMAC4 soap_in___ns1__updateStock(struct soap *soap, const char *tag, struct __ns1__updateStock *a, const char *type)
{
	size_t soap_flag_ns1__updateStockRequest_ = 1;
	short soap_flag;
	a = (struct __ns1__updateStock *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateStock, sizeof(struct __ns1__updateStock), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateStock(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__updateStockRequest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__updateStockRequest(soap, "ns1:updateStockRequest", &a->ns1__updateStockRequest_, "ns1:updateStockRequest"))
				{	soap_flag_ns1__updateStockRequest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateStock(struct soap *soap, const struct __ns1__updateStock *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__updateStock(soap, tag?tag:"-ns1:updateStock", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateStock * SOAP_FMAC4 soap_get___ns1__updateStock(struct soap *soap, struct __ns1__updateStock *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateStock(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__updateStock * SOAP_FMAC2 soap_instantiate___ns1__updateStock(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__updateStock(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__updateStock, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__updateStock);
		if (size)
			*size = sizeof(struct __ns1__updateStock);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__updateStock[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__updateStock);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__updateStock*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__updateStock(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__updateStock %p -> %p\n", q, p));
	*(struct __ns1__updateStock*)p = *(struct __ns1__updateStock*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__updateHent(struct soap *soap, struct __ns1__updateHent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__updateHentRequest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__updateHent(struct soap *soap, const struct __ns1__updateHent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__updateHentRequest(soap, &a->ns1__updateHentRequest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__updateHent(struct soap *soap, const char *tag, int id, const struct __ns1__updateHent *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__updateHentRequest(soap, "ns1:updateHentRequest", -1, &a->ns1__updateHentRequest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateHent * SOAP_FMAC4 soap_in___ns1__updateHent(struct soap *soap, const char *tag, struct __ns1__updateHent *a, const char *type)
{
	size_t soap_flag_ns1__updateHentRequest_ = 1;
	short soap_flag;
	a = (struct __ns1__updateHent *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__updateHent, sizeof(struct __ns1__updateHent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__updateHent(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__updateHentRequest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__updateHentRequest(soap, "ns1:updateHentRequest", &a->ns1__updateHentRequest_, "ns1:updateHentRequest"))
				{	soap_flag_ns1__updateHentRequest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__updateHent(struct soap *soap, const struct __ns1__updateHent *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__updateHent(soap, tag?tag:"-ns1:updateHent", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__updateHent * SOAP_FMAC4 soap_get___ns1__updateHent(struct soap *soap, struct __ns1__updateHent *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__updateHent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__updateHent * SOAP_FMAC2 soap_instantiate___ns1__updateHent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__updateHent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__updateHent, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__updateHent);
		if (size)
			*size = sizeof(struct __ns1__updateHent);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__updateHent[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__updateHent);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__updateHent*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__updateHent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__updateHent %p -> %p\n", q, p));
	*(struct __ns1__updateHent*)p = *(struct __ns1__updateHent*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__openSyncTransaction(struct soap *soap, struct __ns1__openSyncTransaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__openSyncTransactionRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__openSyncTransaction(struct soap *soap, const struct __ns1__openSyncTransaction *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__sessionRequest(soap, &a->ns1__openSyncTransactionRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__openSyncTransaction(struct soap *soap, const char *tag, int id, const struct __ns1__openSyncTransaction *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__sessionRequest(soap, "ns1:openSyncTransactionRequest", -1, &a->ns1__openSyncTransactionRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__openSyncTransaction * SOAP_FMAC4 soap_in___ns1__openSyncTransaction(struct soap *soap, const char *tag, struct __ns1__openSyncTransaction *a, const char *type)
{
	size_t soap_flag_ns1__openSyncTransactionRequest = 1;
	short soap_flag;
	a = (struct __ns1__openSyncTransaction *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__openSyncTransaction, sizeof(struct __ns1__openSyncTransaction), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__openSyncTransaction(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__openSyncTransactionRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sessionRequest(soap, "ns1:openSyncTransactionRequest", &a->ns1__openSyncTransactionRequest, "ns1:sessionRequest"))
				{	soap_flag_ns1__openSyncTransactionRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__openSyncTransaction(struct soap *soap, const struct __ns1__openSyncTransaction *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__openSyncTransaction(soap, tag?tag:"-ns1:openSyncTransaction", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__openSyncTransaction * SOAP_FMAC4 soap_get___ns1__openSyncTransaction(struct soap *soap, struct __ns1__openSyncTransaction *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__openSyncTransaction(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__openSyncTransaction * SOAP_FMAC2 soap_instantiate___ns1__openSyncTransaction(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__openSyncTransaction(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__openSyncTransaction, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__openSyncTransaction);
		if (size)
			*size = sizeof(struct __ns1__openSyncTransaction);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__openSyncTransaction[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__openSyncTransaction);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__openSyncTransaction*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__openSyncTransaction(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__openSyncTransaction %p -> %p\n", q, p));
	*(struct __ns1__openSyncTransaction*)p = *(struct __ns1__openSyncTransaction*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__closeHentCursor(struct soap *soap, struct __ns1__closeHentCursor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__closeHentCursorRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__closeHentCursor(struct soap *soap, const struct __ns1__closeHentCursor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__sessionRequest(soap, &a->ns1__closeHentCursorRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__closeHentCursor(struct soap *soap, const char *tag, int id, const struct __ns1__closeHentCursor *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__sessionRequest(soap, "ns1:closeHentCursorRequest", -1, &a->ns1__closeHentCursorRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__closeHentCursor * SOAP_FMAC4 soap_in___ns1__closeHentCursor(struct soap *soap, const char *tag, struct __ns1__closeHentCursor *a, const char *type)
{
	size_t soap_flag_ns1__closeHentCursorRequest = 1;
	short soap_flag;
	a = (struct __ns1__closeHentCursor *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__closeHentCursor, sizeof(struct __ns1__closeHentCursor), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__closeHentCursor(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__closeHentCursorRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sessionRequest(soap, "ns1:closeHentCursorRequest", &a->ns1__closeHentCursorRequest, "ns1:sessionRequest"))
				{	soap_flag_ns1__closeHentCursorRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__closeHentCursor(struct soap *soap, const struct __ns1__closeHentCursor *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__closeHentCursor(soap, tag?tag:"-ns1:closeHentCursor", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__closeHentCursor * SOAP_FMAC4 soap_get___ns1__closeHentCursor(struct soap *soap, struct __ns1__closeHentCursor *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__closeHentCursor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__closeHentCursor * SOAP_FMAC2 soap_instantiate___ns1__closeHentCursor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__closeHentCursor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__closeHentCursor, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__closeHentCursor);
		if (size)
			*size = sizeof(struct __ns1__closeHentCursor);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__closeHentCursor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__closeHentCursor);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__closeHentCursor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__closeHentCursor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__closeHentCursor %p -> %p\n", q, p));
	*(struct __ns1__closeHentCursor*)p = *(struct __ns1__closeHentCursor*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__fetchHents(struct soap *soap, struct __ns1__fetchHents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__fetchHentsRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__fetchHents(struct soap *soap, const struct __ns1__fetchHents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__cursorRequest(soap, &a->ns1__fetchHentsRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__fetchHents(struct soap *soap, const char *tag, int id, const struct __ns1__fetchHents *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__cursorRequest(soap, "ns1:fetchHentsRequest", -1, &a->ns1__fetchHentsRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__fetchHents * SOAP_FMAC4 soap_in___ns1__fetchHents(struct soap *soap, const char *tag, struct __ns1__fetchHents *a, const char *type)
{
	size_t soap_flag_ns1__fetchHentsRequest = 1;
	short soap_flag;
	a = (struct __ns1__fetchHents *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__fetchHents, sizeof(struct __ns1__fetchHents), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__fetchHents(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__fetchHentsRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__cursorRequest(soap, "ns1:fetchHentsRequest", &a->ns1__fetchHentsRequest, "ns1:cursorRequest"))
				{	soap_flag_ns1__fetchHentsRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__fetchHents(struct soap *soap, const struct __ns1__fetchHents *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__fetchHents(soap, tag?tag:"-ns1:fetchHents", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__fetchHents * SOAP_FMAC4 soap_get___ns1__fetchHents(struct soap *soap, struct __ns1__fetchHents *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__fetchHents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__fetchHents * SOAP_FMAC2 soap_instantiate___ns1__fetchHents(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__fetchHents(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__fetchHents, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__fetchHents);
		if (size)
			*size = sizeof(struct __ns1__fetchHents);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__fetchHents[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__fetchHents);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__fetchHents*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__fetchHents(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__fetchHents %p -> %p\n", q, p));
	*(struct __ns1__fetchHents*)p = *(struct __ns1__fetchHents*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__openHentCursor(struct soap *soap, struct __ns1__openHentCursor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__openHentCursorRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__openHentCursor(struct soap *soap, const struct __ns1__openHentCursor *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__sessionRequest(soap, &a->ns1__openHentCursorRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__openHentCursor(struct soap *soap, const char *tag, int id, const struct __ns1__openHentCursor *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__sessionRequest(soap, "ns1:openHentCursorRequest", -1, &a->ns1__openHentCursorRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__openHentCursor * SOAP_FMAC4 soap_in___ns1__openHentCursor(struct soap *soap, const char *tag, struct __ns1__openHentCursor *a, const char *type)
{
	size_t soap_flag_ns1__openHentCursorRequest = 1;
	short soap_flag;
	a = (struct __ns1__openHentCursor *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__openHentCursor, sizeof(struct __ns1__openHentCursor), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__openHentCursor(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__openHentCursorRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sessionRequest(soap, "ns1:openHentCursorRequest", &a->ns1__openHentCursorRequest, "ns1:sessionRequest"))
				{	soap_flag_ns1__openHentCursorRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__openHentCursor(struct soap *soap, const struct __ns1__openHentCursor *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__openHentCursor(soap, tag?tag:"-ns1:openHentCursor", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__openHentCursor * SOAP_FMAC4 soap_get___ns1__openHentCursor(struct soap *soap, struct __ns1__openHentCursor *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__openHentCursor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__openHentCursor * SOAP_FMAC2 soap_instantiate___ns1__openHentCursor(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__openHentCursor(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__openHentCursor, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__openHentCursor);
		if (size)
			*size = sizeof(struct __ns1__openHentCursor);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__openHentCursor[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__openHentCursor);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__openHentCursor*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__openHentCursor(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__openHentCursor %p -> %p\n", q, p));
	*(struct __ns1__openHentCursor*)p = *(struct __ns1__openHentCursor*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__closeSession(struct soap *soap, struct __ns1__closeSession *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__closeSessionRequest = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__closeSession(struct soap *soap, const struct __ns1__closeSession *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__sessionRequest(soap, &a->ns1__closeSessionRequest);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__closeSession(struct soap *soap, const char *tag, int id, const struct __ns1__closeSession *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__sessionRequest(soap, "ns1:closeSessionRequest", -1, &a->ns1__closeSessionRequest, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__closeSession * SOAP_FMAC4 soap_in___ns1__closeSession(struct soap *soap, const char *tag, struct __ns1__closeSession *a, const char *type)
{
	size_t soap_flag_ns1__closeSessionRequest = 1;
	short soap_flag;
	a = (struct __ns1__closeSession *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__closeSession, sizeof(struct __ns1__closeSession), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__closeSession(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__closeSessionRequest && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__sessionRequest(soap, "ns1:closeSessionRequest", &a->ns1__closeSessionRequest, "ns1:sessionRequest"))
				{	soap_flag_ns1__closeSessionRequest--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__closeSession(struct soap *soap, const struct __ns1__closeSession *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__closeSession(soap, tag?tag:"-ns1:closeSession", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__closeSession * SOAP_FMAC4 soap_get___ns1__closeSession(struct soap *soap, struct __ns1__closeSession *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__closeSession(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__closeSession * SOAP_FMAC2 soap_instantiate___ns1__closeSession(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__closeSession(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__closeSession, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__closeSession);
		if (size)
			*size = sizeof(struct __ns1__closeSession);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__closeSession[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__closeSession);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__closeSession*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__closeSession(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__closeSession %p -> %p\n", q, p));
	*(struct __ns1__closeSession*)p = *(struct __ns1__closeSession*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__openOfficeSession(struct soap *soap, struct __ns1__openOfficeSession *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__openOfficeSessionRequest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__openOfficeSession(struct soap *soap, const struct __ns1__openOfficeSession *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__openOfficeSessionRequest(soap, &a->ns1__openOfficeSessionRequest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__openOfficeSession(struct soap *soap, const char *tag, int id, const struct __ns1__openOfficeSession *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__openOfficeSessionRequest(soap, "ns1:openOfficeSessionRequest", -1, &a->ns1__openOfficeSessionRequest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__openOfficeSession * SOAP_FMAC4 soap_in___ns1__openOfficeSession(struct soap *soap, const char *tag, struct __ns1__openOfficeSession *a, const char *type)
{
	size_t soap_flag_ns1__openOfficeSessionRequest_ = 1;
	short soap_flag;
	a = (struct __ns1__openOfficeSession *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__openOfficeSession, sizeof(struct __ns1__openOfficeSession), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__openOfficeSession(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__openOfficeSessionRequest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__openOfficeSessionRequest(soap, "ns1:openOfficeSessionRequest", &a->ns1__openOfficeSessionRequest_, "ns1:openOfficeSessionRequest"))
				{	soap_flag_ns1__openOfficeSessionRequest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__openOfficeSession(struct soap *soap, const struct __ns1__openOfficeSession *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__openOfficeSession(soap, tag?tag:"-ns1:openOfficeSession", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__openOfficeSession * SOAP_FMAC4 soap_get___ns1__openOfficeSession(struct soap *soap, struct __ns1__openOfficeSession *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__openOfficeSession(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__openOfficeSession * SOAP_FMAC2 soap_instantiate___ns1__openOfficeSession(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__openOfficeSession(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__openOfficeSession, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__openOfficeSession);
		if (size)
			*size = sizeof(struct __ns1__openOfficeSession);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__openOfficeSession[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__openOfficeSession);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__openOfficeSession*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__openOfficeSession(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__openOfficeSession %p -> %p\n", q, p));
	*(struct __ns1__openOfficeSession*)p = *(struct __ns1__openOfficeSession*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___ns1__openMobileSession(struct soap *soap, struct __ns1__openMobileSession *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ns1__openMobileSessionRequest_ = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___ns1__openMobileSession(struct soap *soap, const struct __ns1__openMobileSession *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__openMobileSessionRequest(soap, &a->ns1__openMobileSessionRequest_);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___ns1__openMobileSession(struct soap *soap, const char *tag, int id, const struct __ns1__openMobileSession *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTons1__openMobileSessionRequest(soap, "ns1:openMobileSessionRequest", -1, &a->ns1__openMobileSessionRequest_, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__openMobileSession * SOAP_FMAC4 soap_in___ns1__openMobileSession(struct soap *soap, const char *tag, struct __ns1__openMobileSession *a, const char *type)
{
	size_t soap_flag_ns1__openMobileSessionRequest_ = 1;
	short soap_flag;
	a = (struct __ns1__openMobileSession *)soap_id_enter(soap, "", a, SOAP_TYPE___ns1__openMobileSession, sizeof(struct __ns1__openMobileSession), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___ns1__openMobileSession(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ns1__openMobileSessionRequest_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__openMobileSessionRequest(soap, "ns1:openMobileSessionRequest", &a->ns1__openMobileSessionRequest_, "ns1:openMobileSessionRequest"))
				{	soap_flag_ns1__openMobileSessionRequest_--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___ns1__openMobileSession(struct soap *soap, const struct __ns1__openMobileSession *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___ns1__openMobileSession(soap, tag?tag:"-ns1:openMobileSession", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __ns1__openMobileSession * SOAP_FMAC4 soap_get___ns1__openMobileSession(struct soap *soap, struct __ns1__openMobileSession *p, const char *tag, const char *type)
{
	if ((p = soap_in___ns1__openMobileSession(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __ns1__openMobileSession * SOAP_FMAC2 soap_instantiate___ns1__openMobileSession(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___ns1__openMobileSession(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___ns1__openMobileSession, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__openMobileSession);
		if (size)
			*size = sizeof(struct __ns1__openMobileSession);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(struct __ns1__openMobileSession[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct __ns1__openMobileSession);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct __ns1__openMobileSession*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___ns1__openMobileSession(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __ns1__openMobileSession %p -> %p\n", q, p));
	*(struct __ns1__openMobileSession*)p = *(struct __ns1__openMobileSession*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__downloadPurchaseResponse(struct soap *soap, ns1__downloadPurchaseResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__downloadPurchaseResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__downloadPurchaseResponse(struct soap *soap, const char *tag, int id, ns1__downloadPurchaseResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__downloadPurchaseResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__downloadPurchaseResponse ** SOAP_FMAC4 soap_in_PointerTons1__downloadPurchaseResponse(struct soap *soap, const char *tag, ns1__downloadPurchaseResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__downloadPurchaseResponse **)soap_malloc(soap, sizeof(ns1__downloadPurchaseResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__downloadPurchaseResponse *)soap_instantiate_ns1__downloadPurchaseResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__downloadPurchaseResponse ** p = (ns1__downloadPurchaseResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__downloadPurchaseResponse, sizeof(ns1__downloadPurchaseResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__downloadPurchaseResponse(struct soap *soap, ns1__downloadPurchaseResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__downloadPurchaseResponse);
	if (soap_out_PointerTons1__downloadPurchaseResponse(soap, tag?tag:"ns1:downloadPurchaseResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__downloadPurchaseResponse ** SOAP_FMAC4 soap_get_PointerTons1__downloadPurchaseResponse(struct soap *soap, ns1__downloadPurchaseResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__downloadPurchaseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__downloadPurchaseRequest(struct soap *soap, ns1__downloadPurchaseRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__downloadPurchaseRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__downloadPurchaseRequest(struct soap *soap, const char *tag, int id, ns1__downloadPurchaseRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__downloadPurchaseRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__downloadPurchaseRequest ** SOAP_FMAC4 soap_in_PointerTons1__downloadPurchaseRequest(struct soap *soap, const char *tag, ns1__downloadPurchaseRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__downloadPurchaseRequest **)soap_malloc(soap, sizeof(ns1__downloadPurchaseRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__downloadPurchaseRequest *)soap_instantiate_ns1__downloadPurchaseRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__downloadPurchaseRequest ** p = (ns1__downloadPurchaseRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__downloadPurchaseRequest, sizeof(ns1__downloadPurchaseRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__downloadPurchaseRequest(struct soap *soap, ns1__downloadPurchaseRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__downloadPurchaseRequest);
	if (soap_out_PointerTons1__downloadPurchaseRequest(soap, tag?tag:"ns1:downloadPurchaseRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__downloadPurchaseRequest ** SOAP_FMAC4 soap_get_PointerTons1__downloadPurchaseRequest(struct soap *soap, ns1__downloadPurchaseRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__downloadPurchaseRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__fetchPurchasesResponse(struct soap *soap, ns1__fetchPurchasesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__fetchPurchasesResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__fetchPurchasesResponse(struct soap *soap, const char *tag, int id, ns1__fetchPurchasesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__fetchPurchasesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__fetchPurchasesResponse ** SOAP_FMAC4 soap_in_PointerTons1__fetchPurchasesResponse(struct soap *soap, const char *tag, ns1__fetchPurchasesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__fetchPurchasesResponse **)soap_malloc(soap, sizeof(ns1__fetchPurchasesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__fetchPurchasesResponse *)soap_instantiate_ns1__fetchPurchasesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__fetchPurchasesResponse ** p = (ns1__fetchPurchasesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__fetchPurchasesResponse, sizeof(ns1__fetchPurchasesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__fetchPurchasesResponse(struct soap *soap, ns1__fetchPurchasesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__fetchPurchasesResponse);
	if (soap_out_PointerTons1__fetchPurchasesResponse(soap, tag?tag:"ns1:fetchPurchasesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__fetchPurchasesResponse ** SOAP_FMAC4 soap_get_PointerTons1__fetchPurchasesResponse(struct soap *soap, ns1__fetchPurchasesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__fetchPurchasesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__closePurchaseCursorResponse(struct soap *soap, ns1__closePurchaseCursorResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__closePurchaseCursorResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__closePurchaseCursorResponse(struct soap *soap, const char *tag, int id, ns1__closePurchaseCursorResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__closePurchaseCursorResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__closePurchaseCursorResponse ** SOAP_FMAC4 soap_in_PointerTons1__closePurchaseCursorResponse(struct soap *soap, const char *tag, ns1__closePurchaseCursorResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__closePurchaseCursorResponse **)soap_malloc(soap, sizeof(ns1__closePurchaseCursorResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__closePurchaseCursorResponse *)soap_instantiate_ns1__closePurchaseCursorResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__closePurchaseCursorResponse ** p = (ns1__closePurchaseCursorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__closePurchaseCursorResponse, sizeof(ns1__closePurchaseCursorResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__closePurchaseCursorResponse(struct soap *soap, ns1__closePurchaseCursorResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__closePurchaseCursorResponse);
	if (soap_out_PointerTons1__closePurchaseCursorResponse(soap, tag?tag:"ns1:closePurchaseCursorResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__closePurchaseCursorResponse ** SOAP_FMAC4 soap_get_PointerTons1__closePurchaseCursorResponse(struct soap *soap, ns1__closePurchaseCursorResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__closePurchaseCursorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__openPurchaseCursorResponse(struct soap *soap, ns1__openPurchaseCursorResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__openPurchaseCursorResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__openPurchaseCursorResponse(struct soap *soap, const char *tag, int id, ns1__openPurchaseCursorResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__openPurchaseCursorResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__openPurchaseCursorResponse ** SOAP_FMAC4 soap_in_PointerTons1__openPurchaseCursorResponse(struct soap *soap, const char *tag, ns1__openPurchaseCursorResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__openPurchaseCursorResponse **)soap_malloc(soap, sizeof(ns1__openPurchaseCursorResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__openPurchaseCursorResponse *)soap_instantiate_ns1__openPurchaseCursorResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__openPurchaseCursorResponse ** p = (ns1__openPurchaseCursorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__openPurchaseCursorResponse, sizeof(ns1__openPurchaseCursorResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__openPurchaseCursorResponse(struct soap *soap, ns1__openPurchaseCursorResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__openPurchaseCursorResponse);
	if (soap_out_PointerTons1__openPurchaseCursorResponse(soap, tag?tag:"ns1:openPurchaseCursorResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__openPurchaseCursorResponse ** SOAP_FMAC4 soap_get_PointerTons1__openPurchaseCursorResponse(struct soap *soap, ns1__openPurchaseCursorResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__openPurchaseCursorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__uploadPurchaseResponse(struct soap *soap, ns1__uploadPurchaseResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__uploadPurchaseResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__uploadPurchaseResponse(struct soap *soap, const char *tag, int id, ns1__uploadPurchaseResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__uploadPurchaseResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__uploadPurchaseResponse ** SOAP_FMAC4 soap_in_PointerTons1__uploadPurchaseResponse(struct soap *soap, const char *tag, ns1__uploadPurchaseResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__uploadPurchaseResponse **)soap_malloc(soap, sizeof(ns1__uploadPurchaseResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__uploadPurchaseResponse *)soap_instantiate_ns1__uploadPurchaseResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__uploadPurchaseResponse ** p = (ns1__uploadPurchaseResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__uploadPurchaseResponse, sizeof(ns1__uploadPurchaseResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__uploadPurchaseResponse(struct soap *soap, ns1__uploadPurchaseResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__uploadPurchaseResponse);
	if (soap_out_PointerTons1__uploadPurchaseResponse(soap, tag?tag:"ns1:uploadPurchaseResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__uploadPurchaseResponse ** SOAP_FMAC4 soap_get_PointerTons1__uploadPurchaseResponse(struct soap *soap, ns1__uploadPurchaseResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__uploadPurchaseResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__uploadPurchaseRequest(struct soap *soap, ns1__uploadPurchaseRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__uploadPurchaseRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__uploadPurchaseRequest(struct soap *soap, const char *tag, int id, ns1__uploadPurchaseRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__uploadPurchaseRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__uploadPurchaseRequest ** SOAP_FMAC4 soap_in_PointerTons1__uploadPurchaseRequest(struct soap *soap, const char *tag, ns1__uploadPurchaseRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__uploadPurchaseRequest **)soap_malloc(soap, sizeof(ns1__uploadPurchaseRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__uploadPurchaseRequest *)soap_instantiate_ns1__uploadPurchaseRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__uploadPurchaseRequest ** p = (ns1__uploadPurchaseRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__uploadPurchaseRequest, sizeof(ns1__uploadPurchaseRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__uploadPurchaseRequest(struct soap *soap, ns1__uploadPurchaseRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__uploadPurchaseRequest);
	if (soap_out_PointerTons1__uploadPurchaseRequest(soap, tag?tag:"ns1:uploadPurchaseRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__uploadPurchaseRequest ** SOAP_FMAC4 soap_get_PointerTons1__uploadPurchaseRequest(struct soap *soap, ns1__uploadPurchaseRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__uploadPurchaseRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__fetchCompanyResponse(struct soap *soap, ns1__fetchCompanyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__fetchCompanyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__fetchCompanyResponse(struct soap *soap, const char *tag, int id, ns1__fetchCompanyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__fetchCompanyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__fetchCompanyResponse ** SOAP_FMAC4 soap_in_PointerTons1__fetchCompanyResponse(struct soap *soap, const char *tag, ns1__fetchCompanyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__fetchCompanyResponse **)soap_malloc(soap, sizeof(ns1__fetchCompanyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__fetchCompanyResponse *)soap_instantiate_ns1__fetchCompanyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__fetchCompanyResponse ** p = (ns1__fetchCompanyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__fetchCompanyResponse, sizeof(ns1__fetchCompanyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__fetchCompanyResponse(struct soap *soap, ns1__fetchCompanyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__fetchCompanyResponse);
	if (soap_out_PointerTons1__fetchCompanyResponse(soap, tag?tag:"ns1:fetchCompanyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__fetchCompanyResponse ** SOAP_FMAC4 soap_get_PointerTons1__fetchCompanyResponse(struct soap *soap, ns1__fetchCompanyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__fetchCompanyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__updateCompanyResponse(struct soap *soap, ns1__updateCompanyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__updateCompanyResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__updateCompanyResponse(struct soap *soap, const char *tag, int id, ns1__updateCompanyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__updateCompanyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__updateCompanyResponse ** SOAP_FMAC4 soap_in_PointerTons1__updateCompanyResponse(struct soap *soap, const char *tag, ns1__updateCompanyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__updateCompanyResponse **)soap_malloc(soap, sizeof(ns1__updateCompanyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__updateCompanyResponse *)soap_instantiate_ns1__updateCompanyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__updateCompanyResponse ** p = (ns1__updateCompanyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__updateCompanyResponse, sizeof(ns1__updateCompanyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__updateCompanyResponse(struct soap *soap, ns1__updateCompanyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__updateCompanyResponse);
	if (soap_out_PointerTons1__updateCompanyResponse(soap, tag?tag:"ns1:updateCompanyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__updateCompanyResponse ** SOAP_FMAC4 soap_get_PointerTons1__updateCompanyResponse(struct soap *soap, ns1__updateCompanyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__updateCompanyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__updateCompanyRequest(struct soap *soap, ns1__updateCompanyRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__updateCompanyRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__updateCompanyRequest(struct soap *soap, const char *tag, int id, ns1__updateCompanyRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__updateCompanyRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__updateCompanyRequest ** SOAP_FMAC4 soap_in_PointerTons1__updateCompanyRequest(struct soap *soap, const char *tag, ns1__updateCompanyRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__updateCompanyRequest **)soap_malloc(soap, sizeof(ns1__updateCompanyRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__updateCompanyRequest *)soap_instantiate_ns1__updateCompanyRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__updateCompanyRequest ** p = (ns1__updateCompanyRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__updateCompanyRequest, sizeof(ns1__updateCompanyRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__updateCompanyRequest(struct soap *soap, ns1__updateCompanyRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__updateCompanyRequest);
	if (soap_out_PointerTons1__updateCompanyRequest(soap, tag?tag:"ns1:updateCompanyRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__updateCompanyRequest ** SOAP_FMAC4 soap_get_PointerTons1__updateCompanyRequest(struct soap *soap, ns1__updateCompanyRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__updateCompanyRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__closeStockCursorResponse(struct soap *soap, ns1__closeStockCursorResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__closeStockCursorResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__closeStockCursorResponse(struct soap *soap, const char *tag, int id, ns1__closeStockCursorResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__closeStockCursorResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__closeStockCursorResponse ** SOAP_FMAC4 soap_in_PointerTons1__closeStockCursorResponse(struct soap *soap, const char *tag, ns1__closeStockCursorResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__closeStockCursorResponse **)soap_malloc(soap, sizeof(ns1__closeStockCursorResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__closeStockCursorResponse *)soap_instantiate_ns1__closeStockCursorResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__closeStockCursorResponse ** p = (ns1__closeStockCursorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__closeStockCursorResponse, sizeof(ns1__closeStockCursorResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__closeStockCursorResponse(struct soap *soap, ns1__closeStockCursorResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__closeStockCursorResponse);
	if (soap_out_PointerTons1__closeStockCursorResponse(soap, tag?tag:"ns1:closeStockCursorResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__closeStockCursorResponse ** SOAP_FMAC4 soap_get_PointerTons1__closeStockCursorResponse(struct soap *soap, ns1__closeStockCursorResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__closeStockCursorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__fetchStocksResponse(struct soap *soap, ns1__fetchStocksResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__fetchStocksResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__fetchStocksResponse(struct soap *soap, const char *tag, int id, ns1__fetchStocksResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__fetchStocksResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__fetchStocksResponse ** SOAP_FMAC4 soap_in_PointerTons1__fetchStocksResponse(struct soap *soap, const char *tag, ns1__fetchStocksResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__fetchStocksResponse **)soap_malloc(soap, sizeof(ns1__fetchStocksResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__fetchStocksResponse *)soap_instantiate_ns1__fetchStocksResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__fetchStocksResponse ** p = (ns1__fetchStocksResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__fetchStocksResponse, sizeof(ns1__fetchStocksResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__fetchStocksResponse(struct soap *soap, ns1__fetchStocksResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__fetchStocksResponse);
	if (soap_out_PointerTons1__fetchStocksResponse(soap, tag?tag:"ns1:fetchStocksResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__fetchStocksResponse ** SOAP_FMAC4 soap_get_PointerTons1__fetchStocksResponse(struct soap *soap, ns1__fetchStocksResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__fetchStocksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__openStockCursorResponse(struct soap *soap, ns1__openStockCursorResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__openStockCursorResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__openStockCursorResponse(struct soap *soap, const char *tag, int id, ns1__openStockCursorResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__openStockCursorResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__openStockCursorResponse ** SOAP_FMAC4 soap_in_PointerTons1__openStockCursorResponse(struct soap *soap, const char *tag, ns1__openStockCursorResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__openStockCursorResponse **)soap_malloc(soap, sizeof(ns1__openStockCursorResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__openStockCursorResponse *)soap_instantiate_ns1__openStockCursorResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__openStockCursorResponse ** p = (ns1__openStockCursorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__openStockCursorResponse, sizeof(ns1__openStockCursorResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__openStockCursorResponse(struct soap *soap, ns1__openStockCursorResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__openStockCursorResponse);
	if (soap_out_PointerTons1__openStockCursorResponse(soap, tag?tag:"ns1:openStockCursorResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__openStockCursorResponse ** SOAP_FMAC4 soap_get_PointerTons1__openStockCursorResponse(struct soap *soap, ns1__openStockCursorResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__openStockCursorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__commitSyncTransactionResponse(struct soap *soap, ns1__commitSyncTransactionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__commitSyncTransactionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__commitSyncTransactionResponse(struct soap *soap, const char *tag, int id, ns1__commitSyncTransactionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__commitSyncTransactionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__commitSyncTransactionResponse ** SOAP_FMAC4 soap_in_PointerTons1__commitSyncTransactionResponse(struct soap *soap, const char *tag, ns1__commitSyncTransactionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__commitSyncTransactionResponse **)soap_malloc(soap, sizeof(ns1__commitSyncTransactionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__commitSyncTransactionResponse *)soap_instantiate_ns1__commitSyncTransactionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__commitSyncTransactionResponse ** p = (ns1__commitSyncTransactionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__commitSyncTransactionResponse, sizeof(ns1__commitSyncTransactionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__commitSyncTransactionResponse(struct soap *soap, ns1__commitSyncTransactionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__commitSyncTransactionResponse);
	if (soap_out_PointerTons1__commitSyncTransactionResponse(soap, tag?tag:"ns1:commitSyncTransactionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__commitSyncTransactionResponse ** SOAP_FMAC4 soap_get_PointerTons1__commitSyncTransactionResponse(struct soap *soap, ns1__commitSyncTransactionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__commitSyncTransactionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__closeSyncTransactionResponse(struct soap *soap, ns1__closeSyncTransactionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__closeSyncTransactionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__closeSyncTransactionResponse(struct soap *soap, const char *tag, int id, ns1__closeSyncTransactionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__closeSyncTransactionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__closeSyncTransactionResponse ** SOAP_FMAC4 soap_in_PointerTons1__closeSyncTransactionResponse(struct soap *soap, const char *tag, ns1__closeSyncTransactionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__closeSyncTransactionResponse **)soap_malloc(soap, sizeof(ns1__closeSyncTransactionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__closeSyncTransactionResponse *)soap_instantiate_ns1__closeSyncTransactionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__closeSyncTransactionResponse ** p = (ns1__closeSyncTransactionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__closeSyncTransactionResponse, sizeof(ns1__closeSyncTransactionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__closeSyncTransactionResponse(struct soap *soap, ns1__closeSyncTransactionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__closeSyncTransactionResponse);
	if (soap_out_PointerTons1__closeSyncTransactionResponse(soap, tag?tag:"ns1:closeSyncTransactionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__closeSyncTransactionResponse ** SOAP_FMAC4 soap_get_PointerTons1__closeSyncTransactionResponse(struct soap *soap, ns1__closeSyncTransactionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__closeSyncTransactionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__updateStockResponse(struct soap *soap, ns1__updateStockResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__updateStockResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__updateStockResponse(struct soap *soap, const char *tag, int id, ns1__updateStockResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__updateStockResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__updateStockResponse ** SOAP_FMAC4 soap_in_PointerTons1__updateStockResponse(struct soap *soap, const char *tag, ns1__updateStockResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__updateStockResponse **)soap_malloc(soap, sizeof(ns1__updateStockResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__updateStockResponse *)soap_instantiate_ns1__updateStockResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__updateStockResponse ** p = (ns1__updateStockResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__updateStockResponse, sizeof(ns1__updateStockResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__updateStockResponse(struct soap *soap, ns1__updateStockResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__updateStockResponse);
	if (soap_out_PointerTons1__updateStockResponse(soap, tag?tag:"ns1:updateStockResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__updateStockResponse ** SOAP_FMAC4 soap_get_PointerTons1__updateStockResponse(struct soap *soap, ns1__updateStockResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__updateStockResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__updateStockRequest(struct soap *soap, ns1__updateStockRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__updateStockRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__updateStockRequest(struct soap *soap, const char *tag, int id, ns1__updateStockRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__updateStockRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__updateStockRequest ** SOAP_FMAC4 soap_in_PointerTons1__updateStockRequest(struct soap *soap, const char *tag, ns1__updateStockRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__updateStockRequest **)soap_malloc(soap, sizeof(ns1__updateStockRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__updateStockRequest *)soap_instantiate_ns1__updateStockRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__updateStockRequest ** p = (ns1__updateStockRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__updateStockRequest, sizeof(ns1__updateStockRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__updateStockRequest(struct soap *soap, ns1__updateStockRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__updateStockRequest);
	if (soap_out_PointerTons1__updateStockRequest(soap, tag?tag:"ns1:updateStockRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__updateStockRequest ** SOAP_FMAC4 soap_get_PointerTons1__updateStockRequest(struct soap *soap, ns1__updateStockRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__updateStockRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__updateHentResponse(struct soap *soap, ns1__updateHentResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__updateHentResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__updateHentResponse(struct soap *soap, const char *tag, int id, ns1__updateHentResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__updateHentResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__updateHentResponse ** SOAP_FMAC4 soap_in_PointerTons1__updateHentResponse(struct soap *soap, const char *tag, ns1__updateHentResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__updateHentResponse **)soap_malloc(soap, sizeof(ns1__updateHentResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__updateHentResponse *)soap_instantiate_ns1__updateHentResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__updateHentResponse ** p = (ns1__updateHentResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__updateHentResponse, sizeof(ns1__updateHentResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__updateHentResponse(struct soap *soap, ns1__updateHentResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__updateHentResponse);
	if (soap_out_PointerTons1__updateHentResponse(soap, tag?tag:"ns1:updateHentResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__updateHentResponse ** SOAP_FMAC4 soap_get_PointerTons1__updateHentResponse(struct soap *soap, ns1__updateHentResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__updateHentResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__updateHentRequest(struct soap *soap, ns1__updateHentRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__updateHentRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__updateHentRequest(struct soap *soap, const char *tag, int id, ns1__updateHentRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__updateHentRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__updateHentRequest ** SOAP_FMAC4 soap_in_PointerTons1__updateHentRequest(struct soap *soap, const char *tag, ns1__updateHentRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__updateHentRequest **)soap_malloc(soap, sizeof(ns1__updateHentRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__updateHentRequest *)soap_instantiate_ns1__updateHentRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__updateHentRequest ** p = (ns1__updateHentRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__updateHentRequest, sizeof(ns1__updateHentRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__updateHentRequest(struct soap *soap, ns1__updateHentRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__updateHentRequest);
	if (soap_out_PointerTons1__updateHentRequest(soap, tag?tag:"ns1:updateHentRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__updateHentRequest ** SOAP_FMAC4 soap_get_PointerTons1__updateHentRequest(struct soap *soap, ns1__updateHentRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__updateHentRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__openSyncTransactionResponse(struct soap *soap, ns1__openSyncTransactionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__openSyncTransactionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__openSyncTransactionResponse(struct soap *soap, const char *tag, int id, ns1__openSyncTransactionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__openSyncTransactionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__openSyncTransactionResponse ** SOAP_FMAC4 soap_in_PointerTons1__openSyncTransactionResponse(struct soap *soap, const char *tag, ns1__openSyncTransactionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__openSyncTransactionResponse **)soap_malloc(soap, sizeof(ns1__openSyncTransactionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__openSyncTransactionResponse *)soap_instantiate_ns1__openSyncTransactionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__openSyncTransactionResponse ** p = (ns1__openSyncTransactionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__openSyncTransactionResponse, sizeof(ns1__openSyncTransactionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__openSyncTransactionResponse(struct soap *soap, ns1__openSyncTransactionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__openSyncTransactionResponse);
	if (soap_out_PointerTons1__openSyncTransactionResponse(soap, tag?tag:"ns1:openSyncTransactionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__openSyncTransactionResponse ** SOAP_FMAC4 soap_get_PointerTons1__openSyncTransactionResponse(struct soap *soap, ns1__openSyncTransactionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__openSyncTransactionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__closeHentCursorResponse(struct soap *soap, ns1__closeHentCursorResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__closeHentCursorResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__closeHentCursorResponse(struct soap *soap, const char *tag, int id, ns1__closeHentCursorResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__closeHentCursorResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__closeHentCursorResponse ** SOAP_FMAC4 soap_in_PointerTons1__closeHentCursorResponse(struct soap *soap, const char *tag, ns1__closeHentCursorResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__closeHentCursorResponse **)soap_malloc(soap, sizeof(ns1__closeHentCursorResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__closeHentCursorResponse *)soap_instantiate_ns1__closeHentCursorResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__closeHentCursorResponse ** p = (ns1__closeHentCursorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__closeHentCursorResponse, sizeof(ns1__closeHentCursorResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__closeHentCursorResponse(struct soap *soap, ns1__closeHentCursorResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__closeHentCursorResponse);
	if (soap_out_PointerTons1__closeHentCursorResponse(soap, tag?tag:"ns1:closeHentCursorResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__closeHentCursorResponse ** SOAP_FMAC4 soap_get_PointerTons1__closeHentCursorResponse(struct soap *soap, ns1__closeHentCursorResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__closeHentCursorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__fetchHentsResponse(struct soap *soap, ns1__fetchHentsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__fetchHentsResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__fetchHentsResponse(struct soap *soap, const char *tag, int id, ns1__fetchHentsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__fetchHentsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__fetchHentsResponse ** SOAP_FMAC4 soap_in_PointerTons1__fetchHentsResponse(struct soap *soap, const char *tag, ns1__fetchHentsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__fetchHentsResponse **)soap_malloc(soap, sizeof(ns1__fetchHentsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__fetchHentsResponse *)soap_instantiate_ns1__fetchHentsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__fetchHentsResponse ** p = (ns1__fetchHentsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__fetchHentsResponse, sizeof(ns1__fetchHentsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__fetchHentsResponse(struct soap *soap, ns1__fetchHentsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__fetchHentsResponse);
	if (soap_out_PointerTons1__fetchHentsResponse(soap, tag?tag:"ns1:fetchHentsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__fetchHentsResponse ** SOAP_FMAC4 soap_get_PointerTons1__fetchHentsResponse(struct soap *soap, ns1__fetchHentsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__fetchHentsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__cursorRequest(struct soap *soap, ns1__cursorRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__cursorRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__cursorRequest(struct soap *soap, const char *tag, int id, ns1__cursorRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__cursorRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__cursorRequest ** SOAP_FMAC4 soap_in_PointerTons1__cursorRequest(struct soap *soap, const char *tag, ns1__cursorRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__cursorRequest **)soap_malloc(soap, sizeof(ns1__cursorRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__cursorRequest *)soap_instantiate_ns1__cursorRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__cursorRequest ** p = (ns1__cursorRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__cursorRequest, sizeof(ns1__cursorRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__cursorRequest(struct soap *soap, ns1__cursorRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__cursorRequest);
	if (soap_out_PointerTons1__cursorRequest(soap, tag?tag:"ns1:cursorRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__cursorRequest ** SOAP_FMAC4 soap_get_PointerTons1__cursorRequest(struct soap *soap, ns1__cursorRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__cursorRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__openHentCursorResponse(struct soap *soap, ns1__openHentCursorResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__openHentCursorResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__openHentCursorResponse(struct soap *soap, const char *tag, int id, ns1__openHentCursorResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__openHentCursorResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__openHentCursorResponse ** SOAP_FMAC4 soap_in_PointerTons1__openHentCursorResponse(struct soap *soap, const char *tag, ns1__openHentCursorResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__openHentCursorResponse **)soap_malloc(soap, sizeof(ns1__openHentCursorResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__openHentCursorResponse *)soap_instantiate_ns1__openHentCursorResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__openHentCursorResponse ** p = (ns1__openHentCursorResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__openHentCursorResponse, sizeof(ns1__openHentCursorResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__openHentCursorResponse(struct soap *soap, ns1__openHentCursorResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__openHentCursorResponse);
	if (soap_out_PointerTons1__openHentCursorResponse(soap, tag?tag:"ns1:openHentCursorResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__openHentCursorResponse ** SOAP_FMAC4 soap_get_PointerTons1__openHentCursorResponse(struct soap *soap, ns1__openHentCursorResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__openHentCursorResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__closeSessionResponse(struct soap *soap, ns1__closeSessionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__closeSessionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__closeSessionResponse(struct soap *soap, const char *tag, int id, ns1__closeSessionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__closeSessionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__closeSessionResponse ** SOAP_FMAC4 soap_in_PointerTons1__closeSessionResponse(struct soap *soap, const char *tag, ns1__closeSessionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__closeSessionResponse **)soap_malloc(soap, sizeof(ns1__closeSessionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__closeSessionResponse *)soap_instantiate_ns1__closeSessionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__closeSessionResponse ** p = (ns1__closeSessionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__closeSessionResponse, sizeof(ns1__closeSessionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__closeSessionResponse(struct soap *soap, ns1__closeSessionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__closeSessionResponse);
	if (soap_out_PointerTons1__closeSessionResponse(soap, tag?tag:"ns1:closeSessionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__closeSessionResponse ** SOAP_FMAC4 soap_get_PointerTons1__closeSessionResponse(struct soap *soap, ns1__closeSessionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__closeSessionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__openOfficeSessionRequest(struct soap *soap, ns1__openOfficeSessionRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__openOfficeSessionRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__openOfficeSessionRequest(struct soap *soap, const char *tag, int id, ns1__openOfficeSessionRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__openOfficeSessionRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__openOfficeSessionRequest ** SOAP_FMAC4 soap_in_PointerTons1__openOfficeSessionRequest(struct soap *soap, const char *tag, ns1__openOfficeSessionRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__openOfficeSessionRequest **)soap_malloc(soap, sizeof(ns1__openOfficeSessionRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__openOfficeSessionRequest *)soap_instantiate_ns1__openOfficeSessionRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__openOfficeSessionRequest ** p = (ns1__openOfficeSessionRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__openOfficeSessionRequest, sizeof(ns1__openOfficeSessionRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__openOfficeSessionRequest(struct soap *soap, ns1__openOfficeSessionRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__openOfficeSessionRequest);
	if (soap_out_PointerTons1__openOfficeSessionRequest(soap, tag?tag:"ns1:openOfficeSessionRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__openOfficeSessionRequest ** SOAP_FMAC4 soap_get_PointerTons1__openOfficeSessionRequest(struct soap *soap, ns1__openOfficeSessionRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__openOfficeSessionRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__openSessionResponse(struct soap *soap, ns1__openSessionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__openSessionResponse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__openSessionResponse(struct soap *soap, const char *tag, int id, ns1__openSessionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__openSessionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__openSessionResponse ** SOAP_FMAC4 soap_in_PointerTons1__openSessionResponse(struct soap *soap, const char *tag, ns1__openSessionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__openSessionResponse **)soap_malloc(soap, sizeof(ns1__openSessionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__openSessionResponse *)soap_instantiate_ns1__openSessionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__openSessionResponse ** p = (ns1__openSessionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__openSessionResponse, sizeof(ns1__openSessionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__openSessionResponse(struct soap *soap, ns1__openSessionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__openSessionResponse);
	if (soap_out_PointerTons1__openSessionResponse(soap, tag?tag:"ns1:openSessionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__openSessionResponse ** SOAP_FMAC4 soap_get_PointerTons1__openSessionResponse(struct soap *soap, ns1__openSessionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__openSessionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__openMobileSessionRequest(struct soap *soap, ns1__openMobileSessionRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__openMobileSessionRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__openMobileSessionRequest(struct soap *soap, const char *tag, int id, ns1__openMobileSessionRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__openMobileSessionRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__openMobileSessionRequest ** SOAP_FMAC4 soap_in_PointerTons1__openMobileSessionRequest(struct soap *soap, const char *tag, ns1__openMobileSessionRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__openMobileSessionRequest **)soap_malloc(soap, sizeof(ns1__openMobileSessionRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__openMobileSessionRequest *)soap_instantiate_ns1__openMobileSessionRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__openMobileSessionRequest ** p = (ns1__openMobileSessionRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__openMobileSessionRequest, sizeof(ns1__openMobileSessionRequest), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__openMobileSessionRequest(struct soap *soap, ns1__openMobileSessionRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__openMobileSessionRequest);
	if (soap_out_PointerTons1__openMobileSessionRequest(soap, tag?tag:"ns1:openMobileSessionRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__openMobileSessionRequest ** SOAP_FMAC4 soap_get_PointerTons1__openMobileSessionRequest(struct soap *soap, ns1__openMobileSessionRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__openMobileSessionRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__qualifiedPurchase(struct soap *soap, ns1__qualifiedPurchase *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__qualifiedPurchase))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__qualifiedPurchase(struct soap *soap, const char *tag, int id, ns1__qualifiedPurchase *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__qualifiedPurchase);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__qualifiedPurchase ** SOAP_FMAC4 soap_in_PointerTons1__qualifiedPurchase(struct soap *soap, const char *tag, ns1__qualifiedPurchase **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__qualifiedPurchase **)soap_malloc(soap, sizeof(ns1__qualifiedPurchase *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__qualifiedPurchase *)soap_instantiate_ns1__qualifiedPurchase(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__qualifiedPurchase ** p = (ns1__qualifiedPurchase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__qualifiedPurchase, sizeof(ns1__qualifiedPurchase), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__qualifiedPurchase(struct soap *soap, ns1__qualifiedPurchase *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__qualifiedPurchase);
	if (soap_out_PointerTons1__qualifiedPurchase(soap, tag?tag:"ns1:qualifiedPurchase", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__qualifiedPurchase ** SOAP_FMAC4 soap_get_PointerTons1__qualifiedPurchase(struct soap *soap, ns1__qualifiedPurchase **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__qualifiedPurchase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__purchase(struct soap *soap, ns1__purchase *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__purchase))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__purchase(struct soap *soap, const char *tag, int id, ns1__purchase *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__purchase);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__purchase ** SOAP_FMAC4 soap_in_PointerTons1__purchase(struct soap *soap, const char *tag, ns1__purchase **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__purchase **)soap_malloc(soap, sizeof(ns1__purchase *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__purchase *)soap_instantiate_ns1__purchase(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__purchase ** p = (ns1__purchase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__purchase, sizeof(ns1__purchase), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns1__purchase **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__qualifiedPurchase, sizeof(ns1__qualifiedPurchase), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__purchase(struct soap *soap, ns1__purchase *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__purchase);
	if (soap_out_PointerTons1__purchase(soap, tag?tag:"ns1:purchase", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__purchase ** SOAP_FMAC4 soap_get_PointerTons1__purchase(struct soap *soap, ns1__purchase **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__purchase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__company(struct soap *soap, ns1__company *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__company))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__company(struct soap *soap, const char *tag, int id, ns1__company *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__company);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__company ** SOAP_FMAC4 soap_in_PointerTons1__company(struct soap *soap, const char *tag, ns1__company **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__company **)soap_malloc(soap, sizeof(ns1__company *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__company *)soap_instantiate_ns1__company(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__company ** p = (ns1__company **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__company, sizeof(ns1__company), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__company(struct soap *soap, ns1__company *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__company);
	if (soap_out_PointerTons1__company(soap, tag?tag:"ns1:company", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__company ** SOAP_FMAC4 soap_get_PointerTons1__company(struct soap *soap, ns1__company **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__company(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__stock(struct soap *soap, ns1__stock *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__stock))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__stock(struct soap *soap, const char *tag, int id, ns1__stock *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__stock);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__stock ** SOAP_FMAC4 soap_in_PointerTons1__stock(struct soap *soap, const char *tag, ns1__stock **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__stock **)soap_malloc(soap, sizeof(ns1__stock *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__stock *)soap_instantiate_ns1__stock(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__stock ** p = (ns1__stock **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__stock, sizeof(ns1__stock), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__stock(struct soap *soap, ns1__stock *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__stock);
	if (soap_out_PointerTons1__stock(soap, tag?tag:"ns1:stock", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__stock ** SOAP_FMAC4 soap_get_PointerTons1__stock(struct soap *soap, ns1__stock **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__stock(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__sessionRequest(struct soap *soap, ns1__sessionRequest *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__sessionRequest))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__sessionRequest(struct soap *soap, const char *tag, int id, ns1__sessionRequest *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__sessionRequest);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__sessionRequest ** SOAP_FMAC4 soap_in_PointerTons1__sessionRequest(struct soap *soap, const char *tag, ns1__sessionRequest **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__sessionRequest **)soap_malloc(soap, sizeof(ns1__sessionRequest *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__sessionRequest *)soap_instantiate_ns1__sessionRequest(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__sessionRequest ** p = (ns1__sessionRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__sessionRequest, sizeof(ns1__sessionRequest), 0);
		if (!p && soap->error == SOAP_HREF)
		{	soap->error = SOAP_OK;
			p = (ns1__sessionRequest **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__cursorRequest, sizeof(ns1__cursorRequest), 0);
		}
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__sessionRequest(struct soap *soap, ns1__sessionRequest *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__sessionRequest);
	if (soap_out_PointerTons1__sessionRequest(soap, tag?tag:"ns1:sessionRequest", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__sessionRequest ** SOAP_FMAC4 soap_get_PointerTons1__sessionRequest(struct soap *soap, ns1__sessionRequest **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__sessionRequest(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__result(struct soap *soap, ns1__result *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__result))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__result(struct soap *soap, const char *tag, int id, ns1__result *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__result);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__result ** SOAP_FMAC4 soap_in_PointerTons1__result(struct soap *soap, const char *tag, ns1__result **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__result **)soap_malloc(soap, sizeof(ns1__result *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__result *)soap_instantiate_ns1__result(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__result ** p = (ns1__result **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__result, sizeof(ns1__result), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__result(struct soap *soap, ns1__result *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__result);
	if (soap_out_PointerTons1__result(soap, tag?tag:"ns1:result", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__result ** SOAP_FMAC4 soap_get_PointerTons1__result(struct soap *soap, ns1__result **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__result(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__hent(struct soap *soap, ns1__hent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__hent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__hent(struct soap *soap, const char *tag, int id, ns1__hent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__hent);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__hent ** SOAP_FMAC4 soap_in_PointerTons1__hent(struct soap *soap, const char *tag, ns1__hent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__hent **)soap_malloc(soap, sizeof(ns1__hent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__hent *)soap_instantiate_ns1__hent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__hent ** p = (ns1__hent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__hent, sizeof(ns1__hent), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__hent(struct soap *soap, ns1__hent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__hent);
	if (soap_out_PointerTons1__hent(soap, tag?tag:"ns1:hent", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__hent ** SOAP_FMAC4 soap_get_PointerTons1__hent(struct soap *soap, ns1__hent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__hent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__invoice(struct soap *soap, ns1__invoice *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__invoice))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__invoice(struct soap *soap, const char *tag, int id, ns1__invoice *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__invoice);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__invoice ** SOAP_FMAC4 soap_in_PointerTons1__invoice(struct soap *soap, const char *tag, ns1__invoice **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__invoice **)soap_malloc(soap, sizeof(ns1__invoice *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__invoice *)soap_instantiate_ns1__invoice(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__invoice ** p = (ns1__invoice **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__invoice, sizeof(ns1__invoice), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__invoice(struct soap *soap, ns1__invoice *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__invoice);
	if (soap_out_PointerTons1__invoice(soap, tag?tag:"ns1:invoice", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__invoice ** SOAP_FMAC4 soap_get_PointerTons1__invoice(struct soap *soap, ns1__invoice **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__invoice(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__cow(struct soap *soap, ns1__cow *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__cow))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__cow(struct soap *soap, const char *tag, int id, ns1__cow *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__cow);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__cow ** SOAP_FMAC4 soap_in_PointerTons1__cow(struct soap *soap, const char *tag, ns1__cow **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__cow **)soap_malloc(soap, sizeof(ns1__cow *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__cow *)soap_instantiate_ns1__cow(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	ns1__cow ** p = (ns1__cow **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__cow, sizeof(ns1__cow), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__cow(struct soap *soap, ns1__cow *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__cow);
	if (soap_out_PointerTons1__cow(soap, tag?tag:"ns1:cow", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ns1__cow ** SOAP_FMAC4 soap_get_PointerTons1__cow(struct soap *soap, ns1__cow **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__cow(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTodouble(struct soap *soap, double *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_double);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTodouble(struct soap *soap, const char *tag, int id, double *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_double);
	if (id < 0)
		return soap->error;
	return soap_out_double(soap, tag, id, *a, type);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_in_PointerTodouble(struct soap *soap, const char *tag, double **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (double **)soap_malloc(soap, sizeof(double *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_double(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (double **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_double, sizeof(double), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTodouble(struct soap *soap, double *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTodouble);
	if (soap_out_PointerTodouble(soap, tag?tag:"double", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 double ** SOAP_FMAC4 soap_get_PointerTodouble(struct soap *soap, double **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTodouble(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_time);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag?tag:"string", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__qualifiedPurchase(struct soap *soap, std::vector<ns1__qualifiedPurchase * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__qualifiedPurchase(struct soap *soap, const std::vector<ns1__qualifiedPurchase * >*a)
{
	for (std::vector<ns1__qualifiedPurchase * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__qualifiedPurchase(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__qualifiedPurchase(struct soap *soap, const char *tag, int id, const std::vector<ns1__qualifiedPurchase * >*a, const char *type)
{
	for (std::vector<ns1__qualifiedPurchase * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__qualifiedPurchase(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__qualifiedPurchase * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__qualifiedPurchase(struct soap *soap, const char *tag, std::vector<ns1__qualifiedPurchase * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__qualifiedPurchase(soap, -1)))
		return NULL;
	ns1__qualifiedPurchase *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__qualifiedPurchase, SOAP_TYPE_std__vectorTemplateOfPointerTons1__qualifiedPurchase, sizeof(ns1__qualifiedPurchase), 1))
				break;
			if (!soap_in_PointerTons1__qualifiedPurchase(soap, tag, NULL, "ns1:qualifiedPurchase"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__qualifiedPurchase(soap, tag, &n, "ns1:qualifiedPurchase"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__qualifiedPurchase * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__qualifiedPurchase(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__qualifiedPurchase(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__qualifiedPurchase, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__qualifiedPurchase * >);
		if (size)
			*size = sizeof(std::vector<ns1__qualifiedPurchase * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__qualifiedPurchase * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__qualifiedPurchase * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__qualifiedPurchase * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__qualifiedPurchase(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__qualifiedPurchase * > %p -> %p\n", q, p));
	*(std::vector<ns1__qualifiedPurchase * >*)p = *(std::vector<ns1__qualifiedPurchase * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__stock(struct soap *soap, std::vector<ns1__stock * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__stock(struct soap *soap, const std::vector<ns1__stock * >*a)
{
	for (std::vector<ns1__stock * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__stock(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__stock(struct soap *soap, const char *tag, int id, const std::vector<ns1__stock * >*a, const char *type)
{
	for (std::vector<ns1__stock * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__stock(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__stock * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__stock(struct soap *soap, const char *tag, std::vector<ns1__stock * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__stock(soap, -1)))
		return NULL;
	ns1__stock *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__stock, SOAP_TYPE_std__vectorTemplateOfPointerTons1__stock, sizeof(ns1__stock), 1))
				break;
			if (!soap_in_PointerTons1__stock(soap, tag, NULL, "ns1:stock"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__stock(soap, tag, &n, "ns1:stock"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__stock * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__stock(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__stock(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__stock, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__stock * >);
		if (size)
			*size = sizeof(std::vector<ns1__stock * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__stock * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__stock * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__stock * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__stock(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__stock * > %p -> %p\n", q, p));
	*(std::vector<ns1__stock * >*)p = *(std::vector<ns1__stock * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__hent(struct soap *soap, std::vector<ns1__hent * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__hent(struct soap *soap, const std::vector<ns1__hent * >*a)
{
	for (std::vector<ns1__hent * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__hent(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__hent(struct soap *soap, const char *tag, int id, const std::vector<ns1__hent * >*a, const char *type)
{
	for (std::vector<ns1__hent * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__hent(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__hent * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__hent(struct soap *soap, const char *tag, std::vector<ns1__hent * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__hent(soap, -1)))
		return NULL;
	ns1__hent *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__hent, SOAP_TYPE_std__vectorTemplateOfPointerTons1__hent, sizeof(ns1__hent), 1))
				break;
			if (!soap_in_PointerTons1__hent(soap, tag, NULL, "ns1:hent"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__hent(soap, tag, &n, "ns1:hent"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__hent * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__hent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__hent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__hent, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__hent * >);
		if (size)
			*size = sizeof(std::vector<ns1__hent * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__hent * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__hent * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__hent * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__hent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__hent * > %p -> %p\n", q, p));
	*(std::vector<ns1__hent * >*)p = *(std::vector<ns1__hent * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__invoice(struct soap *soap, std::vector<ns1__invoice * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__invoice(struct soap *soap, const std::vector<ns1__invoice * >*a)
{
	for (std::vector<ns1__invoice * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__invoice(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__invoice(struct soap *soap, const char *tag, int id, const std::vector<ns1__invoice * >*a, const char *type)
{
	for (std::vector<ns1__invoice * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__invoice(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__invoice * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__invoice(struct soap *soap, const char *tag, std::vector<ns1__invoice * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__invoice(soap, -1)))
		return NULL;
	ns1__invoice *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__invoice, SOAP_TYPE_std__vectorTemplateOfPointerTons1__invoice, sizeof(ns1__invoice), 1))
				break;
			if (!soap_in_PointerTons1__invoice(soap, tag, NULL, "ns1:invoice"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__invoice(soap, tag, &n, "ns1:invoice"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__invoice * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__invoice(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__invoice(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__invoice, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__invoice * >);
		if (size)
			*size = sizeof(std::vector<ns1__invoice * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__invoice * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__invoice * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__invoice * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__invoice(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__invoice * > %p -> %p\n", q, p));
	*(std::vector<ns1__invoice * >*)p = *(std::vector<ns1__invoice * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTons1__cow(struct soap *soap, std::vector<ns1__cow * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTons1__cow(struct soap *soap, const std::vector<ns1__cow * >*a)
{
	for (std::vector<ns1__cow * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTons1__cow(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTons1__cow(struct soap *soap, const char *tag, int id, const std::vector<ns1__cow * >*a, const char *type)
{
	for (std::vector<ns1__cow * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTons1__cow(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<ns1__cow * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTons1__cow(struct soap *soap, const char *tag, std::vector<ns1__cow * >*a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTons1__cow(soap, -1)))
		return NULL;
	ns1__cow *n;
	short soap_flag = 0;
	do
	{	if (tag && *tag != '-')
			soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_ns1__cow, SOAP_TYPE_std__vectorTemplateOfPointerTons1__cow, sizeof(ns1__cow), 1))
				break;
			if (!soap_in_PointerTons1__cow(soap, tag, NULL, "ns1:cow"))
				break;
		}
		else
		{
			if (!soap_in_PointerTons1__cow(soap, tag, &n, "ns1:cow"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (tag && *tag != '-' && !soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC1 std::vector<ns1__cow * > * SOAP_FMAC2 soap_instantiate_std__vectorTemplateOfPointerTons1__cow(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTons1__cow(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTons1__cow, n, BKRepoService_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__cow * >);
		if (size)
			*size = sizeof(std::vector<ns1__cow * >);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW(std::vector<ns1__cow * >[n]);
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<ns1__cow * >);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<ns1__cow * >*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTons1__cow(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<ns1__cow * > %p -> %p\n", q, p));
	*(std::vector<ns1__cow * >*)p = *(std::vector<ns1__cow * >*)q;
}

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of BKRepoServiceC.cpp */
